/////////////////////////////////////////////////////////////////////////////////////////
// Failure 1: Compute KR cohomology of "figure-eight knot".
/////////////////////////////////////////////////////////////////////////////////////////

option(noredefine);option(noloadLib);option(redSB);
LIB "blow.lib";
LIB "linkhom.lib";
LIB "matrix.lib";
int nx=8;
ring rr0=0,(x(1..nx)),dp;
int N = 2; // The N in sl(N) link homology
printlevel = 1;

// First try "AABB", i.e. degree -2 bit of KR complex:

matrix A1a = mfIdentityDefect( x(1)^(N+1), x(5)^(N+1), x(1), x(5) );
matrix A1b = mfIdentityDefect( x(8)^(N+1), x(7)^(N+1), x(8), x(7) );
matrix A1 = MFtensor(A1b, A1a);
matrix A2a = mfIdentityDefect( x(6)^(N+1), x(2)^(N+1), x(6), x(2) );
matrix A2b = mfIdentityDefect( x(7)^(N+1), x(8)^(N+1), x(7), x(8) );
matrix A2 = MFtensor(A2b, A2a);
matrix B3 = mfWideEdge( x(3), x(5), x(4), x(6), N);
matrix B4 = mfWideEdge( x(4), x(2), x(3), x(1), N);

// The internal algebra is defined by the ideal J
ideal J = x(1)^N, x(2)^N, x(3)^N, x(4)^N, x(5)^N, x(6)^N, x(7)^N, x(8)^N;
intvec q = N, N, N, N, N, N, N, N;
number Nn = N + 1;
matrix C = 1/Nn * unitmat(8);

// Compute the ordinary tensor product, which is a two-periodic complex:

matrix D = MFtensor(MFtensor(MFtensor(A1,A2),B3),B4);
print(D*D == zeromat(256));

// Inflate the differential on this tensor product

matrix Dblow = mablow(D,J);

// This takes a few hours on haydn and goes through -- only in the end
// can Singular not define a matrix A[256*256][256*256]... 


// second try: only compute "BB":

option(noredefine);option(noloadLib);option(redSB);
LIB "blow.lib";
LIB "linkhom.lib";
LIB "matrix.lib";
int nx=2;
int ny=4;
ring rr=0,(x(1..nx),y(1..ny)),dp;
int N = 2; // The N in sl(N) link homology
printlevel = 1;

matrix B3 = mfWideEdge( x(1), y(3), x(2), y(4), N);
matrix B4 = mfWideEdge( x(2), y(2), x(1), y(1), N);
matrix D = MFtensor(B3,B4);

list L = fuseDefects(B3,B4, x(1)^(N+1) + x(2)^(N+1) );
matrix RD = L[1];
matrix ep = L[2];

print(RD*ep - ep*RD);
// ep is not idempotent on the nose:
print(ep*ep-ep);

def nR = ringWithoutXVars();
setring nR;

matrix RD = imap(rr, RD);
matrix ep = imap(rr, ep);
list RD_blocks = extractblockmat( RD );
matrix RD0 = RD_blocks[3];
matrix RD1 = RD_blocks[2];

module Im = dplus(RD0,RD1,RD0,RD1);

// To test whether ep belongs to Im, we must first convert it into a vector
vector v = matrix2vector(ep * ep - ep);

reduce( v, std(Im) );

// After running for a few hours on mascagni, this gives: 
// error: no more memory
// System 274944k:-1294928k Appl 203439k/71504k Malloc 0k/0k 
// Valloc 274944k/71504k Pages 52829/15907 Regions 537:547
// halt 14

/////////////////////////////////////////////////////////////////////////////////////////
// Failure 3: EXAMPLE S1 - Autopsy of something not idempotent on the nose
/////////////////////////////////////////////////////////////////////////////////////////

// This example is taken from linkhom-example1
option(noredefine);option(noloadLib);option(redSB);
LIB "blow.lib";
LIB "linkhom.lib";
LIB "matrix.lib";
int nx=2;
int ny=4;
ring rr=0,(x(1..nx),y(1..ny)),dp;
int N = 2; // The N in sl(N) link homology

matrix D1 = mfWideEdge(y(1),y(2),x(1),x(2),N);
matrix D2 = mfWideEdge(x(1),x(2),y(3),y(4),N);

ideal J = x(1)^N, x(2)^N;
intvec q = N, N;
number Nn = N;
matrix C[2][2] = 1/Nn, 0, 0, 1/Nn;

// Compute the ordinary tensor product
matrix D = MFtensor(D1,D2);
matrix Dblow = mablow(D,J);

// Reduce this inflated differential
list l = mfReduce(Dblow,1);
matrix RD = l[1];
matrix F = l[2]; // A homotopy equivalence F: Dblow -> RD
matrix G = l[3]; // A homotopy equivalence G: RD -> Dblow

matrix dq = dQ(D2, q, C);
matrix iddQ = ZZtensor( unitmat(ncols(D1)), dq ); // "iddQ" is "id x dQ_X"
matrix delQ = deltaQ(D, q);

// And finally the idempotent e on Dblow
int sign = (nx * (nx-1)) div 2;
matrix e = (-1)^(sign) * iddQ * delQ;

matrix ep = F * e * G;
print(ep * RD == RD * ep);
print(ep * ep == ep);

// So ep is not idempotent on the nose, but we will now check that it is idempotent up to
// homotopy, by showing that ep * ep - ep is null-homotopic.
def nR = ringWithoutXVars();
setring nR;

matrix RD = imap(rr, RD);
matrix ep = imap(rr, ep);
list RD_blocks = extractblockmat( RD );
matrix RD0 = RD_blocks[3];
matrix RD1 = RD_blocks[2];

// If Q = ( 0 & g // f & 0 ) and Q' = ( 0 & gs // fs & 0 ) are two matrix factorisations
// described by  matrices f, g and fs, gs in Singular, respectively, the output of 
// MFcohom(f,g,fs,gs) is a complete list of representatives of the cohomology Hom_MF(Q, Qâ€² ).

module Im = dplus(RD0,RD1,RD0,RD1);

// To test whether ep belongs to Im, we must first convert it into a vector
vector v = matrix2vector(ep * ep - ep);

reduce( v, std(Im) );

// After running for a few hours on mascagni, this gives: 
// error: no more memory 
// System -1326160k:-1187328k Appl 879034k/26181k Malloc 0k/0k 
// Valloc 905216k/26181k Pages 223147/3157 Regions 1768:1777
