//////////////////////////////////////////////////////////////////////////////////////
// EXAMPLE H1 - Computing Homs using idempotents, for x^d
//////////////////////////////////////////////////////////////////////////////////////

option(noredefine);option(noloadLib);option(redSB);
LIB "blow.lib";
LIB "matrix.lib";
int nx=1;
int ny=1;
ring rr=0,(x(1..nx),y(1..ny)),dp;
int baa=10;
poly W = x(1)^baa;

// We give ourselves matrix factorisations X and Y of W over k[x]
matrix X[2][2] = 0, x(1), x(1)^(baa-1), 0;
matrix Y[2][2] = 0, x(1)^4, x(1)^(baa-4), 0;

// For baa = 10 we calculate that Hom(Y,X) and Hom(Y,X[1]) are one dimensional using Exts,
// when X = (x^9, x) and Y = (x^6, x^4). This agrees with the idempotent calculation below.
list l = fuseDefects(MFdual(Y), X, W);
matrix RD = l[1]; // Reduced inflation of MFdual(Y) x X
matrix ep = l[2]; // Idempotent endomorphism of RD
print(ep * ep - ep); // is ep is an idempotent "on the nose"?
matrix final = mfSuspend( mfSplitIdempotent(RD, ep), nx );
print(final); // Yields k + k[1].

// We know that Hom(Y,X) is homotopy equivalent to the splitting of ep. Hence on
// cohomology (which is automatically the case here, since RD has zero differential) the
// matrix ep^0 is actually an idempotent matrix whose image is precisely H^0 Hom(Y,X).
// Hence dim H^0 Hom(Y,X) = rank(ep^0) and dim H^1 Hom(Y,X) = rank(ep^1)

matrix ep0 = extractblockmat(ep)[1];
matrix ep1 = extractblockmat(ep)[4];

print(mat_rk(ep0)); // Output is dim H^0 Hom(Y,X)
print(mat_rk(ep1)); // Output is dim H^1 Hom(Y,X) 

// Try running the above with Y or X something contractible, you will see that RD is contractible
// and the output is something like (1,0) as a MF of 0 over k.

//////////// Independent calculation of Homs using Ext ////////////

LIB "homolog.lib";
ring S = 0,(x(1)),ds;

int baa = 10;
poly W = x(1)^baa;

ideal I = W;
qring A = std(I);

matrix X[2][2] = 0, x(1), x(1)^(baa-1), 0;
matrix Y[2][2] = 0, x(1)^4, x(1)^(baa-4),0;

module M = [X[1,2]];
module N = [Y[1,2]];
module Nsusp = [Y[2,1]];

isCM(M); isCM(N);

// We have one dimensions worth of morphisms M -> N and M -> N[1] in the stable cat of CMs
Ext(2,N,M,1); Ext(2,Nsusp,M,1);

//////////////////////////////////////////////////////////////////////////////////////
// EXAMPLE H2 - Computing the endomorphism space of a certain MF over the E6 singularity
//////////////////////////////////////////////////////////////////////////////////////

option(noredefine);option(noloadLib);option(redSB);
LIB "blow.lib";
LIB "matrix.lib";
int nx=2;
int ny=1;
ring rr=0,(x(1..nx),y(1..ny)),dp;
poly W = x(1)^3 + x(2)^4;

matrix phi[3][3] = x(2)^3,x(1)^2,x(1) * x(2)^2,x(1) * x(2),-x(2)^2,x(1)^2,x(1)^2,-x(1) * x(2),-x(2)^3;
matrix psi[3][3] = x(2),0,x(1),x(1),-x(2)^2,0,0,x(1),-x(2);
matrix z[3][3];
matrix X = blockmat(z,phi,psi,z);

list l = fuseDefects(MFdual(X), X, W);
matrix RD = l[1];
matrix ep = l[2];
print(ep * ep - ep); // is ep is an idempotent "on the nose"?
matrix final = mfSuspend( mfSplitIdempotent(RD, ep) );
print(final);

// The output is that Hom(X,X) is six dimensional, and Hom(X,X[1]) is six dimensional. We can
// check this using Exts as follows

LIB "homolog.lib";
ring S = 0,(x(1),x(2)),ds;
poly W = x(1)^3 + x(2)^4;

ideal I = W;
qring A = std(I);

matrix phi[3][3] = x(2)^3,x(1)^2,x(1) * x(2)^2,x(1) * x(2),-x(2)^2,x(1)^2,x(1)^2,-x(1) * x(2),-x(2)^3;
matrix psi[3][3] = x(2),0,x(1),x(1),-x(2)^2,0,0,x(1),-x(2);
matrix z[3][3];
matrix X = blockmat(z,phi,psi,z);

module M = phi;
module Msusp = psi;

isCM(M); isCM(Msusp);

// We have one dimensions worth of morphisms M -> N and M -> N[1] in the stable cat of CMs
Ext(2,M,M,1); Ext(2,M,Msusp,1);

// We find that both spaces have dimension six, which corroborates what we calculated above.