version="0.1";
category="Miscellaneous";
// summary description of the library
info="
LIBRARY:   linkhom.lib  Computation of link homology using foam compilation
AUTHOR:    Nils Carqueville, Daniel Murfet
KEYWORDS:  matrix factorization, link homology

PROCEDURES:
";

LIB "linalg.lib";
LIB "matrix.lib";
LIB "ring.lib";
LIB "blow.lib"

////////////////////////////////////////////////////////////////////
// USAGE GUIDE
//
// We expect our ambient ring to be of the type
//
//     0,(x(1..nx),y(1..ny)),dp
// 
// where nx, ny are integer variables that we expect to be defined before calling
// any of the routines in this library. The x variables are the "internal" variables.
// The references to [KR] are to Khovanov and Rozansky "Matrix factorizations and
// link homology" arXiv:math/0401268v2.

////////////////////////////////////////////////////////////////////
// NOTES ON GRADING
//
// In [KR, p.47] all variables are assigned degree two. The conventions for graded
// matrix factorisations are explained in [KR, p.44]
//
// Note that the Jacobi algebra A = QQ[x]/(x^n) (notation of [KR]) is naturally graded,
// but this grading is shifted up by n - 1 so that |1| = n - 1 and |x^i| = 2i + n - 1.
// Note this shift is the opposite direction to the one given in (see [KR,p.45]), but
// actual calculations seem to suggest that this is an error in [KR]. See blow-example-grading.

/////////////////////////////////////////////////////////////////////////////////////
// g - returns the polynomial g of [KR] p.48.
/////////////////////////////////////////////////////////////////////////////////////

proc gpoly(poly s1, poly s2, int n)
{
    poly g = s1^(n+1);
    
    int i;
    for(i=1;i<=(n+1)/2;i++)
    {
        g = g + (n+1) * (-1)^(i) * ( binomial(n-i,i-1) * s2^(i) * s1^(n+1-2*i) )/i;
    }
    
    return(g);
}

////////////////////////////////////////////////////////////////////
// mfWideEdge
//
// We are given four variables a,b,c,d and an integer N, and we return
// the matrix factorisation of a^(n+1) + b^(n+1) - c^(n+1) - d^(n+1)
// associated by Khovanov and Rozansky to a wide edge in the planar
// diagram of a link (see p.48 of [KR]). Let us include the
// following picture of a wide edge
//
//       a        b
//         \   /
//          \/
//          |
//          |
//         /\
//       /   \
//     c       d
//
// where a,b,c,d are variables labelled on the edges as shown (see Figure 5
// on p.6 of [KR]).
//
// WARNING: Note that in Figure 8 on p.9 of [KR] the variable ordering on the "bottom"
// two variables is swapped. This becomes relevant when you start reading Section 6
// which assigns a factorisation to labelling chosen in Figure 8. With our conventions,
// this means that if you call
//
//  matrix D = mfWideEdge(x(1),x(2),x(4),x(3),N);
//
// Then the matrix D you get will be the (Q1,Q2) pair written on p.50 of [KR]. Note however
// that everything is symmetric for the exchange x(1) <-> x(2) and x(4) <-> x(3), so there
// is no need to worry about this ordering.
////////////////////////////////////////////////////////////////////

proc mfWideEdge(poly a, poly b, poly c, poly d, int n)
{
    poly W = a^(n+1) + b^(n+1) - c^(n+1) - d^(n+1);
    
    // Following KR we write W = (a + b - c - d)u1 + (ab - cd)u2 
    poly u1 = (gpoly(a + b, a*b, n) - gpoly(c + d, a*b, n))/(a+b-c-d);
    poly u2 = (gpoly(c + d, a*b, n) - gpoly(c + d, c*d, n))/(a*b-c*d);
    
    if( W != u1 * (a + b - c - d) + u2 * (a * b - c * d) )
    {
        print("[mfWideEdge] Something wrong in the calculation, exiting.");
        return();
    }
    
    matrix koszul1[2][2] = 0, a + b - c - d, u1, 0;
    matrix koszul2[2][2] = 0, a * b - c * d, u2, 0;
    
    // Note the order that we tensor these two Koszul complexes is opposite
    // to the order suggested on p.48 of [KR]. This is done so as to agree
    // with the matrices written on p.50.
    matrix D = MFtensor(koszul2, koszul1);
    
    return(D);
}

proc mfWideEdgeGrading(int n)
{
    // Note that deg(u1) = n and deg(u2) = n - 1 so as written on 
    // [KR, p.48] the Koszul factorisations koszul1 and koszul2 have
    // respective grading vectors
    intvec g = 0, 1-n;
    intvec h = 0, 3-n;
    
    // Grading vector on the tensor product
    intvec r = MFtensorGradings(h, g);
    
    // The grading is then shifted by -1, as defined on [KR, p.48]
    int i;
    for(i=1;i<=size(r);i++){ r[i] = r[i] - 1; }
    
    return(r);
}

////////////////////////////////////////////////////////////////////
// mfIdentityDefect
//
// We are given two potentials W1 and W2 and two variables y and x.
// We assume that W1 = W(y) and W2 = W(x) for some fixed polynomial
// W and we return the identity defect W2 -> W1
////////////////////////////////////////////////////////////////////

proc mfIdentityDefect(poly W1, poly W2, poly y, poly x)
{
    matrix koszul1[2][2] = 0, y - x, (W1 - W2)/(y - x), 0;
    return(koszul1);
}

// We are given the degree of some homogeneous potential
proc mfIdentityDefectGrading(int dg)
{
    int n = dg - 1;
    
    // We have |W| = 2(n+1) and the identity defect is given the grading
    // R ---> R{1+n-|(W1-W2)/(y-x)|} --> R, but |(W1-W2)/(y-x)| = 2 * n so
    // this is R ---> R{1-n} ---> R, see [KR, p.45].
    
    intvec g = 0, 1-n;
    return(g);
}

////////////////////////////////////////////////////////////////////
// mfChi0
//
// mfChi0(x(1),x(2),x(3),x(4),N) is the map C(Gamma^0) --> C(Gamma^1)
// from [KR, p.50].
////////////////////////////////////////////////////////////////////

proc mfChi0(poly p(1), p(2), p(3), p(4), int N)
{
    poly pi23 = ( p(2)^(N+1) - p(3)^(N+1) )/( p(2)-p(3) );
    poly u1 = ( gpoly(p(1)+p(2), p(1)*p(2), N) - gpoly(p(3)+p(4), p(1)*p(2), N) )/( p(1)+p(2)-p(3)-p(4) );
    poly u2 = ( gpoly(p(3)+p(4), p(1)*p(2), N) - gpoly(p(3)+p(4), p(3)*p(4), N) )/( p(1)*p(2)-p(3)*p(4) );
    poly aa1 = -u2 + ( u1 +  p(1) * u2 - pi23 )/( p(1) - p(4) );

    matrix chi0[4][4] = p(4)-p(2), 0, 0,    0,
                    aa1,        1, 0,    0,
                    0,         0, p(4), -p(2),
                    0,         0, -1,   1;            // We set mu=0.
                    
    return(chi0);
}


////////////////////////////////////////////////////////////////////
// mfChi1
//
// mfChi1(x(1),x(2),x(3),x(4),N) is the map C(Gamma^1) --> C(Gamma^0)
// from [KR, p.51].
////////////////////////////////////////////////////////////////////

proc mfChi1(poly p(1), p(2), p(3), p(4), int N)
{
    poly pi23 = ( p(2)^(N+1) - p(3)^(N+1) )/( p(2)-p(3) );
    poly u1 = ( gpoly(p(1)+p(2), p(1)*p(2), N) - gpoly(p(3)+p(4), p(1)*p(2), N) )/( p(1)+p(2)-p(3)-p(4) );
    poly u2 = ( gpoly(p(3)+p(4), p(1)*p(2), N) - gpoly(p(3)+p(4), p(3)*p(4), N) )/( p(1)*p(2)-p(3)*p(4) );
    poly aa2 = ( u1 + p(1) * u2 - pi23 )/( p(4)-p(1) );
    poly aa3 = p(1) - p(3);

    matrix chi1[4][4] = 1, 0, 0,    0,
                    aa2,        aa3, 0,    0,
                    0,         0, 1, p(3),
                    0,         0, 1, p(1);            // We set lambda=0.
                    
    return(chi1);
}