version="0.1";
category="Miscellaneous";
// summary description of the library
info="
LIBRARY:   linkhom.lib  Computation of link homology using foam compilation
AUTHOR:    Nils Carqueville, Daniel Murfet
KEYWORDS:  matrix factorization, link homology

PROCEDURES:
";

LIB "linalg.lib";
LIB "matrix.lib";
LIB "ring.lib";
LIB "blow.lib";

////////////////////////////////////////////////////////////////////
// USAGE GUIDE
//
// We expect our ambient ring to be of the type
//
//     0,(x(1..nx),y(1..ny)),dp
// 
// where nx, ny are integer variables that we expect to be defined before calling
// any of the routines in this library. The x variables are the "internal" variables.
// The references to [KR] are to Khovanov and Rozansky "Matrix factorizations and
// link homology" arXiv:math/0401268v2.

////////////////////////////////////////////////////////////////////
// NOTES ON GRADING
//
// In [KR, p.47] all variables are assigned degree two. The conventions for graded
// matrix factorisations are explained in [KR, p.44]
//
// Note that the Jacobi algebra A = QQ[x]/(x^n) (notation of [KR]) is naturally graded,
// but this grading is shifted up by n - 1 so that |1| = n - 1 and |x^i| = 2i + n - 1.
// Note this shift is the opposite direction to the one given in (see [KR,p.45]), but
// actual calculations seem to suggest that this is an error in [KR]. See blow-example-grading.

////////////////////////////////////////////////////////////////////
// Notes on optimisation
//
// Currently mfCompileWeb compiles maps between webs. It would be better to compile
// webs and store the compilation together with the necessary maps.

/////////////////////////////////////////////////////////////////////////////////////
// g - returns the polynomial g of [KR] p.48.
/////////////////////////////////////////////////////////////////////////////////////

proc gpoly(poly s1, poly s2, int n)
{
    poly g = s1^(n+1);
    
    int i;
    for(i=1;i<=(n+1)/2;i++)
    {
        g = g + (n+1) * (-1)^(i) * ( binomial(n-i,i-1) * s2^(i) * s1^(n+1-2*i) )/i;
    }
    
    return(g);
}

////////////////////////////////////////////////////////////////////
// mfWideEdge
//
// We are given four variables a,b,c,d and an integer N, and we return
// the matrix factorisation of a^(n+1) + b^(n+1) - c^(n+1) - d^(n+1)
// associated by Khovanov and Rozansky to a wide edge in the planar
// diagram of a link (see p.48 of [KR]). Let us include the
// following picture of a wide edge
//
//       a        b
//         \   /
//          \/
//          |
//          |
//         /\
//       /   \
//     d       c
//
// where a,b,c,d are variables labelled on the edges as shown. Note that this
// is the ordering convention of Figure 8 on p.9 of [KR]. With this convention
// if you call
//
// matrix D = mfWideEdge(x(1),x(2),x(3),x(4),N);
//
// Then the matrix D you get will be the (Q1,Q2) pair written on p.50 of [KR]. Note however
// that everything is symmetric for the exchange x(1) <-> x(2) and x(4) <-> x(3).
////////////////////////////////////////////////////////////////////

proc mfWideEdge(poly a, poly b, poly c, poly d, int n)
{
    poly W = a^(n+1) + b^(n+1) - c^(n+1) - d^(n+1);
    
    // Following KR we write W = (a + b - c - d)u1 + (ab - cd)u2 
    poly u1 = (gpoly(a + b, a*b, n) - gpoly(c + d, a*b, n))/(a+b-c-d);
    poly u2 = (gpoly(c + d, a*b, n) - gpoly(c + d, c*d, n))/(a*b-c*d);
    
    if( W != u1 * (a + b - c - d) + u2 * (a * b - c * d) )
    {
        print("[mfWideEdge] Something wrong in the calculation, exiting.");
        return();
    }
    
    matrix koszul1[2][2] = 0, a + b - c - d, u1, 0;
    matrix koszul2[2][2] = 0, a * b - c * d, u2, 0;
    
    // Note the order that we tensor these two Koszul complexes is opposite
    // to the order suggested on p.48 of [KR]. This is done so as to agree
    // with the matrices written on p.50.
    matrix D = MFtensor(koszul2, koszul1);
    
    return(D);
}

proc mfWideEdgeGrading(int n)
{
    // Note that deg(u1) = n and deg(u2) = n - 1 so as written on 
    // [KR, p.48] the Koszul factorisations koszul1 and koszul2 have
    // respective grading vectors
    intvec g = 0, 1-n;
    intvec h = 0, 3-n;
    
    // Grading vector on the tensor product
    intvec r = MFtensorGradings(h, g);
    
    // The grading is then shifted by -1, as defined on [KR, p.48]
    int i;
    for(i=1;i<=size(r);i++){ r[i] = r[i] - 1; }
    
    return(r);
}

////////////////////////////////////////////////////////////////////
// mfIdentityDefect
//
// We are given two potentials W1 and W2 and two variables y and x.
// We assume that W1 = W(y) and W2 = W(x) for some fixed polynomial
// W and we return the identity defect W2 -> W1
////////////////////////////////////////////////////////////////////

proc mfIdentityDefect(poly W1, poly W2, poly y, poly x)
{
    matrix koszul1[2][2] = 0, y - x, (W1 - W2)/(y - x), 0;
    return(koszul1);
}

// We are given the degree of some homogeneous potential
proc mfIdentityDefectGrading(int dg)
{
    int n = dg - 1;
    
    // We have |W| = 2(n+1) and the identity defect is given the grading
    // R ---> R{1+n-|(W1-W2)/(y-x)|} --> R, but |(W1-W2)/(y-x)| = 2 * n so
    // this is R ---> R{1-n} ---> R, see [KR, p.45].
    
    intvec g = 0, 1-n;
    return(g);
}

////////////////////////////////////////////////////////////////////
// mfIdentityEdge
//
// We are given four variables a,b,c,d and an integer N, and we return
// the matrix factorisation of a^(n+1) + b^(n+1) - c^(n+1) - d^(n+1)
// associated by Khovanov and Rozansky to the Gamma0 diagram of Figure 8
// Let us include the following picture of a wide edge
//
//       a        b
//         \   /
//          \/
//          |
//          |
//         /\
//       /   \
//     d       c
//
// where a,b,c,d are variables labelled on the edges as shown. The return
// is the tensor product of L^b_c with L^a_d (in KR's notation), in that
// order. Note that this is not symmetric with respect to the interchange
// a <-> b or c <-> d, so the ordering of the variables matters.
////////////////////////////////////////////////////////////////////

proc mfIdentityEdge(poly a, poly b, poly c, poly d, int n)
{
    matrix Aa = mfIdentityDefect( a^(n+1), d^(n+1), a, d );
    matrix Ab = mfIdentityDefect( b^(n+1), c^(n+1), b, c );
    
    // Note the order of the tensor factors (this is opposite to what
    // a first reading of the third line of [KR, p.50] would suggest,
    // but is necessary to reproduce the matrices P0 and P1 there, and
    // to make chi0 = (U0,U1) into a morphism of MFs).
    matrix A = MFtensor(Ab, Aa);
    
    return(A);
}

proc mfIdentityEdgeGrading(int n)
{
    intvec Aagr = mfIdentityDefectGrading( n+1 );
    intvec Abgr = mfIdentityDefectGrading( n+1 );
    intvec Agr = MFtensorGradings(Abgr, Aagr);
    
    return(Agr);
}

////////////////////////////////////////////////////////////////////
// checklist
//
// checklist(l,p) gives 1 if p is an element of the list l,
// otherwise it gives 0.
////////////////////////////////////////////////////////////////////

proc checklist(list l, p)
{
    int inlist;
    for(int i=1; i<=size(l); i++)
    {
        def li = l[i];
        if(p==li)
        {
            inlist=1;
        }
    }
    return(inlist);
}


////////////////////////////////////////////////////////////////////
// removefromlist
//
// removefromlist(l,p) gives back the list l, but with all instances of
// entries p deleted. For example:
// removefromlist( list(1,2,2,3,2), 2 ) = list(1,3). 
////////////////////////////////////////////////////////////////////

proc removefromlist(list l, poly p)
{
    for(int i=1; i<=size(l); i++)
    {
        def li = l[i];
        if(p==li)
        {
            l = delete(l,i);
            i=i-1;
        }
    }
    return(l);
}


////////////////////////////////////////////////////////////////////
// mfVertex
//
// mfVertex(zeroOrOne, varis, N) gives the "KR-vertex" of type 0
// (tensor product of two identity defects) or of type 1 (wide edge
// defect) in the list of variables varis. N as in sl(N). The ordering
// of the variables in varis corresponds to 
//
//     varis[1]   varis[2]
//           \   /
//            \/
//            |
//            |
//           /\
//         /   \
//   varis[4]    varis[3]
//
// See the comments preceeding mfIdentityEdge for an idea of why the
// ordering here is significant.
////////////////////////////////////////////////////////////////////

proc mfVertex(int zeroOrOne, list varis, int N)
{
    if( zeroOrOne == 0 )
    {
        matrix A = mfIdentityEdge( varis[1], varis[2], varis[3], varis[4], N );
        return(A);
    }
        
    if( zeroOrOne == 1 )
    {
        matrix A = mfWideEdge( varis[1], varis[2], varis[3], varis[4], N );
        return(A);
    }
}

////////////////////////////////////////////////////////////////////
// mfVertexGrading
////////////////////////////////////////////////////////////////////

proc mfVertexGrading(int zeroOrOne, list varis, int N)
{
   if( zeroOrOne == 0 )
   {
       intvec Agr = mfIdentityEdgeGrading(N);
       return(Agr);
   }
   
   if( zeroOrOne == 1 )
   {
       intvec Agr = mfWideEdgeGrading(N);
       return(Agr);
   }
}

////////////////////////////////////////////////////////////////////
// mfChi
//
// mfChi(zeroOrOne,x(1),x(2),x(3),x(4),N) is the map C(Gamma^0) --> C(Gamma^1)
// from [KR, p.50] for zeroOrOne=0, and the map C(Gamma^1) --> C(Gamma^0)
// from [KR, p.51] for zeroOrOne=1.
////////////////////////////////////////////////////////////////////

proc mfChi(int zeroOrOne, poly p(1), p(2), p(3), p(4), int N)
{
    if( zeroOrOne == 0 )
    {
        poly pi23 = ( p(2)^(N+1) - p(3)^(N+1) )/( p(2)-p(3) );
        poly u1 = ( gpoly(p(1)+p(2), p(1)*p(2), N) - gpoly(p(3)+p(4), p(1)*p(2), N) )/( p(1)+p(2)-p(3)-p(4) );
        poly u2 = ( gpoly(p(3)+p(4), p(1)*p(2), N) - gpoly(p(3)+p(4), p(3)*p(4), N) )/( p(1)*p(2)-p(3)*p(4) );
        poly aa1 = -u2 + ( u1 +  p(1) * u2 - pi23 )/( p(1) - p(4) );

        matrix chi0[4][4] = p(4)-p(2), 0, 0,    0,
                        aa1,        1, 0,    0,
                        0,         0, p(4), -p(2),
                        0,         0, -1,   1;            // We set mu=0.                    
        return(chi0);
    }

    if( zeroOrOne == 1 )
    {
        poly pi23 = ( p(2)^(N+1) - p(3)^(N+1) )/( p(2)-p(3) );
        poly u1 = ( gpoly(p(1)+p(2), p(1)*p(2), N) - gpoly(p(3)+p(4), p(1)*p(2), N) )/( p(1)+p(2)-p(3)-p(4) );
        poly u2 = ( gpoly(p(3)+p(4), p(1)*p(2), N) - gpoly(p(3)+p(4), p(3)*p(4), N) )/( p(1)*p(2)-p(3)*p(4) );
        poly aa2 = ( u1 + p(1) * u2 - pi23 )/( p(4)-p(1) );
        poly aa3 = p(1) - p(3);

        matrix chi1[4][4] = 1, 0, 0,    0,
                        aa2,        aa3, 0,    0,
                        0,         0, 1, p(3),
                        0,         0, 1, p(1);            // We set lambda=0.
    
        return(chi1);
    }
}

////////////////////////////////////////////////////////////////////
// mfCompileWeb
//
// mfCompileWeb(D1, D2, chitype, chiposition, N) compiles two webs
// given by D1 and D2 as described below, together with a map
// between the two webs that is a tensor product of identity maps
// and one chi-map as the chiposition-th tensor factor. The output
// of mfCompileWeb is a list with four entries: the second entry
// is the component (0 or 1) of the reduced MFs of zero, i.e. 
// rational complexes ofvector spaces, that is non-zero, 
// and the first entry gives the reduced map between these two
// components. (Of course, we can read off from the number of rows
// and columns of this map what the two complexes are.)
// The third and fourth entries are the grading vectors on the
// source and target vector spaces respectively.
// NOTE that we should only call mfCompileWeb in a ring defined by
//     int nx=2; int ny=4; ring rr=0,(x(1..nx),y(1..ny)),dp;.
// For example, we can run 
//     mfCompileWeb(D1, D2, chitype, chiposition, N);
// after having defined:
// intvec edgevec(1) = 1,7,5,8;
// intvec edgevec(2) = 6,8,2,7;
// intvec edgevec(3) = 3,5,4,6;
// intvec edgevec(4) = 4,2,3,1;
// list D1 = list(0,edgevec(1) ), list(0,edgevec(2) ), list(1,edgevec(3) ), list(1,edgevec(4) );
// list D2 = list(0,edgevec(1) ), list(0,edgevec(2) ), list(1,edgevec(3) ), list(0,edgevec(4) );
// N=2
// int chitype = 1;
// int chiposition = 4;
// NOTE that we order the entries of the intvecs e = edgevec(i) such
// that the two outgoing edges at vertex i are labelled by the
// first two entries of edgevec(i), and so that the labels continue
// clockwise (orientations being up the page)
//
//        e[1]    e[2]
//           \   /
//            \/
//            |
//            |
//           /\
//         /   \
//      e[4]    e[3]
//
// SKETCH of how to compile (certain) webs automatically:
//
//  (1) We assume that we are given a KR-type web, i.e. a planar graph with only two
//      kinds of 4-valent vertices, two of whose incident edges are incoming and the other 
//      two are outgoing, and there are no external edges. 
//  (2) We further assume that the vertices can be assigned distinct labels 1,...,v where
//      v=(total number of vertices) such that vertices 1 and 2 are joined by precisely two
//      edges, that the fusion of vertices 1 and 2 is joined with vertex 3 by precisely two
//      edges etc.; only the fusion of the first v-1 vertices is joined by precisely four
//      edges with the final vertex v.
//      NOTE: We make no assumption that the two edges between 1 and 2 are both oriented
//      from 1 to 2 (in fact the orientations on the two edges could be opposite).
//  (3) Hence we can represent such a web by the following data D: D is a list of v elements,
//      each of which is again a list of two elements: D[i] = list(vertextype(i),edgevec(i)) for
//      i=1,...,v where vertextype(i) is a string that indicates whether the vertex is the tensor
//      product of two identity defects (label A) or a wide edge defect (label B), and edgevec(i)
//      is an intvec of length 4 such that its first two entries label the outgoing edges and 
//      its last two entries label the incoming edges of the i-th vertex. (There are 2*v edges,
//      and the D uniquely determines the kind of web that we consider.)
//  (4) The only morphisms of webs with v vertices that we will encounter are tensor products 
//      of v-1 identity maps and either one chi0 or one chi1. Thus to specify a morphism of webs
//      we only have to indicate at which position i chi0 oder chi1 sits. Its variable dependence
//      will be given by edgevec(i) and the identifications with x- and y-variables made below.
//  (5) Let us be given two web data D1 and D2 with D1[i] = list(vertextype1(i),edgevec1(i)) and
//      similarly for D2, and let us be given a map alpha between D1 and D2. Our aim is to reduce
//      this (where by reducing we mean both our usual blowing-up and idempotent-splitting).
//      We start by identifying which of the eight entries in edgevec1(1) and edgevec1(2) 
//      occur twice and call them int(1) and int(2). The remaining four entries we call 
//      ext(1),...,ext(4). The ordering is not important. Then we make the idenfication:
//          x(i) corresponds to int(i) for i=1,2,
//          y(i) corresponds to ext(i) for i=1,2,3,4.
//  (6) Using this and the data D1, D2, alpha, we compute the fusions of the first two vertices
//      in both webs as well as the morphism between these two fused subwebs in the usual way 
//      (see linkhom-example-figure-eight-knot).
//  (7) Identify which two numbers in edgevec1(3) are not in {ext(i)}_{i=1,...,4} and call them
//      n(1) and n(2). Furthermore, determine which of the numbers in {ext(i)}_{i=1,...,4} also
//      appear in edgevec1(3). Let us say these are ext(i1) and ext(i2). Now we make new
//      identifications as follows:
//          x(1) cooresponds to ext(i1),
//          x(2) cooresponds to ext(i2),
//          y(k) corresponds to ext(k) for k in {1,2,3,4}\{i1,i2},
//          y(i1) cooresponds to n(1),
//          x(i2) cooresponds to n(2).
//  (8) Redefine everything that was produced in step (6):
//      bla = subst( bla, y(i1), x(1) ); bla = subst( bla, y(i2), x(2) );.
//  (9) Now compute the next fusion as usual, i.e. repeat the obvious adaptation of steps
//      (7) to (9) until the first v-1 vertices are fused.
// (10) Rename y(1),...,y(4) into x(1),...x(4), write the last vertex in the correct
//      x-variables (as encoded in edgevec1(v) and the most recent identifications of variables
//      and edge labels), and do the last fusion as usual. 
////////////////////////////////////////////////////////////////////

// TODO: Will mfCompileWeb work when there are only two vertices in the web?
// TODO: possible signs due to the ordering of internal variables?
proc mfCompileWeb(list D1, D2, int chitype, int chiposition, int N)
{
    int paranoidChecks = 1; // If set to 1 then we perform additional stringent sanity checks
    
    def RRR = basering;
    int websize = size(D1);
    int i,j,k,i1,i2,i3,i4;
    
    // Sanity checks
    if( websize != size(D2) )
    {
        print("[mfCompileWeb] Passed webs of different sizes, exiting.");
        return();
    }
    if( chitype != 0 && chitype != 1 || chiposition > websize )
    {
        print("[mfCompileWeb] chitype not in {0,1} or chiposition > web size, exiting.");
        return();
    }
    
    // Define the morphisms between the unreduced tensor factors to be
    // identity maps (only later redefine the chipositions-th alpha to
    // be the appropriate chi map):
    
    for( i=1; i<=websize; i++ )
    {
        matrix alpha(i) = unitmat(4);
    }
    
    // Fusion of the first two vertices.
    // Find out which are the two internal variables inter(1) and inter(2)
    // between vertices 1 and 2:
    
    list L1,L2;
    for( i=1; i<=4; i++ )
    {
        L1[i] = D1[1][2][i];
        L2[i] = D1[2][2][i];
    }
    
    int z = 1;
    for( i1=1; i1<=4; i1++ )
    {
        for( i2=1; i2<=4; i2++ )
        {
            if( L1[i1] == L2[i2] )
            {
                int inter(z) = L1[i1];
                z = z + 1;
            }
        }
    }
    // Note that inter(1),inter(2) occur in the same order which these edges
    // appear in edgevec(1).
    
    // Call the remaining labels of edges incident on either of the two
    // vertices ext(1),...,ext(4). The order is to enumerate the external
    // edges in edgevec(1) and then those in edgevec(2).
    
    L1 = removefromlist(removefromlist( L1, inter(1) ), inter(2) );
    L2 = removefromlist(removefromlist( L2, inter(1) ), inter(2) );     
    for( i=1; i<=2; i++ )
    {
        int ext(i) = L1[i];
        int ext(i+2) = L2[i];
    }
    
    // At this stage, the variable listOfCVariableNames[i] corresponds to 
    // the edge label listOfEdgeLabels[i] for i=1,...,6:
    
    list listOfCVariableNames = x(1),x(2),y(1),y(2),y(3),y(4);
    list listOfEdgeLabels = inter(1),inter(2),ext(1),ext(2),ext(3),ext(4);
    
    // Find the variable dependence of the first two vertices:
    list varis(1), varis(2);
    for( i1=1; i1<=4; i1++ )
    {
        for( i2=1; i2<=6; i2++ )
        {
            if( D1[1][2][i1] == listOfEdgeLabels[i2] )
            {
                varis(1)[i1] = listOfCVariableNames[i2];
            }
            if( D1[2][2][i1] == listOfEdgeLabels[i2] )
            {
                varis(2)[i1] = listOfCVariableNames[i2];
            }

        }
    }
    
    // V1(i) is the MF associated to the i-th vertex in web 1, 
    // V2(i) is the MF associated to the i-th vertex in web 2: 
    matrix V1(1) = mfVertex( D1[1][1], varis(1), N ); 
    matrix V1(2) = mfVertex( D1[2][1], varis(2), N );
    matrix V2(1) = mfVertex( D2[1][1], varis(1), N );
    matrix V2(2) = mfVertex( D2[2][1], varis(2), N );
    
    intvec V1gr(1) = mfVertexGrading( D1[1][1], varis(1), N );
    intvec V1gr(2) = mfVertexGrading( D1[2][1], varis(2), N );
    intvec V2gr(1) = mfVertexGrading( D2[1][1], varis(1), N );
    intvec V2gr(2) = mfVertexGrading( D2[2][1], varis(2), N );
    
    // Now start to reduce V1(1) x V1(2), V2(1) x V2(2) and the map between them:
        
    ideal J = x(1)^N, x(2)^N;
    intvec q = N, N;
    number Nn = N + 1;
    matrix C[2][2] = 1/Nn, 0, 0, 1/Nn;

    // The matrix webmap will eventually be the reduced map between the two
    // webs. At the moment, it is simply the map V1(1) x V1(2) --> V2(1) x V2(2):
    
    for( i=1; i<=2; i++ )
    {
        if( i == chiposition )
        {
            alpha(i) = mfChi(chitype, varis(i)[1], varis(i)[2], varis(i)[3], varis(i)[4], N);
            break;
        }
    }
    
    // Compute the ordinary tensor product:
    matrix T1 = MFtensor( V1(1), V1(2) );
    matrix T1blow = mablow(T1,J);
    matrix T2 = MFtensor( V2(1), V2(2) );
    matrix T2blow = mablow(T2,J);
    
    intvec T1gr = MFtensorGradings( V1gr(1), V1gr(2) );
    intvec T1blowgr = mablowGrading( T1gr, J, N );
    intvec T2gr = MFtensorGradings( V2gr(1), V2gr(2) );
    intvec T2blowgr = mablowGrading(T2gr,J, N);

    // Inflate the induced morphism between the webs
    matrix webmap = mablow( ZZtensor( alpha(1), alpha(2) ), J );
    
    // Reduce this inflated differential:
    list l1 = mfReduce(T1blow,1);
    matrix RT1 = l1[1];
    matrix F1(1) = l1[2]; // A homotopy equivalence T1blow -> RT1
    matrix G1(1) = l1[3]; // A homotopy equivalence RT1 -> T1blow
    list l2 = mfReduce(T2blow,1);
    matrix RT2 = l2[1];
    matrix F2(1) = l2[2]; // A homotopy equivalence T2blow -> RT2
    matrix G2(1) = l2[3]; // A homotopy equivalence RT2 -> T2blow
    
    intvec RT1gr = computeGradingFromInjection(G1(1),T1blowgr);
    intvec RT2gr = computeGradingFromInjection(G2(1),T2blowgr);
    
    // Define d1(1) to be the product over all outgoing edges labelled by x-variables
    // of the derivatives of V1(1) with respect to these variables, and
    // define d1(2) to be the product over all outgoing edges labelled by x-variables
    // of the derivatives of V1(2) with respect to these variables, and
    // similarly for d2(1) and d2(2):
    
    matrix d1(1) = unitmat( ncols( V1(1) ) );
    matrix d1(2) = unitmat( ncols( V1(2) ) );
    matrix d2(1) = unitmat( ncols( V2(1) ) );
    matrix d2(2) = unitmat( ncols( V2(2) ) );
    for( i=1; i<=2; i++ )
    {
        // vertex V1(1):
        if( x(1) == varis(1)[i] )
        {
            d1(1) = d1(1) * diff( V1(1), x(1) );
            d2(1) = d2(1) * diff( V2(1), x(1) );
        }
        
        if( x(2) == varis(1)[i] )
        {
            d1(1) = d1(1) * diff( V1(1), x(2) );
            d2(1) = d2(1) * diff( V2(1), x(2) );
        }
        
        // vertex V1(2):
        if( x(1) == varis(2)[i] )
        {
            d1(2) = d1(2) * diff( V1(2), x(1) );
            d2(2) = d2(2) * diff( V2(2), x(1) );
        }
        
        if( x(2) == varis(2)[i] )
        {
            d1(2) = d1(2) * diff( V1(2), x(2) );
            d2(2) = d2(2) * diff( V2(2), x(2) );
        }
    }
    // TODO: possible signs?
    
    matrix diff1(1) = ZZtensor( d1(1), unitmat( ncols( V1(2) ) ) );
    matrix diff1(2) = ZZtensor( unitmat( ncols( V1(1) ) ), d1(2) );
    matrix iddQ1 = mablow( det(C) * diff1(1) * diff1(2), J );
    matrix diff2(1) = ZZtensor( d2(1), unitmat( ncols( V2(2) ) ) );
    matrix diff2(2) = ZZtensor( unitmat( ncols( V2(1) ) ), d2(2) );
    matrix iddQ2 = mablow( det(C) * diff2(1) * diff2(2), J );

    matrix delta1(1) = mablow_delta(T1, 1, N, J);
    matrix delta1(2) = mablow_delta(T1, 2, N, J);
    matrix delQ1 = delta1(1) * delta1(2);
    matrix delta2(1) = mablow_delta(T2, 1, N, J);
    matrix delta2(2) = mablow_delta(T2, 2, N, J);
    matrix delQ2 = delta2(1) * delta2(2);
    
    // And finally the idempotents e1,e2 on T1blow,T2blow
    matrix e1 = iddQ1 * delQ1;
    matrix e2 = iddQ2 * delQ2;

    matrix ep1 = F1(1) * e1 * G1(1);
    matrix ep2 = F2(1) * e2 * G2(1);
    
    // Sanity checks:
    if( ep1 * RT1 != RT1 * ep1 )
    {
        print("[mfCompileWeb] The reduced idempotent (up to homotopy) ep1 is not an endomorphism of RT1, exiting.");
        return();
    }
    if( ep2 * RT2 != RT2 * ep2 )
    {
        print("[mfCompileWeb] The reduced idempotent (up to homotopy) ep2 is not an endomorphism of RT2, exiting.");
        return();
    }
    
    if( paranoidChecks )
    {
        // Check that ep1 and ep2 are idempotent up to homotopy
        matrix ep1ck = ep1;
        ep1ck = subst( ep1ck, y(1), 0 );
        ep1ck = subst( ep1ck, y(2), 0 );
        ep1ck = subst( ep1ck, y(3), 0 );
        ep1ck = subst( ep1ck, y(4), 0 );
        if( ep1ck * ep1ck != ep1ck )
        {
            // NOTE: If this test fails to pass, it is usually due to a sign problem...
            
            // TODO DEBUG DEBUG WARNING UGLY HACK
            ep1 = -ep1;
            
            // print("[mfCompileWeb] ep1 is not idempotent up to homotopy, exiting.");
            // return();
        }
        
        matrix ep2ck = ep2;
        ep2ck = subst( ep2ck, y(1), 0 );
        ep2ck = subst( ep2ck, y(2), 0 );
        ep2ck = subst( ep2ck, y(3), 0 );
        ep2ck = subst( ep2ck, y(4), 0 );
        if( ep2ck * ep2ck != ep2ck )
        {
            // TODO DEBUG DEBUG WARNING UGLY HACK
            ep2 = -ep2;
            
            // print("[mfCompileWeb] ep2 is not idempotent up to homotopy, exiting.");
            // return();
        }
        
        // Check that ep1 and ep2 are degree zero
        if( !checkMorphismDegree(RT1,RT1gr,RT1,RT1gr,ep1,0) )
        {
            print("[mfCompileWeb] ep1 is not degree zero, exiting.");
            return();
        }

        if( !checkMorphismDegree(RT2,RT2gr,RT2,RT2gr,ep2,0) )
        {
            print("[mfCompileWeb] ep2 is not degree zero, exiting.");
            return();
        }
    }
    
    // Strictify these idempotents:
    matrix epstrict1 = mfStrictifyIdempotent(RT1, ep1);
    matrix epstrict2 = mfStrictifyIdempotent(RT2, ep2);
    
    // Sanity checks:
    if( epstrict1 * RT1 != RT1 * epstrict1 || epstrict1 * epstrict1 != epstrict1 )
    {
        print("[mfCompileWeb] The strictified idempotent epstrict1 is not an endomorphism of RT1, or not an idempotent on the nose, exiting.");
        return();
    }
    if( epstrict2 * RT2 != RT2 * epstrict2 || epstrict2 * epstrict2 != epstrict2 )
    {
        print("[mfCompileWeb] The strictified idempotent epstrict2 is not an endomorphism of RT2, or not an idempotent on the nose, exiting.");
        return();
    }

    list l1 = mfSplitIdempotent(RT1, epstrict1, RT1gr);
    list l2 = mfSplitIdempotent(RT2, epstrict2, RT2gr);

    matrix final1 = mfSuspend( l1[1], 2 );
    matrix final2 = mfSuspend( l2[1], 2 );
    
    intvec final1gr = mfSuspendGrading( l1[4], 2 );
    intvec final2gr = mfSuspendGrading( l2[4], 2 );
    
    // Grading sanity check
    if( isGradingValid(final1, final1gr) != 1 || isGradingValid(final2,final2gr) != 1 )
    {
        print("[mfCompileWeb] Something has gone wrong with the grading, exiting.");
        return();
    }
    
    // Determine the outgoing and incoming labels of final1 and final2
    // (in terms of the integer labels in {1,...,2*websize}). 
    // As final1 and final2 both depend only on y(1),...,y(4), their incident
    // edges are labelled by ext(1),...,ext(4). We need to determine i1,i2 such
    // that the vertices labelled by ext(i1) and ext(i2) are outgoing. 
    // Then we define a list finalvaris whose first two entries are ext(i1),ext(i2),
    // and whose third and fourth entry is given by the remaining two labellings.
    list templist;
    for( i=1; i<=4; i++ )
    {
        for( i1=1; i1<=2; i1++ )
        {
            for( i2=1; i2<=2; i2++ )
            {
                if( ext(i) == D1[1][2][i1] || ext(i) == D1[2][2][i2] )
                {
                    templist = templist + list(i);
                    i = i + 1;
                }
            }
        }
    }    
    for( i=1; i<=4; i++ )
    {
        if( i != templist[1] && i != templist[2] )
        {
            templist = templist + list(i);
        }
    }
    list finalvaris;
    for( i=1; i<=4; i++ )
    {
        finalvaris[i] = ext(templist[i]);
    }
    
    // Compute the transformation matrices:
    matrix s1(1) = mfSuspendMorph( l1[2], 2 );    // final1 --> RT1
    matrix t1(1) = mfSuspendMorph( l1[3], 2 );    // RT1 --> final1
    matrix s2(1) = mfSuspendMorph( l2[2], 2 );    // final2 --> RT2
    matrix t2(1) = mfSuspendMorph( l2[3], 2 );    // RT2 --> final2
    
    // Compute the induced map between the reductions
    webmap = t2(1) * F2(1) * webmap * G1(1) * s1(1);
    
    // Sanity check (DEBUG, can be removed)
    if( final2 * webmap != webmap * final1 )
    {
        print("[mfCompileWeb] webmap is not a morphism, exiting.");
        return();
    }

    kill T1, T1blow, T2, T2blow, l1, l2, RT1, RT2, d1(1), d1(2), d2(1), d2(2), diff1(1), diff1(2), iddQ1, diff2(1), diff2(2), iddQ2, delta1(1), delta1(2), delta2(1), delta2(2), delQ1, delQ2, e1, e2, ep1, ep2, epstrict1, epstrict2; 
    
    // Now repeat the above steps analogously and iteratively until all vertices but
    // the last one in the webs are fused:
    dbprint(printlevel, "[mfCompileWeb] Beginning induction step.");
    
    for( k=3; k<=websize-1; k++ )
    {
        // NOTE: the ext(i) will not necessarily be ordered "clockwise" with respect
        // to the underlying directed graph of the current web.
        // Identify which two numbers in D1[k][2] are not in {ext(i)}_{i=1,...,4}
        // and call them newlabel(1) and newlabel(2):
        int count = 1;
        for( i1=1; i1<=4; i1++ )
        {
            int z;
            for( i2=1; i2<=4; i2++ )
            {
                if( D1[k][2][i1] != ext(i2) )
                {
                    z = z + 1;
                }
            }
            if( z == 4 )
            {
                int newlabel(count) = D1[k][2][i1];
                count = count + 1;
            }
        }
        
        // Determine which of the numbers in {ext(i)}_{i=1,...,4} also appear 
        // in D1[k][2], and let us define i1,i2 such that these are ext(i1) and ext(i2).
        // These keep the ordering given in D1[k][2].
        list extlabel;
        for( i1=1; i1<=4; i1++ )
        {
            for( i2=1; i2<=4; i2++ )
            {
                if( D1[k][2][i1] == ext(i2) )
                {
                    extlabel = extlabel + list(i2);
                    break;
                }
            }
        }
        int i1 = extlabel[1]; // TODO: mondo confusing notation
        int i2 = extlabel[2];

        // At this stage, the variable listOfCVariableNames[i] corresponds to 
        // the edge label listOfEdgeLabels[i] for i=1,...,6:
        //          x(1) cooresponds to ext(i1),
        //          x(2) cooresponds to ext(i2),
        //          y(k) corresponds to ext(k) for k in {1,2,3,4}\{i1,i2},
        //          y(i1) cooresponds to n(1),
        //          y(i2) cooresponds to n(2).
        int assotox1,assotox2 = ext(i1),ext(i2);
        list newexternals; int count = 1;
        for( i=1; i<=4; i++ )
        {
            if( i != i1 && i != i2 )
            {
                newexternals[i] = ext(i);
            }
            else
            {
                newexternals[i] = newlabel(count);
                count = count + 1;
            }
        }
        for( i=1; i<=4; i++ )
        {
            ext(i) = newexternals[i];
        }
        list listOfCVariableNames = x(1),x(2),y(1),y(2),y(3),y(4);
        list listOfEdgeLabels = assotox1,assotox2,ext(1),ext(2),ext(3),ext(4);
    
        // Find the variable dependence of the "blob" MF which is the fusion of the
        // first k-1 vertices and the k-th MF:    
        list blobvaris, varis(k);
        for( i3=1; i3<=4; i3++ )
        {
            for( i4=1; i4<=6; i4++ )
            {
                if( finalvaris[i3] == listOfEdgeLabels[i4] )
                {
                    blobvaris[i3] = listOfCVariableNames[i4];
                }
                if( D1[k][2][i3] == listOfEdgeLabels[i4] )
                {
                    varis(k)[i3] = listOfCVariableNames[i4];
                }
            }
        }
        
        // Redefine the results of step k-1 according to the new identifications:
        final1 = subst( final1, y(i1), x(1) ); final1 = subst( final1, y(i2), x(2) );
        final2 = subst( final2, y(i1), x(1) ); final2 = subst( final2, y(i2), x(2) );
        webmap = subst( webmap, y(i1), x(1) ); webmap = subst( webmap, y(i2), x(2) );
        s1(k-2) = subst( s1(k-2), y(i1), x(1) ); s1(k-2) = subst( s1(k-2), y(i2), x(2) );
        t1(k-2) = subst( t1(k-2), y(i1), x(1) ); t1(k-2) = subst( t1(k-2), y(i2), x(2) );
        s2(k-2) = subst( s2(k-2), y(i1), x(1) ); s2(k-2) = subst( s2(k-2), y(i2), x(2) );
        t2(k-2) = subst( t2(k-2), y(i1), x(1) ); t2(k-2) = subst( t2(k-2), y(i2), x(2) );
        G1(k-2) = subst( G1(k-2), y(i1), x(1) ); G1(k-2) = subst( G1(k-2), y(i2), x(2) );
        F2(k-2) = subst( F2(k-2), y(i1), x(1) ); F2(k-2) = subst( F2(k-2), y(i2), x(2) );
        
        // V1(k) is the MF associated to the k-th vertex in web 1, 
        // V2(k) is the MF associated to the k-th vertex in web 2: 
        matrix V1(k) = mfVertex( D1[k][1], varis(k), N );
        matrix V2(k) = mfVertex( D2[k][1], varis(k), N );
    
        intvec V1gr(k) = mfVertexGrading( D1[k][1], varis(k), N );
        intvec V2gr(k) = mfVertexGrading( D2[k][1], varis(k), N );
        
        // Now start to reduce final1 x V1(k), final2 x V2(k) and the map between them:
        
        ideal J = x(1)^N, x(2)^N;
        intvec q = N, N;
        number Nn = N + 1;
        matrix C[2][2] = 1/Nn, 0, 0, 1/Nn;
        
        if( k == chiposition )
        {
            alpha(k) = mfChi(chitype, varis(k)[1], varis(k)[2], varis(k)[3], varis(k)[4], N);
        }
        
        // Compute the ordinary tensor product:
        matrix T1 = MFtensor( final1, V1(k) );
        matrix T1blow = mablow(T1,J);
        matrix T2 = MFtensor( final2, V2(k) );
        matrix T2blow = mablow(T2,J);

        intvec T1gr = MFtensorGradings( final1gr, V1gr(k) );
        intvec T1blowgr = mablowGrading(T1gr,J,N);
        intvec T2gr = MFtensorGradings( final2gr, V2gr(k) );
        intvec T2blowgr = mablowGrading(T2gr,J,N);

        // blown-up version of the map between the first k vertices:
        webmap = mablow( ZZtensor( webmap, alpha(k) ), J );
        
        // Reduce this inflated differential:
        list l1 = mfReduce(T1blow,1);
        matrix RT1 = l1[1];
        matrix F1(k-1) = l1[2]; // A homotopy equivalence T1blow -> RT1
        matrix G1(k-1) = l1[3]; // A homotopy equivalence RT1 -> T1blow
        list l2 = mfReduce(T2blow,1);
        matrix RT2 = l2[1];
        matrix F2(k-1) = l2[2]; // A homotopy equivalence T2blow -> RT2
        matrix G2(k-1) = l2[3]; // A homotopy equivalence RT2 -> T2blow
    
        intvec RT1gr = computeGradingFromInjection(G1(k-1),T1blowgr);
        intvec RT2gr = computeGradingFromInjection(G2(k-1),T2blowgr);
    
        // Define d1(1) to be the product over all outgoing edges labelled by x-variables
        // of the derivatives of final1 with respect to these variables, and
        // define d1(k) to be the product over all outgoing edges labelled by x-variables
        // of the derivatives of V1(k) with respect to these variables, and
        // similarly for d2(1) and d2(2):
        matrix d1(1) = unitmat( ncols( final1 ) );
        matrix d1(k) = unitmat( ncols( V1(k) ) );
        matrix d2(1) = unitmat( ncols( final2 ) );
        matrix d2(k) = unitmat( ncols( V2(k) ) );
        for( i=1; i<=2; i++ )
        {
            // vertex final1:
            if( x(1) == blobvaris[i] )
            {
                d1(1) = d1(1) * diff( final1, x(1) );
                d2(1) = d2(1) * diff( final2, x(1) );
            }
        
            if( x(2) == blobvaris[i] )
            {
                d1(1) = d1(1) * diff( final1, x(2) );
                d2(1) = d2(1) * diff( final2, x(2) );
            }
        
            // vertex V1(2):
            if( x(1) == varis(k)[i] )
            {
                d1(k) = d1(k) * diff( V1(k), x(1) );
                d2(k) = d2(k) * diff( V2(k), x(1) );
            }
        
            if( x(2) == varis(k)[i] )
            {
                d1(k) = d1(k) * diff( V1(k), x(2) );
                d2(k) = d2(k) * diff( V2(k), x(2) );
            }
        }
        
        matrix diff1(1) = ZZtensor( d1(1), unitmat( ncols( V1(k) ) ) );
        matrix diff1(2) = ZZtensor( unitmat( ncols( final1 ) ), d1(k) );
        matrix iddQ1 = mablow( det(C) * diff1(1) * diff1(2), J );
        matrix diff2(1) = ZZtensor( d2(1), unitmat( ncols( V2(k) ) ) );
        matrix diff2(2) = ZZtensor( unitmat( ncols( final2 ) ), d2(k) );
        matrix iddQ2 = mablow( det(C) * diff2(1) * diff2(2), J );

        matrix delta1(1) = mablow_delta(T1, 1, N, J);
        matrix delta1(2) = mablow_delta(T1, 2, N, J);
        matrix delQ1 = delta1(1) * delta1(2);
        matrix delta2(1) = mablow_delta(T2, 1, N, J);
        matrix delta2(2) = mablow_delta(T2, 2, N, J);
        matrix delQ2 = delta2(1) * delta2(2);
    
        // And finally the idempotents e1,e2 on T1blow,T2blow:
        matrix e1 = (-1)^k * iddQ1 * delQ1;   // TODO: is the factor (-1)^k correct?
        // Good question... seems to work! You'll have to explain to me why.
        matrix e2 = (-1)^k * iddQ2 * delQ2;   // TODO: is the factor (-1)^k correct?
    
        matrix ep1 = F1(k-1) * e1 * G1(k-1);
        matrix ep2 = F2(k-1) * e2 * G2(k-1);
        
        // Sanity checks:
        if( ep1 * RT1 != RT1 * ep1 )
        {
            print("[mfCompileWeb] The reduced idempotent (up to homotopy) ep1 at level "+string(k)+" is not an endomorphism of RT1, exiting.");
            return();
        }
        if( ep2 * RT2 != RT2 * ep2 )
        {
            print("[mfCompileWeb] The reduced idempotent (up to homotopy) ep2 at level "+string(k)+" is not an endomorphism of RT2, exiting.");
            return();
        }
    
        if( paranoidChecks )
        {
            // Check that ep1 and ep2 are idempotent up to homotopy
            matrix ep1ck = ep1;
            ep1ck = subst( ep1ck, y(1), 0 );
            ep1ck = subst( ep1ck, y(2), 0 );
            ep1ck = subst( ep1ck, y(3), 0 );
            ep1ck = subst( ep1ck, y(4), 0 );
            if( ep1ck * ep1ck != ep1ck )
            {
                // TODO DEBUG DEBUG WARNING UGLY HACK
                ep1 = -ep1;
                
                //print("[mfCompileWeb] ep1 at level "+string(k)+" is not idempotent up to homotopy, exiting.");
                //return();
            }
            
            matrix ep2ck = ep2;
            ep2ck = subst( ep2ck, y(1), 0 );
            ep2ck = subst( ep2ck, y(2), 0 );
            ep2ck = subst( ep2ck, y(3), 0 );
            ep2ck = subst( ep2ck, y(4), 0 );
            if( ep2ck * ep2ck != ep2ck )
            {
                // TODO DEBUG DEBUG WARNING UGLY HACK
                ep2 = -ep2;
                
                //print("[mfCompileWeb] ep2 at level "+string(k)+" is not idempotent up to homotopy, exiting.");
                //return();
            }
        }
        
        // Strictify these idempotents:
        matrix epstrict1 = mfStrictifyIdempotent(RT1, ep1);
        matrix epstrict2 = mfStrictifyIdempotent(RT2, ep2);
    
      // Sanity checks:
        if( epstrict1 * RT1 != RT1 * epstrict1 || epstrict1 * epstrict1 != epstrict1 )
        {
            print("[mfCompileWeb] The strictified idempotent epstrict1 at level "+string(k)+" is not an endomorphism of RT1, or not an idempotent on the nose, exiting.");
            return();
        }
        if( epstrict2 * RT2 != RT2 * epstrict2 || epstrict2 * epstrict2 != epstrict2 )
        {
            print("[mfCompileWeb] The strictified idempotent epstrict2 at level "+string(k)+" is not an endomorphism of RT2, or not an idempotent on the nose, exiting.");
            return();
        }

        list l1 = mfSplitIdempotent(RT1, epstrict1, RT1gr);
        list l2 = mfSplitIdempotent(RT2, epstrict2, RT2gr);

        final1 = mfSuspend( l1[1], 2 );
        final2 = mfSuspend( l2[1], 2 );
    
        final1gr = mfSuspendGrading( l1[4], 2 );
        final2gr = mfSuspendGrading( l2[4], 2 );
        
        // Grading sanity check
        if( isGradingValid(final1, final1gr) != 1 || isGradingValid(final2,final2gr) != 1 )
        {
            print("[mfCompileWeb] Something has gone wrong with the grading in induction, exiting.");
            return();
        }
        
        // Determine the outgoing and incoming labels of final1 and final2
        // (in terms of the integer labels in {1,...,2*websize}). 
        // As final1 and final2 both depend only on y(1),...,y(4), their incident
        // edges are labelled by ext(1),...,ext(4). We need to determine i1,i2 such
        // that the vertices labelled by ext(i1) and ext(i2) are incoming. 
        // Then we define a list finalvaris whose first two entries are ext(i1),ext(i2),
        // and whose third and fourth entry is given by the remaning two labellings.
        list templist;
        for( i=1; i<=4; i++ )
        {
            for( i1=1; i1<=2; i1++ )
            {
                for( i2=1; i2<=2; i2++ )
                {
                    if( ext(i) == finalvaris[i1] || ext(i) == D1[k][2][i2] )
                    {
                        templist = templist + list(i);
                        i = i + 1;
                    }
                }
            }
        }    
        for( i=1; i<=4; i++ )
        {
            if( i != templist[1] && i != templist[2] )
            {
                templist = templist + list(i);
            }
        }
        list finalvaris;
        for( i=1; i<=4; i++ )
        {
            finalvaris[i] = ext(templist[i]);
        }
    
        // Compute the transformation matrices:

        matrix s1(k-1) = mfSuspendMorph( l1[2], 2 );    // final1 --> RT1
        matrix t1(k-1) = mfSuspendMorph( l1[3], 2 );    // RT1 --> final1
        matrix s2(k-1) = mfSuspendMorph( l2[2], 2 );    // final2 --> RT2
        matrix t2(k-1) = mfSuspendMorph( l2[3], 2 );    // RT2 --> final2

        // Compute the induced map between the reductions
        webmap = t2(k-1) * F2(k-1) * webmap * G1(k-1) * s1(k-1);
    
        // Sanity check (DEBUG, can be removed)
        if( final2 * webmap != webmap * final1 )
        {
            print("[mfCompileWeb] inductive webmap is not a morphism, exiting.");
            return();
        }
        
        kill T1, T1blow, T2, T2blow, l1, l2, RT1, RT2, d1(1), d1(k), d2(1), d2(k), diff1(1), diff1(2), iddQ1, diff2(1), diff2(2), iddQ2, delta1(1), delta1(2), delta2(1), delta2(2), delQ1, delQ2, e1, e2, ep1, ep2, epstrict1, epstrict2; 
        
    }//end of k-loop
    
    // Now do the final fusion of the first websize-1 vertices with the last one.
    dbprint(printlevel, "[mfCompileWeb] Performing final fusion.");
    
    // Rename y(i) to x(i) for all i=1,...,4:
    int k = websize;
    int i;
    def lastvertex = D1[websize][2];
    int nx=4;
    int ny=4;
    ring rr2=0,(x(1..nx),y(1..ny)),dp;
    matrix final1 = imap(RRR,final1);
    matrix final2 = imap(RRR,final2);
    matrix s1(k-2) = imap(RRR,s1(k-2));
    matrix t1(k-2) = imap(RRR,t1(k-2));
    matrix s2(k-2) = imap(RRR,s2(k-2));
    matrix t2(k-2) = imap(RRR,t2(k-2));
    matrix G1(k-2) = imap(RRR,G1(k-2));
    matrix F2(k-2) = imap(RRR,F2(k-2));
    matrix webmap = imap(RRR,webmap);
    for( i=1; i<=4; i++ )
    {
        final1 = subst(final1,y(i),x(i));
        final2 = subst(final2,y(i),x(i));    
        s1(k-2) = subst(s1(k-2),y(i),x(i));
        t1(k-2) = subst(t1(k-2),y(i),x(i));
        s2(k-2) = subst(s2(k-2),y(i),x(i));
        t2(k-2) = subst(t2(k-2),y(i),x(i));
        G1(k-2) = subst(G1(k-2),y(i),x(i));
        F2(k-2) = subst(F2(k-2),y(i),x(i));
        webmap = subst(webmap,y(i),x(i));
    }
    int nx=4;
    ring rr3=0,(x(1..nx)),dp;
    int i,j,i1,i2,i3,i4;
//    def lastvertex = imap(rr2,lastvertex);
    matrix final1 = imap(rr2,final1);
    matrix final2 = imap(rr2,final2);
    matrix s1(k-2) = imap(rr2,s1(k-2));
    matrix t1(k-2) = imap(rr2,t1(k-2));
    matrix s2(k-2) = imap(rr2,s2(k-2));
    matrix t2(k-2) = imap(rr2,t2(k-2));
    matrix G1(k-2) = imap(rr2,G1(k-2));
    matrix F2(k-2) = imap(rr2,F2(k-2));
    matrix webmap = imap(rr2,webmap);

    list listOfCVariableNames = x(1),x(2),x(3),x(4);
    list listOfEdgeLabels = ext(1),ext(2),ext(3),ext(4);
    
    // Find the variable dependence of the "blob" MF which is the fusion of the
    // first k-1 vertices and the k-th MF:    
    list blobvaris, varis(k);
    for( i3=1; i3<=4; i3++ )
    {
        for( i4=1; i4<=4; i4++ )
        {
            if( finalvaris[i3] == listOfEdgeLabels[i4] )
            {
                blobvaris[i3] = listOfCVariableNames[i4];
            }
            if( lastvertex[i3] == listOfEdgeLabels[i4] )
            {
                varis(k)[i3] = listOfCVariableNames[i4];
            }
        }
    }
    
    // V1(k) is the MF associated to the k-th vertex in web 1, 
    // V2(k) is the MF associated to the k-th vertex in web 2: 
    matrix V1(k) = mfVertex( D1[k][1], varis(k), N );
    matrix V2(k) = mfVertex( D2[k][1], varis(k), N );

    intvec V1gr(k) = mfVertexGrading( D1[k][1], varis(k), N );
    intvec V2gr(k) = mfVertexGrading( D2[k][1], varis(k), N );
    
    // Now start to reduce final1 x V1(k), final2 x V2(k) and the map between them:

    ideal J = x(1)^N, x(2)^N, x(3)^N, x(4)^N;
    intvec q = N, N, N, N;
    number Nn = N + 1;
    matrix C[4][4] = 1/Nn * unitmat(4);
    
    matrix alpha(k) = unitmat(4);
    if( k == chiposition )
    {
        matrix alpha(k) = mfChi(chitype, varis(k)[1], varis(k)[2], varis(k)[3], varis(k)[4], N);
    }

    // Compute the ordinary tensor product:
    matrix T1 = MFtensor( final1, V1(k) );
    matrix T1blow = mablow(T1,J);
    matrix T2 = MFtensor( final2, V2(k) );
    matrix T2blow = mablow(T2,J);
    
    T1gr = MFtensorGradings( final1gr, V1gr(k) );
    T1blowgr = mablowGrading(T1gr,J,N);
    T2gr = MFtensorGradings( final2gr, V2gr(k) );
    T2blowgr = mablowGrading(T2gr,J,N);
    
    // blow up webmap
    webmap = mablow( ZZtensor( webmap, alpha(k) ), J );
        
    // Reduce this inflated differential:
    list l1 = mfReduce(T1blow,1);
    matrix RT1 = l1[1];
    matrix F1(k-1) = l1[2]; // A homotopy equivalence T1blow -> RT1
    matrix G1(k-1) = l1[3]; // A homotopy equivalence RT1 -> T1blow
    list l2 = mfReduce(T2blow,1);
    matrix RT2 = l2[1];
    matrix F2(k-1) = l2[2]; // A homotopy equivalence T2blow -> RT2
    matrix G2(k-1) = l2[3]; // A homotopy equivalence RT2 -> T2blow

    RT1gr = computeGradingFromInjection(G1(k-1),T1blowgr);
    RT2gr = computeGradingFromInjection(G2(k-1),T2blowgr);
    
    webmap = F2(k-1) * webmap * G1(k-1);
    
    // Define d1(1) to be the product over all outgoing edges labelled by x-variables
    // of the derivatives of final1 with respect to these variables, and
    // define d1(k) to be the product over all outgoing edges labelled by x-variables
    // of the derivatives of V1(k) with respect to these variables, and
    // similarly for d2(1) and d2(2):
    matrix d1(1) = unitmat( ncols( final1 ) );
    matrix d1(k) = unitmat( ncols( V1(k) ) );
    matrix d2(1) = unitmat( ncols( final2 ) );
    matrix d2(k) = unitmat( ncols( V2(k) ) );
    for( i=1; i<=2; i++ )
    {
        // vertex final1:
        if( x(1) == blobvaris[i] )
        {
            d1(1) = d1(1) * diff( final1, x(1) );
            d2(1) = d2(1) * diff( final2, x(1) );
        }
        if( x(2) == blobvaris[i] )
        {
            d1(1) = d1(1) * diff( final1, x(2) );
            d2(1) = d2(1) * diff( final2, x(2) );
        }
        if( x(3) == blobvaris[i] )
        {
            d1(1) = d1(1) * diff( final1, x(3) );
            d2(1) = d2(1) * diff( final2, x(3) );
        }
        if( x(4) == blobvaris[i] )
        {
            d1(1) = d1(1) * diff( final1, x(4) );
            d2(1) = d2(1) * diff( final2, x(4) );
        }
            
        // vertex V1(k):
        if( x(1) == varis(k)[i] )
        {
            d1(k) = d1(k) * diff( V1(k), x(1) );
            d2(k) = d2(k) * diff( V2(k), x(1) );
        }        
        if( x(2) == varis(k)[i] )
        {
            d1(k) = d1(k) * diff( V1(k), x(2) );
            d2(k) = d2(k) * diff( V2(k), x(2) );
        }
        if( x(3) == varis(k)[i] )
        {
            d1(k) = d1(k) * diff( V1(k), x(3) );
            d2(k) = d2(k) * diff( V2(k), x(3) );
        }        
        if( x(4) == varis(k)[i] )
        {
            d1(k) = d1(k) * diff( V1(k), x(4) );
            d2(k) = d2(k) * diff( V2(k), x(4) );
        }
    }
        
    matrix diff1(1) = ZZtensor( d1(1), unitmat( ncols( V1(k) ) ) );
    matrix diff1(2) = ZZtensor( unitmat( ncols( final1 ) ), d1(k) );
    matrix iddQ1 = mablow( det(C) * diff1(1) * diff1(2), J );
    matrix diff2(1) = ZZtensor( d2(1), unitmat( ncols( V2(k) ) ) );
    matrix diff2(2) = ZZtensor( unitmat( ncols( final2 ) ), d2(k) );
    matrix iddQ2 = mablow( det(C) * diff2(1) * diff2(2), J );

    matrix delta1(1) = mablow_delta(T1, 1, N, J);
    matrix delta1(2) = mablow_delta(T1, 2, N, J);
    matrix delta1(3) = mablow_delta(T1, 3, N, J);
    matrix delta1(4) = mablow_delta(T1, 4, N, J);
    matrix delQ1 = delta1(1) * delta1(2) * delta1(3) * delta1(4);
    matrix delta2(1) = mablow_delta(T2, 1, N, J);
    matrix delta2(2) = mablow_delta(T2, 2, N, J);
    matrix delta2(3) = mablow_delta(T2, 3, N, J);
    matrix delta2(4) = mablow_delta(T2, 4, N, J);
    matrix delQ2 = delta2(1) * delta2(2) * delta2(3) * delta2(4);
    
    // And finally the idempotents e1,e2 on T1blow,T2blow:
    // Note the sign factor is binom(4,2) = 6 so we ignore it
    matrix e1 = (-1)^k * iddQ1 * delQ1;   // TODO: is the factor (-1)^k correct?
    matrix e2 = (-1)^k * iddQ2 * delQ2;   // TODO: is the factor (-1)^k correct?
    
    matrix ep1 = F1(k-1) * e1 * G1(k-1);
    matrix ep2 = F2(k-1) * e2 * G2(k-1);
    
    matrix epstrict1 = mfStrictifyIdempotent(RT1, ep1);
    matrix epstrict2 = mfStrictifyIdempotent(RT2, ep2);

    matrix ep0 = extractblockmat(epstrict1)[1];
    matrix ep1 = extractblockmat(epstrict1)[4];
    int rank0 = mat_rk(ep0);
    int rank1 = mat_rk(ep1);
    
    matrix ep0r = extractblockmat(epstrict2)[1];
    matrix ep1r = extractblockmat(epstrict2)[4];
    int rank0r = mat_rk(ep0r);
    int rank1r = mat_rk(ep1r);

    int z2degree;
    intvec splitgr, splitgrr;
    
    // Now compute the non-zero part of the map of the above two complexes:
    if( rank1 != 0 )
    {
        z2degree = 1;
        matrix eq0f = ep1;
        matrix eq0fr = ep1r;

        // Now split the idempotent eq0f by hand:
        LIB "control.lib";
        module ker0 = rightKernel(unitmat(ncols(eq0f)) - eq0f);
        matrix f0 = ker0;
        matrix g0[ncols(f0)][nrows(f0)]; // Defaults to zero
    
        if( ker0[1] != [0] )
        {
            matrix g0 = leftInverse(f0) * eq0f; // Solves f0 * g0 = eq0f.
        };
        
        // The grading on the odd part of RT1 is given by
        intvec RT1gr1 = RT1gr[(size(RT1gr)/2+1)..size(RT1gr)];
        splitgr = computeGradingFromInjection(f0, RT1gr1);

        // Now split the idempotent eq0fr by hand:
        module ker0r = rightKernel(unitmat(ncols(eq0fr)) - eq0fr);
        matrix f0r = ker0r;
        matrix g0r[ncols(f0r)][nrows(f0r)];
    
        if( ker0r[1] != [0] )
        {
            matrix g0r = leftInverse(f0r) * eq0fr;
        };

        // The grading on the odd part of RT2 is given by
        intvec RT2gr1 = RT2gr[(size(RT2gr)/2+1)..size(RT2gr)];
        splitgrr = computeGradingFromInjection(f0r,RT2gr1);
        
        // Finally, to get the (non-zero part of the) map from web1 to web2:

        webmap = g0r * extractblockmat(webmap)[4] * f0;
    }
    if( rank0 != 0 )
    {
        z2degree = 0;
        matrix eq0f = ep0;
        matrix eq0fr = ep0r;

        // Now split the idempotent eq0f by hand:
        LIB "control.lib";
        module ker0 = rightKernel(unitmat(ncols(eq0f)) - eq0f);
        matrix f0 = ker0;
        matrix g0[ncols(f0)][nrows(f0)]; // Defaults to zero
    
        if( ker0[1] != [0] )
        {
            matrix g0 = leftInverse(f0) * eq0f; // Solves f0 * g0 = eq0f.
        };
        
        // The grading on the even part of RT1 is given by
        intvec RT1gr0 = RT1gr[1..(size(RT1gr)/2)];
        splitgr = computeGradingFromInjection(f0, RT1gr0);

        // Now split the idempotent eq0fr by hand:
        module ker0r = rightKernel(unitmat(ncols(eq0fr)) - eq0fr);
        matrix f0r = ker0r;
        matrix g0r[ncols(f0r)][nrows(f0r)];
    
        if( ker0r[1] != [0] )
        {
            matrix g0r = leftInverse(f0r) * eq0fr;
        };

        // The grading on the even part of RT2 is given by
        intvec RT2gr0 = RT2gr[1..(size(RT2gr)/2)];
        splitgrr = computeGradingFromInjection(f0r, RT2gr0);

        // Finally, to get the (non-zero part of the) map from web1 to web2:

        webmap = g0r * extractblockmat(webmap)[1] * f0;
    }
    
            kill V1(k), V2(k), J, C, T1, T1blow, T2, T2blow, l1, l2, RT1, RT2, diff1(1), diff1(2), diff2(1), diff2(2), iddQ1, iddQ2, delta1(1), delta1(2), delta1(3), delta1(4), delta2(1), delta2(2), delta2(3), delta2(4), delQ1, delQ2, e1, e2, epstrict1, epstrict2, ep0, ep1, ep0r, ep1r;
    
    // The reduced MFs of zero are concentrated in Z2-degree z2degree, 
    // and webmap is the non-zero map between them:
    
    setring RRR;
    
    // Define lists populated by the transformation maps G1,F2,s1,t1,f0,g0r
    // (to be used if the alternate versions of mfCompileWeb are called in
    // mfCompileLink, which happens if D1 and/or D2 has already been compiled):
    list transformationMaps1;
    list transformationMaps2;
    for( i=1; i<=2; i++ )
    {
        transformationMaps1[i] = list();
        transformationMaps2[i] = list();
    }
    for( i=1; i<=k-2; i++ )
    {
        transformationMaps1[1][i] = G1(i);
        transformationMaps2[1][i] = F2(i);
        transformationMaps1[2][i] = s1(i);
        transformationMaps2[2][i] = t2(i);
    }
    transformationMaps1[1][k-1] = imap(rr3,G1(k-1));
    transformationMaps2[1][k-1] = imap(rr3,F2(k-1));
    transformationMaps1[2][k-1] = imap(rr3,f0);
    transformationMaps2[2][k-1] = imap(rr3,g0r);
    
    matrix webmap = imap(rr3,webmap);
    
    list finaloutput = webmap, z2degree, splitgr, splitgrr, transformationMaps1, transformationMaps2;
    kill webmap, z2degree, splitgr, splitgrr;
    return(finaloutput);
}

/////////////////////////////////////////
// powervec
//
// Given an integer m returns a list of all intvecs of length m with entries 0,1.

proc powervec(int m)
{
    if( m == 1 )
    {
        intvec a = 0;
        intvec b = 1;
        list r = a,b;
        kill a,b;
        return(r);
    }
    
    list l = powervec(m-1);
    list r;
    
    int i;
    for(i=1;i<=size(l);i++)
    {
       // Prepend either 0 or 1 to each entry of l
        intvec v = l[i];
        intvec a = 0,v;
        intvec b = 1,v;
        r = r + list(a,b);
        kill v,a,b;
    }
    
    kill l;
    return(r):
}

/////////////////////////////////////////
// intvecToString
//
// NOTE that in mfCompileLink below we only need to evaluate intvecToString on
// intvecs that are made up only of 0s and 1s, so there cannot be a problem with
// the fact that intvecToString maps e.g. both 11,2,3 and 1,2,3,4 to the same string.
/////////////////////////////////////////

proc intvecToString(intvec v)
{
    string s;
    int i;
    for( i = 1; i <= size(v); i++ )
    {
        s = s + string(v[i]);
    }
    
    return(s);
}

/////////////////////////////////////////
// Link datatype
//
// Suppose we are given a link with m crossings, on which we fix a particular ordering.
// We represent this as a list (X,Y) consisting of an intvec X and a list Y, such that
//
// - X is an intvec of size m with X[i] = 1 if the i-th crossing of the link is positive
// and X[i] = -1 if the crossing is negative.
// - each entry of Y is an intvec of size 4 such that Y[i] labels the edges incident at
//  the i-th crossing of the link, oriented in the usual clockwise fashion.

////////////////////////////////////////////////////////////////////
// mfCompileLink
//
// Takes as arguments a link, defined as a pair in the sense explained above, the name
// of a file to use for storing intermediate results, and a flag useSaveFile specifying
// whether or not to make use of this datafile. The return is a list of tuples
//
//      T = (intvec state1,intvec state2,int chitype,int chiposition,data).
//
// Suppose we have m crossings in our link. A "state diagram" is an assignment of integers 0,1
// (or the letters A,B) to crossings, represented by an intvec with entries 0,1. So the tuple T
// consists of two state diagrams state1,state2 related by a map of type chitype in position
// chiposition. The final entry is the result of calling mfCompileWeb on this data. 
//
// The return of mfCompileLink is the list of all such tuples, over all possible pairs
// (state1,state2) connected by maps.
//
// To facilitate the computations we store the results of mfCompileLink to disk, using writelist.
// To illustrate the scheme, take the state 010 and state 110, let us say that the underlying
// link has a positive crossing in the first position so that there is a map 010 -> 110 of
// chitype 0. Internally to mfCompileLink we would then run
//
//      list map010to110 = mfCompileWeb( suitable params );
//
// Then a call to writelist:
//
//      writelist("filename","map010to110",map010to110);
//
// This will either create "filename" or append to it if it exists, writing a line to the file
// consisting of a Singular command which will recreate the list map010to110. To read from the
// file and execute this command one calls 
//
//      execute(read("filename"));
//
// which will run each line of "filename" in Singular.
//
// Before computing a given tuple T we load in the contents of the datafile and see if it has
// already been computed.
//
// WARNING/TODO: The algorithm only works for certain special links, as described in the
// introduction to mfCompileWeb.
//
// NOTE: The maps returned by mfCompileWeb are degree one, and we do not mess with this;
// we leave all the grading vectors unchanged (earlier there was an attempt to implement
// the grading shifts according to [KR,p.81], but this is better done elsewhere).

proc mfCompileLink(list linkData, string fileName, int useSaveFile, int N)
{
    def RRR = basering;
    
    // We always use a fixed ring with two "internal" x variables and four "external" y variables
    ring rr=0,(x(1..2),y(1..4)),dp;
    
    intvec vertexParity = linkData[1];
    list edgeList = linkData[2];
    
    int webSize = size(vertexParity);
    
    list stateDiagrams = powervec(webSize);
    list returnList;
    
    // Read in the save file, if it exists
    if( status(fileName,"exists") == "yes" && useSaveFile )
    {
        dbprint(printlevel, "[mfCompileLink] Reading in savefile.");
        execute(read(fileName));
    }

    int i;
    int numStateDiagrams = size(stateDiagrams);
    
    for( i = 1; i <= numStateDiagrams; i++ )
    {
        // Our current state diagram
        intvec v = stateDiagrams[i];
        dbprint(printlevel, "[mfCompileLink] Looking at state [" + string(v) + "] which is number [[ " + string(i) + "/" + string(numStateDiagrams) + " ]].");
    
        // Look at each position and the possible maps given by chis
        int j;
        for( j = 1; j <= size(v); j++ )
        {
            // If either the current position in v is a 0 and the crossing is positive, or
            // if the current position is 1 and the crossing is negative, then there is a map
            // originating in this state diagram with a chi in this position
            intvec w = v;
            int somethingToDo = 0;
        
            if(v[j] == 0 && vertexParity[j] == 1) // chitype is 0
            {
                w[j] = w[j]+1;
                somethingToDo = 1;
            }
        
            if(v[j] == 1 && vertexParity[j] == -1) // chitype is 1
            {
                w[j] = w[j]-1;
                somethingToDo = 1;
            }
        
            if( somethingToDo )
            {
                dbprint(printlevel, "[mfCompileLink]  Looking at the map to [" + string(w) + "].");
                
                // Currently memory usage is so bad that in the first cycle we go from 273192 bytes to 23478000.
                
                string listName = "map" + intvecToString(v) + "to" + intvecToString(w);
            
                // Populate an integer definedCheck with the result of defined(map???to???)
                string cmd = "int definedCheck = defined(" + listName + ");";
                execute(cmd);
                list Q;
                
                // See if this list already exists (having been loaded from the file), and if
                // it does not, then calculate it (the result being stored in Q in either case).
                if( definedCheck && useSaveFile )
                {
                    dbprint(printlevel, "[mfCompileLink]  Already computed, skipping.");
                    string cmd = "Q = " + listName;
                    execute(cmd);
                }
                else
                {
                    dbprint(printlevel, "[mfCompileLink]  Currently used memory: " + string(memory(0) div 1024) + "kb.");
                    
                    // Run mfCompileWeb. There are four possibilities:
                    //   (i) v and w have not been compiled previously,
                    //  (ii) v has not been compiled previously, but w has been,
                    // (iii) w has not been compiled previously, but v has been,
                    //  (iv) both v and w have been compiled previously. 
                    
                    string GwebNameV = "GTransWeb" + intvecToString(v);
                    string FwebNameW = "FTransWeb" + intvecToString(w);
                    string cmdV = "int definedCheckV = defined(" + GwebNameV + ");";
                    string cmdW = "int definedCheckW = defined(" + FwebNameW + ");";
                    execute(cmdV);
                    execute(cmdW);

                    // Case (i):
                    if( definedCheckV == 0 && definedCheckW == 0 )
                    {
                        Q = mfCompileWeb(linkweb(v,edgeList),linkweb(w,edgeList),v[j],j,N);
                        
                        // Store G-transformation data pertaining to v:
                        string GwebNameV = "GTransWeb" + intvecToString(v);
                        string cmd = "list GTransWeb" + intvecToString(v) + " = Q[5][1]";
                        execute(cmd); 
                        writelist(fileName,GwebNameV,Q[5][1]);

                        // Store s-transformation data pertaining to v:
                        string SwebNameV = "STransWeb" + intvecToString(v);
                        string cmd = "list STransWeb" + intvecToString(v) + " = Q[5][2]";
                        execute(cmd); 
                        writelist(fileName,SwebNameV,Q[5][2]);

                        // Store F-transformation data pertaining to w:
                        string FwebNameW = "FTransWeb" + intvecToString(w);
                        string cmd = "list FTransWeb" + intvecToString(w) + " = Q[6][1]";
                        execute(cmd); 
                        writelist(fileName,FwebNameW,Q[6][1]);

                        // Store t-transformation data pertaining to w:
                        string TwebNameW = "TTransWeb" + intvecToString(w);
                        string cmd = "list TTransWeb" + intvecToString(w) + " = Q[6][2]";
                        execute(cmd); 
                        writelist(fileName,TwebNameW,Q[6][2]);

                        // Store weights data pertaining to v:
                        string gradingV = "weightsOf" + intvecToString(v);
                        string cmd = "intvec weightsOf" + intvecToString(v) + " = Q[3]";
                        execute(cmd); 
                        writelist(fileName,gradingV,Q[3]);

                        // Store weights data pertaining to w:
                        string gradingW = "weightsOf" + intvecToString(w);
                        string cmd = "intvec weightsOf" + intvecToString(w) + " = Q[4]";
                        execute(cmd); 
                        writelist(fileName,gradingW,Q[4]);

                        // Store Z2 information of v and w:
                        string z2degreeV = "z2degreeOf" + intvecToString(v);
                        string cmd = "int z2degreeOf" + intvecToString(v) + " = Q[2]";
                        execute(cmd); 
                        writelist(fileName,z2degreeV,Q[2]);
                        string z2degreeW = "z2degreeOf" + intvecToString(w);
                        string cmd = "int z2degreeOf" + intvecToString(w) + " = Q[2]";
                        execute(cmd); 
                        writelist(fileName,z2degreeW,Q[2]);


                        // Add the output of Q to our file (Q[5] and Q[6] are no longer needed):
                        Q = delete(Q,5); Q = delete(Q,5);
                        dbprint(printlevel, "[mfCompileLink]  Writing result to disk.");
                        writelist(fileName,listName,Q);
                                                
                    }// end case (i).
                    
                    // Case (ii):
                    if( definedCheckV == 0 && definedCheckW != 0 )
                    {
                        string cmd = "list FTransWebW = FTransWeb" + intvecToString(w);
                        execute(cmd);
                        string cmd = "list TTransWebW = TTransWeb" + intvecToString(w);
                        execute(cmd);
                        string cmd = "list weightsOfWeb2 = weightsOf" + intvecToString(w);
                        execute(cmd);
                        
                        Q = mfCompileWeb2(linkweb(v,edgeList),FTransWebW,TTransWebW,weightsOfWeb2,v[j],j,N);
                        
                        kill FTransWebW,TTransWebW,weightsOfWeb2;
                        
                        // Store G-transformation data pertaining to v:
                        string GwebNameV = "GTransWeb" + intvecToString(v);
                        string cmd = "list GTransWeb" + intvecToString(v) + " = Q[5][1]";
                        execute(cmd); 
                        writelist(fileName,GwebNameV,Q[5][1]);

                        // Store s-transformation data pertaining to v:
                        string SwebNameV = "STransWeb" + intvecToString(v);
                        string cmd = "list STransWeb" + intvecToString(v) + " = Q[5][2]";
                        execute(cmd); 
                        writelist(fileName,SwebNameV,Q[5][2]);

                        // Store weights data pertaining to v:
                        string gradingV = "weightsOf" + intvecToString(v);
                        string cmd = "intvec weightsOf" + intvecToString(v) + " = Q[3]";
                        execute(cmd); 
                        writelist(fileName,gradingV,Q[3]);

                        // Store Z2 information of v:
                        string z2degreeV = "z2degreeOf" + intvecToString(v);
                        string cmd = "int z2degreeOf" + intvecToString(v) + " = Q[2]";
                        execute(cmd); 
                        writelist(fileName,z2degreeV,Q[2]);


                        // Add the output of Q to our file (Q[5] no longer needed):
                        Q = delete(Q,5);
                        dbprint(printlevel, "[mfCompileLink]  Writing result to disk.");
                        writelist(fileName,listName,Q);
                                                
                    }// end case (ii).

                    // Case (iii):
                    if( definedCheckV != 0 && definedCheckW == 0 )
                    {
                        string cmd = "list GTransWebV = GTransWeb" + intvecToString(v);
                        execute(cmd);
                        string cmd = "list STransWebV = STransWeb" + intvecToString(v);
                        execute(cmd);
                        string cmd = "list weightsOfWeb1 = weightsOf" + intvecToString(v);
                        execute(cmd);

                        Q = mfCompileWeb3(linkweb(w,edgeList),GTransWebV,STransWebV,weightsOfWeb1,v[j],j,N);
                        
                        kill GTransWebV,STransWebV,weightsOfWeb1;
                        
                        // Store F-transformation data pertaining to w:
                        string FwebNameW = "FTransWeb" + intvecToString(w);
                        string cmd = "list FTransWeb" + intvecToString(w) + " = Q[5][1]";
                        execute(cmd); 
                        writelist(fileName,FwebNameW,Q[5][1]);

                        // Store t-transformation data pertaining to w:
                        string TwebNameW = "TTransWeb" + intvecToString(w);
                        string cmd = "list TTransWeb" + intvecToString(w) + " = Q[5][2]";
                        execute(cmd); 
                        writelist(fileName,TwebNameW,Q[5][2]);

                        // Store weights data pertaining to w:
                        string gradingW = "weightsOf" + intvecToString(w);
                        string cmd = "intvec weightsOf" + intvecToString(w) + " = Q[4]";
                        execute(cmd); 
                        writelist(fileName,gradingW,Q[4]);

                        // Store Z2 information of w:
                        string z2degreeW = "z2degreeOf" + intvecToString(w);
                        string cmd = "int z2degreeOf" + intvecToString(w) + " = Q[2]";
                        execute(cmd); 
                        writelist(fileName,z2degreeW,Q[2]);


                        // Add the output of Q to our file (Q[5] no longer needed):
                        Q = delete(Q,5);
                        dbprint(printlevel, "[mfCompileLink]  Writing result to disk.");
                        writelist(fileName,listName,Q);
                                                
                    }// end case (iii).

                    // Case (iv):
                    if( definedCheckV != 0 && definedCheckW != 0 )
                    {
                        string cmd = "list GTransWebV = GTransWeb" + intvecToString(v);
                        execute(cmd);
                        string cmd = "list STransWebV = STransWeb" + intvecToString(v);
                        execute(cmd);
                        string cmd = "list weightsOfWeb1 = weightsOf" + intvecToString(v);
                        execute(cmd);

                        string cmd = "list FTransWebW = FTransWeb" + intvecToString(w);
                        execute(cmd);
                        string cmd = "list TTransWebW = TTransWeb" + intvecToString(w);
                        execute(cmd);
                        string cmd = "list weightsOfWeb2 = weightsOf" + intvecToString(w);
                        execute(cmd);
                        string cmd = "int z2deg = z2degreeOf" + intvecToString(w);
                        execute(cmd);

                        Q = mfCompileWeb4(linkData,GTransWebV,STransWebV,FTransWebW,TTransWebW,weightsOfWeb1,weightsOfWeb2,z2deg,v[j],j,N);
                        
                        kill GTransWebV,STransWebV,FTransWebW,TTransWebW,weightsOfWeb1,weightsOfWeb2;

                        // Add the output of Q to our file:
                        dbprint(printlevel, "[mfCompileLink4]  Writing result to disk.");
                        writelist(fileName,listName,Q);
                                                
                    }// end case (iv).                    
                }
                
                // Add the computed list to the end of compiledEntry
                list compiledEntry = v, w, v[j], j, Q;
                returnList = returnList + list(compiledEntry);
                kill listName, cmd, Q, compiledEntry;
            }
            
            kill w, somethingToDo;
        }
        
        kill v;
    }
    
    setring RRR;
    list returnList = imap(rr,returnList);
    
    return(returnList);
}

proc linkweb(intvec v, list edgeList)
{
    list output;
    int i;
    for(i=1; i<=size(v); i++)
    {
        output[i] = list( v[i], edgeList[i] );
    }
    
    return(output);
}

proc externalDegreeOfWeb(intvec v, intvec vertexParity)
{
    // 0 is always degree zero, and 1 is either degree -1 or +1 depending on the crossing type
    int i;
    int d;
    for( i = 1; i <= size(v); i++ )
    {
        d = d + v[i] * vertexParity[i];
    }
    
    return(d);
}

////////////////////////////////////////////////////////////////////
// superblockmat
//
// We are given a list of matrices which are supposed to fit into
// a block matrix with "numCols" columns, and we return the block matrix.
// The list is interpreted as a block matrix as follows: the first numCols
// entries form the first row, the second numCols entries the second row, etc.

proc superblockmat(int numCols, list #)
{
    int numRows = size(#)/numCols;
    
    // We first collect each row of the block matrix into a list
    list l;
    
    int i,j,k,t,s;
    for(s = 1;s<=numRows;s++)
    {
        // In this row of the block matrix we have the matrices
        // #[(s-1)*numCols + 1], ...., #[s * numCols]
        int b = nrows(#[s*numCols]);
        
        for(j=1;j<=b;j++)
        {
            list thisrow;
            
            for(k=1;k<=numCols;k++)
            {
                // We are now inside #[(s-1)*numCols + k]
                matrix cMat = #[(s-1)*numCols +k];
                for(t=1;t<=ncols(cMat);t++)
                {
                    thisrow = thisrow + list(cMat[j,t]);
                }
                kill cMat;
            }
            
            l = l + list(thisrow);
        }
    }
    
    // Convert l to a matrix
    matrix A[size(l)][size(l[1])];
    for(i=1;i<=size(l);i++)
    {
        for(j=1;j<=size(l[1]);j++)
        {
            A[i,j] = l[i][j];
        }
    }
    
    return(A);
}


proc whichGenerator(vector v)
{
    int position = 1;
    int z;
    while( z == 0 )
    {
        if( v[position] != 0 )
        {
            z = 1;
        }
        position++;
    }
    return(position-1);
}

////////////////////////////////////////////////////////////////////
// computeCohomology
//
// Takes as input a complex of graded vector spaces, specified as a
// tuple (m,L,G) as described as the ouput of KRcomplex. The return is
// a tuple (m,V,H) where V is a list giving the dimension of the
// cohomologies in each degree, and H is a list giving the weights of
// each of these cohomology spaces.

proc computeCohomology(list cpx)
{
    list C = cpx[2];
    int minDegree = cpx[1];
    int maxDegree = minDegree + size(C);
    list weightsPerCohomologicalDegree = cp[3];
    
    def cohom(1) = rightKernel(C[1]);
    int i;
    for( i=2; i<=maxDegree-minDegree; i++ )
    {
        def ker(i) = rightKernel(C[i]);
        def im(i-1) = module(C[i-1]);
        module coho(i) = reduce(ker(i),std(im(i-1)));
        def cohom(i) = std( coho(i) );
    }
    def ker(maxDegree-minDegree+1) = module( unitmat(size(weightsPerCohomologicalDegree[maxDegree-minDegree+1])));
    def im(maxDegree-minDegree) = module(C[maxDegree-minDegree]);
    module coho(maxDegree-minDegree+1) = reduce(ker(maxDegree-minDegree+1),std(im(maxDegree-minDegree)));
    def cohom(maxDegree-minDegree+1) = std( coho(maxDegree-minDegree+1) );

    list V;
    list H;
    int j;
    for( i=1; i<=maxDegree-minDegree+1; i++)
    {
        V[i] = size(cohom(i));
        list wt;
        
        for( j=1; j<=size(cohom(i)); j++ )
        {
            wt[j] = weightsPerCohomologicalDegree[i][whichGenerator(cohom(i)[j])];
        }
        
        H[i] = wt;
    }

    return(list(minDegree,V,H));
}

////////////////////////////////////////////////////////////////////
// gradedPoincare
//
// Takes as input a sequence of graded vector spaces, specified as a
// tuple (m,V,H) as described as the ouput of computeCohomology. The return
// is the graded Poincare poly. The second and argument are the parameters
// to use (i.e., the q and t).
//
// Recall that given a bigraded vector space H, the Poincare polynomial is
//
//     sum_i,j t^i * q^j * dim( H^(i,j) )
//
// Where i, j range over all integers, i is a cohomological degree and j
// is the weight or internal degree.

proc gradedPoincare(list cohom, number v, number u)
{
    int minDegree = cohom[1];
    list V = cohom[2]; // Dimensions of cohomologies
    list H = cohom[3]; // Weight vectors of cohomologies

    number p;

    int i,j;
    for( i=1; i<=size(V); i++)
    {
        for( j=1; j<=size(H[i]); j++ )
        {
            p = p + u^(i + minDegree - 1) * v^(H[i][j]);
        }
    }

    return(p);
}

////////////////////////////////////////////////////////////////////
// gradedEuler
//
// Takes as input a sequence of graded vector spaces, specified as a
// tuple (m,V,H) as described as the ouput of computeCohomology. The return
// is the graded Euler characteristic. The second argument is the parameter
// to use (i.e., the q).

proc gradedEuler(list cohom, number v)
{
    int minDegree = cohom[1];
    list V = cohom[2]; // Dimensions of cohomologies
    list H = cohom[3]; // Weight vectors of cohomologies
    
    // Now we want to compute the Euler char as
    //     sum_i,j (-1)^i * q^j * dim( H^(i,j) )
    // where is the cohomological degree, and j is the weight.

    number euler;

    int i,j;
    for( i=1; i<=size(V); i++)
    {
        for( j=1; j<=size(H[i]); j++ )
        {
            int sign = (i + minDegree + 1) mod 2;
            euler = euler + (-1)^(sign) * v^(H[i][j]);
        }
    }

    return(euler);
}

////////////////////////////////////////////////////////////////////
// KRcomplex
// 
// Given a link, defined in the format specified prior to mfCompileLink,
// and the "compilation" h of this link as given by mfCompileLink, we
// return a pair (m,L,G) where m is the minimum nonzero degree of the KR
// complex, L is the list of matrices giving the differentials, and G is
// the list of intvecs giving the weights on each of the vector spaces.

proc KRcomplex(list linkData, list h)
{
    intvec vertexParity = linkData[1];

    // Discover which webs in the KR complex live in which cohomological degrees
    list r = listWebsByDegree(linkData, h);

    int minDegree = r[1];
    list websByDegree = r[2];
    int maxDegree = minDegree + size(websByDegree) - 1;

    // Find the weights (="internal degrees") of the individual, total pieces in each
    // cohomological degree:
    list weightsPerCohomologicalDegree;
    int i, j;
    for( j=minDegree; j<=maxDegree; j++ )
    {
        int sj = j - minDegree + 1;
        weightsPerCohomologicalDegree[sj] = websByDegree[sj][1][3];
        for( i = 2; i<=size(websByDegree[sj]); i++ )
        {
            intvec tempint = weightsPerCohomologicalDegree[sj];
            tempint = tempint,websByDegree[sj][i][3];
            weightsPerCohomologicalDegree[sj] = tempint;
            kill tempint;
        }
    }

    // Try computing the differentials in the KR complex
    list KRcomplex;
    int c;
    for( c=minDegree; c<=maxDegree-1; c++ )
    {
        int sc = c - minDegree + 1; // shifted degree
        int i,j;
        list webmaps;

        for(j=1;j<=size(websByDegree[sc+1]);j++)
        {
            for(i=1;i<=size(websByDegree[sc]);i++)
            {
                list source = websByDegree[sc][i];
                list target = websByDegree[sc+1][j];

                // Look for the map between these two webs in h, if it exists
                matrix A;
                int s;
                int found = 0;
                for(s=1;s<=size(h);s++)
                {
                    if( h[s][1] == source[1] && h[s][2] == target[1] )
                    {
                        //print("Found map between " + string(source[1]) + " and " + string(target[1]));
                        list data = h[s][5];

                        // Calculate the Koszul sign
                        int signf;
                        int chiposition = h[s][4];
                        int b;
                        for(b=1;b<=chiposition-1;b++)
                        {
                            signf = signf + h[s][1][b];
                        }

                        A = (-1)^(signf) * data[1];
                        found = 1;
                    }
                }

                if( !found )
                {
                    // print("Found no map.");
                    matrix z[target[2]][source[2]];
                    A = z;
                }

                //print(A);
                webmaps = webmaps + list(A);
            }
        }

        matrix final = superblockmat(size(websByDegree[sc]),webmaps);
        KRcomplex = KRcomplex + list(final);
    }

    // Sanity check:
    for( i=minDegree; i<=maxDegree-2; i++ )
    {
        matrix zerom[nrows(KRcomplex[i+1-minDegree+1])][ncols(KRcomplex[i-minDegree+1])];
        if( KRcomplex[i+1-minDegree+1] * KRcomplex[i-minDegree+1] != zerom )
        {
            print("[KRlinkInvariant] KRcomplex is not a complex at cohomological degree " + string(i) + ", exiting");
            return();
        }
    }
    
    return(list(minDegree,KRcomplex,weightsPerCohomologicalDegree));
}

////////////////////////////////////////////////////////////////////
// listWebsByDegree
// 
// Given a link, defined in the format specified prior to mfCompileLink,
// and the "compilation" h of this link as given by mfCompileLink, we
// return a list L with the following format. Let minDegree be the smallest
// degree with a nonzero entry in the KR complex. Then
//
//      L[i] = list of all triples (A,B,C) where A is a state diagram intvec
//      with "external" or cohomological degree minDegree + i - 1, B
//      is the dimension of the vector space which is the compilation of the
//      corresponding web, and C is an intvec that gives the weights of this vector space.
//
// NOTE: The calculation of the weight is a little subtle, and worth paying attention to.
// The output of mfCompileLink has webs whose weights are just the "bare" ones output by
// the splitting and reduction procedure. But for the KR complex there are additional
// grading shifts defined in [KR,p.81], and we incoporate these shifts here.
//
// NOTE: Webs are ordered in whatever ordering the routine powervec puts them in

proc listWebsByDegree(list linkData, list h)
{
    int minDegree = 0;
    int maxDegree = 0;
    
    intvec vertexParity = linkData[1];
    
    // webSize is the number of vertices in our web
    int webSize = size(vertexParity);

    list stateDiagrams = powervec(webSize);

    int i;
    for( i=1; i<=size(stateDiagrams); i++ )
    {
        intvec web = stateDiagrams[i];
        int d = externalDegreeOfWeb(web, vertexParity);
        if( d < minDegree ){ minDegree = d; }
        if( d > maxDegree ){ maxDegree = d; }
    }

    list websByDegree;
    list e;
    int j;
    
    for( j=minDegree; j<=maxDegree; j++ )
    {
        websByDegree[j-minDegree+1] = e;
        intvec totalGrading;
        int first = 1;

        for(i = 1; i <= size(stateDiagrams); i++)
        {
            intvec web = stateDiagrams[i];
            int d = externalDegreeOfWeb(web, vertexParity);
            if( d == j )
            {
                // Look for this web as the source or target of something in h, so that
                // we can extract from h the dimension and the weights of the compilation.
                int rank;
                int c;
                intvec weights;
                int found = 0;
                for(c = 1; c <= size(h); c++)
                {
                    // Every time we see this web as the source of a map
                    if( h[c][1] == web )
                    {
                        if( !found )
                        {
                            rank = ncols(h[c][5][1]);
                            weights = h[c][5][3];
                            found = 1;
                        }
                        
                        // By [KR,p.81] we have an additional 1 - N or N if the chitype is 0 or 1 resp.
                        int chitype = h[c][3];
            
                        if( chitype == 0 )
                        {
                            weights = weights + 1 - N;
                        }
                        else
                        {
                            weights = weights + N;
                        }
                    }
                    
                    // Every time we see this web as the target of a map
                    if( h[c][2] == web )
                    {
                        if( !found )
                        {
                            rank = nrows(h[c][5][1]);
                            weights = h[c][5][4];
                            found = 1;
                        }
                        
                        // By [KR,p.81] we have an additional -N or N - 1 if the chitype is 0 or 1 resp.
                        int chitype = h[c][3];
            
                        if( chitype == 0 )
                        {
                            weights = weights - N;
                        }
                        else
                        {
                            weights = weights + N - 1;
                        }
                    }
                }
            
                websByDegree[j-minDegree+1] = websByDegree[j-minDegree+1] + list(list(web,rank,weights));
            }
        }
    }
    
    return(list(minDegree,websByDegree));
}


///////////////////////////////////////
// computeCohomologyAlt (DEBUG, can be omitted)
//
// Takes as input a complex of graded vector spaces, specified as a
// tuple (m,L,G) as described as the ouput of KRcomplex. The return is
// a tuple (m,V,H) where V is a list giving the dimension of the
// cohomologies in each degree, and H is a list giving the weights of
// each of these cohomology spaces.
//
// We ASSUME we are working over the basefield (i.e. in a quotient ring
// by all variables).

// Remarks about cohomology
//
// Let R be a field and suppose we have two matrices A, B which we view as maps of
// vector spaces A: R^k --> R^l and B: R^l --> R^m. Suppose we have a grading vector
// for R^l, so that each basis element has a weight. Calling
//
//     module ker = std(modulo(B,[0]));
//
// Computes the kernel of B. Suppose that ker is a list v1,...vn of vectors, given as linear
// combinations of gen(1),...,gen(l). Each gen(i) has been assigned a weight, and we assume
// that the vi are homogeneous with respect to these weightings, so that each vi is assigned
// a well-defined weight.
//
// Now view ker as presenting a map R^n --> R^l with columns v1,...,vn. Calling
//
//     module hom = std(modulo(ker,A))
//
// Computes generators of the kernel of the map R^n ---> R^l ---> R^l/Im(A), so that R^n/hom
// is the cohomology Ker(B)/Im(A). Each generator of R^n has a well-defined weight, given
// by the weight of the corresponding vi, which means that the vectors in the output of
//
//     ideal ba = kbase(hom)
//
// each have a well-defined weight. This intvec of weights gives the grading vector for the
// cohomology Ker(B)/Im(A).

proc computeCohomologyAlt(list cpx)
{
    list complex = cpx[2];
    int minDegree = cpx[1];
    int maxDegree = minDegree + size(complex);
    list wts = cp[3];
    
    // V and H will be the list of dimensions (resp. weight vectors) of the cohomologies
    list V,H;
    
    // Augment the complex with an extra zero map at the end
    int width = size(complex);
    matrix zero[1][nrows(complex[width])];
    complex[width+1] = zero;
    
    int i;
    for( i = 1; i <= size(complex); i++ )
    {
        // We are computing cohomology at position i of the complex
        dbprint(printlevel, "[computeCohomology] Computing degree " + string(i));
        
        // Compute the kernel of the next map in the complex
        matrix ker = std(modulo(complex[i],[0]));
        dbprint(printlevel, "[computeCohomology] Kernel is");
        module(ker);
        
        // the columns of hom are elements of the free module of rank
        // equal to the number of generators in the module ker, which equals
        // the number of columns in the matrix ker.
        // The quotient of this free module by the columns of hom is the module ker.
        module hom;        
        if( i == 1 )
        {
            hom = std(syz(ker));
        }
        else
        {
            hom = std(modulo(ker,complex[i-1]));
        }
        
        dbprint(printlevel, "[computeCohomology] hom is ");
        hom;
        
        module ba = std(kbase(hom));
        dbprint(printlevel, "[computeCohomology] final result is");
        ba;
        
        dbprint(printlevel, "[computeCohomology] Weights are");
        wts[i];
        
        // Determine the weight of each element of the kernel
        int kernelSize = size(module(ker));
        intvec kernelWt;
        int j;
        for(j = 1; j <= kernelSize; j++)
        {
            // Weight of the jth kernel generator
            vector v = module(ker)[j];
            kernelWt[j] = vectorWeight(v, wts[i]);
        }
        
        dbprint(printlevel, "[computeCohomology] Kernel weights are");
        kernelWt;
        intvec cohomWt;
        
        // Now use the weights of the kernel generators to determine the weights
        // of the generators of the cohomology. If the cohomology is just equal
        // to the kernel, use those weights:
        if( hom == [0] )
        {
            cohomWt = kernelWt;
        }
        else
        {
            // Use the kernel weights to assign weights to the basis elements
            for(j = 1; j <= size(ba); j++)
            {
                cohomWt[j] = vectorWeight(ba[j], kernelWt);
            }
        }

        dbprint(printlevel, "[computeCohomology] Final cohomology weights");        
        print(cohomWt);
        V[i] = size(ba);
        H[i] = cohomWt;
    }
    
    return(list(minDegree,V,H));
}

///////////////////////////////////////
// vectorWeight (DEBUG, helper method for computeCohomologyAlt, can be omitted)
//
// Given a vector in a free module of rank m and an intvec wts
// assigning a weight to each basis element of the free module,
// we return the weight of the vector (if it is well-defined).

proc vectorWeight(vector v, intvec wts)
{
    if( nrows(v) > size(wts) )
    {
        print("[vectorWeight] Size mismatch on vector and weights, exiting.");
        return();
    }
    
    int i;
    int found = 0;
    int wt;
    
    for(i=1; i <= nrows(v); i++)
    {
        if( v[i] != 0 )
        {
            if( found && wt != wts[i] )
            {
                print("[vectorWeight] Vector has no well-defined weight, exiting.");
                return();
            }
            
            wt = wts[i];
            
            found = 1;
        }
    }
    
    return(wt);
}

// Other versions of mfCompileWeb:

proc mfCompileWeb2(list D1, FTransWeb, TTransWeb, weightsOfWeb2, int chitype, int chiposition, int N)
{
    int paranoidChecks = 1; // If set to 1 then we perform additional stringent sanity checks
    
    def RRR = basering;
    int websize = size(D1);

    matrix finalF = FTransWeb[websize-1];
    matrix finalT = TTransWeb[websize-1];    
    
    int i,j,k,i1,i2,i3,i4;
    
    // Sanity checks
    if( chitype != 0 && chitype != 1 || chiposition > websize )
    {
        print("[mfCompileWeb2] chitype not in {0,1} or chiposition > web size, exiting.");
        return();
    }
    
    // Define the morphisms between the unreduced tensor factors to be
    // identity maps (only later redefine the chipositions-th alpha to
    // be the appropriate chi map):
    
    for( i=1; i<=websize; i++ )
    {
        matrix alpha(i) = unitmat(4);
    }
    
    // Fusion of the first two vertices.
    // Find out which are the two internal variables inter(1) and inter(2)
    // between vertices 1 and 2:
    
    list L1,L2;
    for( i=1; i<=4; i++ )
    {
        L1[i] = D1[1][2][i];
        L2[i] = D1[2][2][i];
    }
    
    int z = 1;
    for( i1=1; i1<=4; i1++ )
    {
        for( i2=1; i2<=4; i2++ )
        {
            if( L1[i1] == L2[i2] )
            {
                int inter(z) = L1[i1];
                z = z + 1;
            }
        }
    }
    // Note that inter(1),inter(2) occur in the same order which these edges
    // appear in edgevec(1).
    
    // Call the remaining labels of edges incident on either of the two
    // vertices ext(1),...,ext(4). The order is to enumerate the external
    // edges in edgevec(1) and then those in edgevec(2).
    
    L1 = removefromlist(removefromlist( L1, inter(1) ), inter(2) );
    L2 = removefromlist(removefromlist( L2, inter(1) ), inter(2) );     
    for( i=1; i<=2; i++ )
    {
        int ext(i) = L1[i];
        int ext(i+2) = L2[i];
    }
    
    // At this stage, the variable listOfCVariableNames[i] corresponds to 
    // the edge label listOfEdgeLabels[i] for i=1,...,6:
    
    list listOfCVariableNames = x(1),x(2),y(1),y(2),y(3),y(4);
    list listOfEdgeLabels = inter(1),inter(2),ext(1),ext(2),ext(3),ext(4);
    
    // Find the variable dependence of the first two vertices:
    list varis(1), varis(2);
    for( i1=1; i1<=4; i1++ )
    {
        for( i2=1; i2<=6; i2++ )
        {
            if( D1[1][2][i1] == listOfEdgeLabels[i2] )
            {
                varis(1)[i1] = listOfCVariableNames[i2];
            }
            if( D1[2][2][i1] == listOfEdgeLabels[i2] )
            {
                varis(2)[i1] = listOfCVariableNames[i2];
            }

        }
    }
    
    // V1(i) is the MF associated to the i-th vertex in web 1, 
    matrix V1(1) = mfVertex( D1[1][1], varis(1), N ); 
    matrix V1(2) = mfVertex( D1[2][1], varis(2), N );
    
    intvec V1gr(1) = mfVertexGrading( D1[1][1], varis(1), N );
    intvec V1gr(2) = mfVertexGrading( D1[2][1], varis(2), N );
    
    // Now start to reduce V1(1) x V1(2) and the corresponding map:
        
    ideal J = x(1)^N, x(2)^N;
    intvec q = N, N;
    number Nn = N + 1;
    matrix C[2][2] = 1/Nn, 0, 0, 1/Nn;

    // The matrix webmap will eventually be the reduced map between the two
    // webs. At the moment, it is simply the map V1(1) x V1(2) --> V2(1) x V2(2):
    
    for( i=1; i<=2; i++ )
    {
        if( i == chiposition )
        {
            alpha(i) = mfChi(chitype, varis(i)[1], varis(i)[2], varis(i)[3], varis(i)[4], N);
            break;
        }
    }
    
    // Compute the ordinary tensor product:
    matrix T1 = MFtensor( V1(1), V1(2) );
    matrix T1blow = mablow(T1,J);
    
    intvec T1gr = MFtensorGradings( V1gr(1), V1gr(2) );
    intvec T1blowgr = mablowGrading( T1gr, J, N );

    // Inflate the induced morphism between the webs
    matrix webmap = mablow( ZZtensor( alpha(1), alpha(2) ), J );
    
    // Reduce this inflated differential:
    list l1 = mfReduce(T1blow,1);
    matrix RT1 = l1[1];
    matrix F1(1) = l1[2]; // A homotopy equivalence T1blow -> RT1
    matrix G1(1) = l1[3]; // A homotopy equivalence RT1 -> T1blow
    
    intvec RT1gr = computeGradingFromInjection(G1(1),T1blowgr);
    
    // Define d1(1) to be the product over all outgoing edges labelled by x-variables
    // of the derivatives of V1(1) with respect to these variables, and
    // define d1(2) to be the product over all outgoing edges labelled by x-variables
    // of the derivatives of V1(2) with respect to these variables:
    
    matrix d1(1) = unitmat( ncols( V1(1) ) );
    matrix d1(2) = unitmat( ncols( V1(2) ) );
    for( i=1; i<=2; i++ )
    {
        // vertex V1(1):
        if( x(1) == varis(1)[i] )
        {
            d1(1) = d1(1) * diff( V1(1), x(1) );
        }
        
        if( x(2) == varis(1)[i] )
        {
            d1(1) = d1(1) * diff( V1(1), x(2) );
        }
        
        // vertex V1(2):
        if( x(1) == varis(2)[i] )
        {
            d1(2) = d1(2) * diff( V1(2), x(1) );
        }
        
        if( x(2) == varis(2)[i] )
        {
            d1(2) = d1(2) * diff( V1(2), x(2) );
        }
    }
    // TODO: possible signs?
    
    matrix diff1(1) = ZZtensor( d1(1), unitmat( ncols( V1(2) ) ) );
    matrix diff1(2) = ZZtensor( unitmat( ncols( V1(1) ) ), d1(2) );
    matrix iddQ1 = mablow( det(C) * diff1(1) * diff1(2), J );

    matrix delta1(1) = mablow_delta(T1, 1, N, J);
    matrix delta1(2) = mablow_delta(T1, 2, N, J);
    matrix delQ1 = delta1(1) * delta1(2);
    
    // And finally the idempotent e1 on T1blow:
    matrix e1 = iddQ1 * delQ1;

    matrix ep1 = F1(1) * e1 * G1(1);
    
    // Sanity check:
    if( ep1 * RT1 != RT1 * ep1 )
    {
        print("[mfCompileWeb2] The reduced idempotent (up to homotopy) ep1 is not an endomorphism of RT1, exiting.");
        return();
    }
    
    if( paranoidChecks )
    {
        // Check that ep1 is idempotent up to homotopy
        matrix ep1ck = ep1;
        ep1ck = subst( ep1ck, y(1), 0 );
        ep1ck = subst( ep1ck, y(2), 0 );
        ep1ck = subst( ep1ck, y(3), 0 );
        ep1ck = subst( ep1ck, y(4), 0 );
        if( ep1ck * ep1ck != ep1ck )
        {
            // NOTE: If this test fails to pass, it is usually due to a sign problem...
            
            // TODO DEBUG DEBUG WARNING UGLY HACK
            ep1 = -ep1;
            
            // print("[mfCompileWeb2] ep1 is not idempotent up to homotopy, exiting.");
            // return();
        }
                
        // Check that ep1 is degree zero
        if( !checkMorphismDegree(RT1,RT1gr,RT1,RT1gr,ep1,0) )
        {
            print("[mfCompileWeb2] ep1 is not degree zero, exiting.");
            return();
        }

    }
    
    // Strictify idempotent:
    matrix epstrict1 = mfStrictifyIdempotent(RT1, ep1);
    
    // Sanity check:
    if( epstrict1 * RT1 != RT1 * epstrict1 || epstrict1 * epstrict1 != epstrict1 )
    {
        print("[mfCompileWeb2] The strictified idempotent epstrict1 is not an endomorphism of RT1, or not an idempotent on the nose, exiting.");
        return();
    }

    list l1 = mfSplitIdempotent(RT1, epstrict1, RT1gr);

    matrix final1 = mfSuspend( l1[1], 2 );
    
    intvec final1gr = mfSuspendGrading( l1[4], 2 );
    
    // Grading sanity check:
    if( isGradingValid(final1, final1gr) != 1 )
    {
        print("[mfCompileWeb2] Something has gone wrong with the grading, exiting.");
        return();
    }
    
    // Determine the outgoing and incoming labels of final1
    // (in terms of the integer labels in {1,...,2*websize}). 
    // As final1 depends only on y(1),...,y(4), its incident
    // edges are labelled by ext(1),...,ext(4). We need to determine i1,i2 such
    // that the vertices labelled by ext(i1) and ext(i2) are outgoing. 
    // Then we define a list finalvaris whose first two entries are ext(i1),ext(i2),
    // and whose third and fourth entry is given by the remaining two labellings.
    list templist;
    for( i=1; i<=4; i++ )
    {
        for( i1=1; i1<=2; i1++ )
        {
            for( i2=1; i2<=2; i2++ )
            {
                if( ext(i) == D1[1][2][i1] || ext(i) == D1[2][2][i2] )
                {
                    templist = templist + list(i);
                    i = i + 1;
                }
            }
        }
    }    
    for( i=1; i<=4; i++ )
    {
        if( i != templist[1] && i != templist[2] )
        {
            templist = templist + list(i);
        }
    }
    list finalvaris;
    for( i=1; i<=4; i++ )
    {
        finalvaris[i] = ext(templist[i]);
    }
    
    // Compute the transformation matrices:
    matrix s1(1) = mfSuspendMorph( l1[2], 2 );    // final1 --> RT1
    matrix t1(1) = mfSuspendMorph( l1[3], 2 );    // RT1 --> final1
    
    // Compute the induced map between the reductions
    webmap = TTransWeb[1] * FTransWeb[1] * webmap * G1(1) * s1(1);
    
    kill T1, T1blow, l1, RT1, d1(1), d1(2), diff1(1), diff1(2), iddQ1, delta1(1), delta1(2),delQ1, e1, ep1, epstrict1; 
    
    // Now repeat the above steps analogously and iteratively until all vertices but
    // the last one in the webs are fused:
    dbprint(printlevel, "[mfCompileWeb2] Beginning induction step.");
    
    for( k=3; k<=websize-1; k++ )
    {
        // NOTE: the ext(i) will not necessarily be ordered "clockwise" with respect
        // to the underlying directed graph of the current web.
        // Identify which two numbers in D1[k][2] are not in {ext(i)}_{i=1,...,4}
        // and call them newlabel(1) and newlabel(2):
        int count = 1;
        for( i1=1; i1<=4; i1++ )
        {
            int z;
            for( i2=1; i2<=4; i2++ )
            {
                if( D1[k][2][i1] != ext(i2) )
                {
                    z = z + 1;
                }
            }
            if( z == 4 )
            {
                int newlabel(count) = D1[k][2][i1];
                count = count + 1;
            }
        }
        
        // Determine which of the numbers in {ext(i)}_{i=1,...,4} also appear 
        // in D1[k][2], and let us define i1,i2 such that these are ext(i1) and ext(i2).
        // These keep the ordering given in D1[k][2].
        list extlabel;
        for( i1=1; i1<=4; i1++ )
        {
            for( i2=1; i2<=4; i2++ )
            {
                if( D1[k][2][i1] == ext(i2) )
                {
                    extlabel = extlabel + list(i2);
                    break;
                }
            }
        }
        int i1 = extlabel[1]; // TODO: mondo confusing notation
        int i2 = extlabel[2];

        // At this stage, the variable listOfCVariableNames[i] corresponds to 
        // the edge label listOfEdgeLabels[i] for i=1,...,6:
        //          x(1) cooresponds to ext(i1),
        //          x(2) cooresponds to ext(i2),
        //          y(k) corresponds to ext(k) for k in {1,2,3,4}\{i1,i2},
        //          y(i1) cooresponds to n(1),
        //          y(i2) cooresponds to n(2).
        int assotox1,assotox2 = ext(i1),ext(i2);
        list newexternals; int count = 1;
        for( i=1; i<=4; i++ )
        {
            if( i != i1 && i != i2 )
            {
                newexternals[i] = ext(i);
            }
            else
            {
                newexternals[i] = newlabel(count);
                count = count + 1;
            }
        }
        for( i=1; i<=4; i++ )
        {
            ext(i) = newexternals[i];
        }
        list listOfCVariableNames = x(1),x(2),y(1),y(2),y(3),y(4);
        list listOfEdgeLabels = assotox1,assotox2,ext(1),ext(2),ext(3),ext(4);
    
        // Find the variable dependence of the "blob" MF which is the fusion of the
        // first k-1 vertices and the k-th MF:    
        list blobvaris, varis(k);
        for( i3=1; i3<=4; i3++ )
        {
            for( i4=1; i4<=6; i4++ )
            {
                if( finalvaris[i3] == listOfEdgeLabels[i4] )
                {
                    blobvaris[i3] = listOfCVariableNames[i4];
                }
                if( D1[k][2][i3] == listOfEdgeLabels[i4] )
                {
                    varis(k)[i3] = listOfCVariableNames[i4];
                }
            }
        }
        
        // Redefine the results of step k-1 according to the new identifications:
        final1 = subst( final1, y(i1), x(1) ); final1 = subst( final1, y(i2), x(2) );
        webmap = subst( webmap, y(i1), x(1) ); webmap = subst( webmap, y(i2), x(2) );
        s1(k-2) = subst( s1(k-2), y(i1), x(1) ); s1(k-2) = subst( s1(k-2), y(i2), x(2) );
        t1(k-2) = subst( t1(k-2), y(i1), x(1) ); t1(k-2) = subst( t1(k-2), y(i2), x(2) );
        G1(k-2) = subst( G1(k-2), y(i1), x(1) ); G1(k-2) = subst( G1(k-2), y(i2), x(2) );
        
        // V1(k) is the MF associated to the k-th vertex in web 1:
        matrix V1(k) = mfVertex( D1[k][1], varis(k), N );
    
        intvec V1gr(k) = mfVertexGrading( D1[k][1], varis(k), N );
        
        // Now start to reduce final1 x V1(k) and the associated map:
        
        ideal J = x(1)^N, x(2)^N;
        intvec q = N, N;
        number Nn = N + 1;
        matrix C[2][2] = 1/Nn, 0, 0, 1/Nn;
        
        if( k == chiposition )
        {
            alpha(k) = mfChi(chitype, varis(k)[1], varis(k)[2], varis(k)[3], varis(k)[4], N);
        }
        
        // Compute the ordinary tensor product:
        matrix T1 = MFtensor( final1, V1(k) );
        matrix T1blow = mablow(T1,J);

        intvec T1gr = MFtensorGradings( final1gr, V1gr(k) );
        intvec T1blowgr = mablowGrading(T1gr,J,N);

        // blown-up version of the map between the first k vertices:
        webmap = mablow( ZZtensor( webmap, alpha(k) ), J );
        
        // Reduce this inflated differential:
        list l1 = mfReduce(T1blow,1);
        matrix RT1 = l1[1];
        matrix F1(k-1) = l1[2]; // A homotopy equivalence T1blow -> RT1
        matrix G1(k-1) = l1[3]; // A homotopy equivalence RT1 -> T1blow
    
        intvec RT1gr = computeGradingFromInjection(G1(k-1),T1blowgr);
    
        // Define d1(1) to be the product over all outgoing edges labelled by x-variables
        // of the derivatives of final1 with respect to these variables, and
        // define d1(k) to be the product over all outgoing edges labelled by x-variables
        // of the derivatives of V1(k) with respect to these variables:
        matrix d1(1) = unitmat( ncols( final1 ) );
        matrix d1(k) = unitmat( ncols( V1(k) ) );
        for( i=1; i<=2; i++ )
        {
            // vertex final1:
            if( x(1) == blobvaris[i] )
            {
                d1(1) = d1(1) * diff( final1, x(1) );
            }
        
            if( x(2) == blobvaris[i] )
            {
                d1(1) = d1(1) * diff( final1, x(2) );
            }
        
            // vertex V1(2):
            if( x(1) == varis(k)[i] )
            {
                d1(k) = d1(k) * diff( V1(k), x(1) );
            }
        
            if( x(2) == varis(k)[i] )
            {
                d1(k) = d1(k) * diff( V1(k), x(2) );
            }
        }
        
        matrix diff1(1) = ZZtensor( d1(1), unitmat( ncols( V1(k) ) ) );
        matrix diff1(2) = ZZtensor( unitmat( ncols( final1 ) ), d1(k) );
        matrix iddQ1 = mablow( det(C) * diff1(1) * diff1(2), J );

        matrix delta1(1) = mablow_delta(T1, 1, N, J);
        matrix delta1(2) = mablow_delta(T1, 2, N, J);
        matrix delQ1 = delta1(1) * delta1(2);
    
        // And finally the idempotent e1 on T1blow:
        matrix e1 = (-1)^k * iddQ1 * delQ1;   // TODO: is the factor (-1)^k correct?
        // Good question... seems to work! You'll have to explain to me why.
        
        matrix ep1 = F1(k-1) * e1 * G1(k-1);
        
        // Sanity check:
        if( ep1 * RT1 != RT1 * ep1 )
        {
            print("[mfCompileWeb2] The reduced idempotent (up to homotopy) ep1 at level "+string(k)+" is not an endomorphism of RT1, exiting.");
            return();
        }
    
        if( paranoidChecks )
        {
            // Check that ep1 is idempotent up to homotopy:
            matrix ep1ck = ep1;
            ep1ck = subst( ep1ck, y(1), 0 );
            ep1ck = subst( ep1ck, y(2), 0 );
            ep1ck = subst( ep1ck, y(3), 0 );
            ep1ck = subst( ep1ck, y(4), 0 );
            if( ep1ck * ep1ck != ep1ck )
            {
                // TODO DEBUG DEBUG WARNING UGLY HACK
                ep1 = -ep1;
                
                //print("[mfCompileWeb2] ep1 at level "+string(k)+" is not idempotent up to homotopy, exiting.");
                //return();
            }
        }
        
        // Strictify idempotent:
        matrix epstrict1 = mfStrictifyIdempotent(RT1, ep1);
    
        // Sanity checks:
        if( epstrict1 * RT1 != RT1 * epstrict1 || epstrict1 * epstrict1 != epstrict1 )
        {
            print("[mfCompileWeb2] The strictified idempotent epstrict1 at level "+string(k)+" is not an endomorphism of RT1, or not an idempotent on the nose, exiting.");
            return();
        }

        list l1 = mfSplitIdempotent(RT1, epstrict1, RT1gr);

        final1 = mfSuspend( l1[1], 2 );
    
        final1gr = mfSuspendGrading( l1[4], 2 );
        
        // Grading sanity check:
        if( isGradingValid(final1, final1gr) != 1 )
        {
            print("[mfCompileWeb2] Something has gone wrong with the grading in induction, exiting.");
            return();
        }
        
        // Determine the outgoing and incoming labels of final1 and final2
        // (in terms of the integer labels in {1,...,2*websize}). 
        // As final1 and final2 both depend only on y(1),...,y(4), their incident
        // edges are labelled by ext(1),...,ext(4). We need to determine i1,i2 such
        // that the vertices labelled by ext(i1) and ext(i2) are incoming. 
        // Then we define a list finalvaris whose first two entries are ext(i1),ext(i2),
        // and whose third and fourth entry is given by the remaning two labellings.
        list templist;
        for( i=1; i<=4; i++ )
        {
            for( i1=1; i1<=2; i1++ )
            {
                for( i2=1; i2<=2; i2++ )
                {
                    if( ext(i) == finalvaris[i1] || ext(i) == D1[k][2][i2] )
                    {
                        templist = templist + list(i);
                        i = i + 1;
                    }
                }
            }
        }    
        for( i=1; i<=4; i++ )
        {
            if( i != templist[1] && i != templist[2] )
            {
                templist = templist + list(i);
            }
        }
        list finalvaris;
        for( i=1; i<=4; i++ )
        {
            finalvaris[i] = ext(templist[i]);
        }
    
        // Compute the transformation matrices:

        matrix s1(k-1) = mfSuspendMorph( l1[2], 2 );    // final1 --> RT1
        matrix t1(k-1) = mfSuspendMorph( l1[3], 2 );    // RT1 --> final1

        // Compute the induced map between the reductions
        webmap = TTransWeb[k-1] * FTransWeb[k-1] * webmap * G1(k-1) * s1(k-1);
            
        kill T1, T1blow, l1, RT1, d1(1), d1(k), diff1(1), diff1(2), iddQ1, delta1(1), delta1(2), delQ1, e1, ep1, epstrict1;
        
    }//end of k-loop
    
    // Now do the final fusion of the first websize-1 vertices with the last one.
    dbprint(printlevel, "[mfCompileWeb2] Performing final fusion.");
    
    // Rename y(i) to x(i) for all i=1,...,4:
    int k = websize;
    int i;
    def lastvertex = D1[websize][2];
    int nx=4;
    int ny=4;
    ring rr2=0,(x(1..nx),y(1..ny)),dp;
    matrix final1 = imap(RRR,final1);
    matrix s1(k-2) = imap(RRR,s1(k-2));
    matrix t1(k-2) = imap(RRR,t1(k-2));
    matrix G1(k-2) = imap(RRR,G1(k-2));
    matrix webmap = imap(RRR,webmap);
    for( i=1; i<=4; i++ )
    {
        final1 = subst(final1,y(i),x(i));
        s1(k-2) = subst(s1(k-2),y(i),x(i));
        t1(k-2) = subst(t1(k-2),y(i),x(i));
        G1(k-2) = subst(G1(k-2),y(i),x(i));
        webmap = subst(webmap,y(i),x(i));
    }
    int nx=4;
    ring rr3=0,(x(1..nx)),dp;
    int i,j,i1,i2,i3,i4;
    matrix final1 = imap(rr2,final1);
    matrix s1(k-2) = imap(rr2,s1(k-2));
    matrix t1(k-2) = imap(rr2,t1(k-2));
    matrix G1(k-2) = imap(rr2,G1(k-2));
    matrix webmap = imap(rr2,webmap);

    list listOfCVariableNames = x(1),x(2),x(3),x(4);
    list listOfEdgeLabels = ext(1),ext(2),ext(3),ext(4);
    
    // Find the variable dependence of the "blob" MF which is the fusion of the
    // first k-1 vertices and the k-th MF:    
    list blobvaris, varis(k);
    for( i3=1; i3<=4; i3++ )
    {
        for( i4=1; i4<=4; i4++ )
        {
            if( finalvaris[i3] == listOfEdgeLabels[i4] )
            {
                blobvaris[i3] = listOfCVariableNames[i4];
            }
            if( lastvertex[i3] == listOfEdgeLabels[i4] )
            {
                varis(k)[i3] = listOfCVariableNames[i4];
            }
        }
    }
    
    // V1(k) is the MF associated to the k-th vertex in web 1: 
    matrix V1(k) = mfVertex( D1[k][1], varis(k), N );

    intvec V1gr(k) = mfVertexGrading( D1[k][1], varis(k), N );
    
    // Now start to reduce final1 x V1(k) and the associated map:

    ideal J = x(1)^N, x(2)^N, x(3)^N, x(4)^N;
    intvec q = N, N, N, N;
    number Nn = N + 1;
    matrix C[4][4] = 1/Nn * unitmat(4);
    
    matrix alpha(k) = unitmat(4);
    if( k == chiposition )
    {
        matrix alpha(k) = mfChi(chitype, varis(k)[1], varis(k)[2], varis(k)[3], varis(k)[4], N);
    }

    // Compute the ordinary tensor product:
    matrix T1 = MFtensor( final1, V1(k) );
    matrix T1blow = mablow(T1,J);
    
    T1gr = MFtensorGradings( final1gr, V1gr(k) );
    T1blowgr = mablowGrading(T1gr,J,N);
    
    // blow up webmap
    webmap = mablow( ZZtensor( webmap, alpha(k) ), J );
        
    // Reduce this inflated differential:
    list l1 = mfReduce(T1blow,1);
    matrix RT1 = l1[1];
    matrix F1(k-1) = l1[2]; // A homotopy equivalence T1blow -> RT1
    matrix G1(k-1) = l1[3]; // A homotopy equivalence RT1 -> T1blow

    RT1gr = computeGradingFromInjection(G1(k-1),T1blowgr);
    
    matrix lastF = imap(RRR,finalF);
    webmap = lastF * webmap * G1(k-1);
    
    // Define d1(1) to be the product over all outgoing edges labelled by x-variables
    // of the derivatives of final1 with respect to these variables, and
    // define d1(k) to be the product over all outgoing edges labelled by x-variables
    // of the derivatives of V1(k) with respect to these variables:
    matrix d1(1) = unitmat( ncols( final1 ) );
    matrix d1(k) = unitmat( ncols( V1(k) ) );
    for( i=1; i<=2; i++ )
    {
        // vertex final1:
        if( x(1) == blobvaris[i] )
        {
            d1(1) = d1(1) * diff( final1, x(1) );
        }
        if( x(2) == blobvaris[i] )
        {
            d1(1) = d1(1) * diff( final1, x(2) );
        }
        if( x(3) == blobvaris[i] )
        {
            d1(1) = d1(1) * diff( final1, x(3) );
        }
        if( x(4) == blobvaris[i] )
        {
            d1(1) = d1(1) * diff( final1, x(4) );
        }
            
        // vertex V1(k):
        if( x(1) == varis(k)[i] )
        {
            d1(k) = d1(k) * diff( V1(k), x(1) );
        }        
        if( x(2) == varis(k)[i] )
        {
            d1(k) = d1(k) * diff( V1(k), x(2) );
        }
        if( x(3) == varis(k)[i] )
        {
            d1(k) = d1(k) * diff( V1(k), x(3) );
        }        
        if( x(4) == varis(k)[i] )
        {
            d1(k) = d1(k) * diff( V1(k), x(4) );
        }
    }
        
    matrix diff1(1) = ZZtensor( d1(1), unitmat( ncols( V1(k) ) ) );
    matrix diff1(2) = ZZtensor( unitmat( ncols( final1 ) ), d1(k) );
    matrix iddQ1 = mablow( det(C) * diff1(1) * diff1(2), J );

    matrix delta1(1) = mablow_delta(T1, 1, N, J);
    matrix delta1(2) = mablow_delta(T1, 2, N, J);
    matrix delta1(3) = mablow_delta(T1, 3, N, J);
    matrix delta1(4) = mablow_delta(T1, 4, N, J);
    matrix delQ1 = delta1(1) * delta1(2) * delta1(3) * delta1(4);
    
    // And finally the idempotent e1 on T1blow:
    // Note the sign factor is binom(4,2) = 6 so we ignore it
    matrix e1 = (-1)^k * iddQ1 * delQ1;   // TODO: is the factor (-1)^k correct?
    
    matrix ep1 = F1(k-1) * e1 * G1(k-1);
    
    matrix epstrict1 = mfStrictifyIdempotent(RT1, ep1);

    matrix ep0 = extractblockmat(epstrict1)[1];
    matrix ep1 = extractblockmat(epstrict1)[4];
    int rank0 = mat_rk(ep0);
    int rank1 = mat_rk(ep1);
    
    int z2degree;
    intvec splitgr;
    
    // Now compute the non-zero part of the map of the above two complexes:
    if( rank1 != 0 )
    {
        z2degree = 1;
        matrix eq0f = ep1;

        // Now split the idempotent eq0f by hand:
        LIB "control.lib";
        module ker0 = rightKernel(unitmat(ncols(eq0f)) - eq0f);
        matrix f0 = ker0;
        matrix g0[ncols(f0)][nrows(f0)]; // Defaults to zero
    
        if( ker0[1] != [0] )
        {
            matrix g0 = leftInverse(f0) * eq0f; // Solves f0 * g0 = eq0f.
        };
        
        // The grading on the odd part of RT1 is given by
        intvec RT1gr1 = RT1gr[(size(RT1gr)/2+1)..size(RT1gr)];
        splitgr = computeGradingFromInjection(f0, RT1gr1);
        
        // Finally, to get the (non-zero part of the) map from web1 to web2:
        
        matrix lastT = imap(RRR,finalT);
        webmap = lastT * extractblockmat(webmap)[4] * f0;
    }
    if( rank0 != 0 )
    {
        z2degree = 0;
        matrix eq0f = ep0;

        // Now split the idempotent eq0f by hand:
        LIB "control.lib";
        module ker0 = rightKernel(unitmat(ncols(eq0f)) - eq0f);
        matrix f0 = ker0;
        matrix g0[ncols(f0)][nrows(f0)]; // Defaults to zero
    
        if( ker0[1] != [0] )
        {
            matrix g0 = leftInverse(f0) * eq0f; // Solves f0 * g0 = eq0f.
        };
        
        // The grading on the even part of RT1 is given by
        intvec RT1gr0 = RT1gr[1..(size(RT1gr)/2)];
        splitgr = computeGradingFromInjection(f0, RT1gr0);

        // Finally, to get the (non-zero part of the) map from web1 to web2:

        matrix lastT = imap(RRR,finalT);
        webmap = lastT * extractblockmat(webmap)[1] * f0;
    }
    
            kill V1(k), J, C, T1, T1blow, l1, RT1, diff1(1), diff1(2), iddQ1, delta1(1), delta1(2), delta1(3), delta1(4), delQ1, e1, epstrict1, ep0, ep1;
    
    // The reduced MFs of zero are concentrated in Z2-degree z2degree, 
    // and webmap is the non-zero map between them:
    
    setring RRR;
    
    // Define lists populated by the transformation maps G1,s1,f0 
    // (to be used if the alternate versions of mfCompileWeb are called in
    // mfCompileLink, which happens if D1 has already been compiled):
    list transformationMaps1;
    for( i=1; i<=2; i++ )
    {
        transformationMaps1[i] = list();
    }
    for( i=1; i<=k-2; i++ )
    {
        transformationMaps1[1][i] = G1(i);
        transformationMaps1[2][i] = s1(i);
    }
    transformationMaps1[1][k-1] = imap(rr3,G1(k-1));
    transformationMaps1[2][k-1] = imap(rr3,f0);
    
    matrix webmap = imap(rr3,webmap);
    
    list finaloutput = webmap, z2degree, splitgr, weightsOfWeb2[1], transformationMaps1;
    kill webmap, z2degree, splitgr;
    return(finaloutput);
}


proc mfCompileWeb3(list D2, GTransWeb, STransWeb, weightsOfWeb1, int chitype, int chiposition, int N)
{
    int paranoidChecks = 1; // If set to 1 then we perform additional stringent sanity checks
    
    def RRR = basering;
    int websize = size(D2);
    
    matrix finalG = GTransWeb[websize-1];
    matrix finalS = STransWeb[websize-1];    
    
    int i,j,k,i1,i2,i3,i4;
    
    // Sanity checks
    if( chitype != 0 && chitype != 1 || chiposition > websize )
    {
        print("[mfCompileWeb3] chitype not in {0,1} or chiposition > web size, exiting.");
        return();
    }
    
    // Define the morphisms between the unreduced tensor factors to be
    // identity maps (only later redefine the chipositions-th alpha to
    // be the appropriate chi map):
    
    for( i=1; i<=websize; i++ )
    {
        matrix alpha(i) = unitmat(4);
    }
    
    // Fusion of the first two vertices.
    // Find out which are the two internal variables inter(1) and inter(2)
    // between vertices 1 and 2:
    
    list L1,L2;
    for( i=1; i<=4; i++ )
    {
        L1[i] = D2[1][2][i];
        L2[i] = D2[2][2][i];
    }
    
    int z = 1;
    for( i1=1; i1<=4; i1++ )
    {
        for( i2=1; i2<=4; i2++ )
        {
            if( L1[i1] == L2[i2] )
            {
                int inter(z) = L1[i1];
                z = z + 1;
            }
        }
    }
    // Note that inter(1),inter(2) occur in the same order which these edges
    // appear in edgevec(1).
    
    // Call the remaining labels of edges incident on either of the two
    // vertices ext(1),...,ext(4). The order is to enumerate the external
    // edges in edgevec(1) and then those in edgevec(2).
    
    L1 = removefromlist(removefromlist( L1, inter(1) ), inter(2) );
    L2 = removefromlist(removefromlist( L2, inter(1) ), inter(2) );     
    for( i=1; i<=2; i++ )
    {
        int ext(i) = L1[i];
        int ext(i+2) = L2[i];
    }
    
    // At this stage, the variable listOfCVariableNames[i] corresponds to 
    // the edge label listOfEdgeLabels[i] for i=1,...,6:
    
    list listOfCVariableNames = x(1),x(2),y(1),y(2),y(3),y(4);
    list listOfEdgeLabels = inter(1),inter(2),ext(1),ext(2),ext(3),ext(4);
    
    // Find the variable dependence of the first two vertices:
    list varis(1), varis(2);
    for( i1=1; i1<=4; i1++ )
    {
        for( i2=1; i2<=6; i2++ )
        {
            if( D2[1][2][i1] == listOfEdgeLabels[i2] )
            {
                varis(1)[i1] = listOfCVariableNames[i2];
            }
            if( D2[2][2][i1] == listOfEdgeLabels[i2] )
            {
                varis(2)[i1] = listOfCVariableNames[i2];
            }

        }
    }
    
    // V2(i) is the MF associated to the i-th vertex in web 2: 
    matrix V2(1) = mfVertex( D2[1][1], varis(1), N );
    matrix V2(2) = mfVertex( D2[2][1], varis(2), N );
    
    intvec V2gr(1) = mfVertexGrading( D2[1][1], varis(1), N );
    intvec V2gr(2) = mfVertexGrading( D2[2][1], varis(2), N );
    
    // Now start to reduce V2(1) x V2(2) and the associated map:
        
    ideal J = x(1)^N, x(2)^N;
    intvec q = N, N;
    number Nn = N + 1;
    matrix C[2][2] = 1/Nn, 0, 0, 1/Nn;

    // The matrix webmap will eventually be the reduced map between the two
    // webs. At the moment, it is simply the map V1(1) x V1(2) --> V2(1) x V2(2):
    
    for( i=1; i<=2; i++ )
    {
        if( i == chiposition )
        {
            alpha(i) = mfChi(chitype, varis(i)[1], varis(i)[2], varis(i)[3], varis(i)[4], N);
            break;
        }
    }
    
    // Compute the ordinary tensor product:
    matrix T2 = MFtensor( V2(1), V2(2) );
    matrix T2blow = mablow(T2,J);
    
    intvec T2gr = MFtensorGradings( V2gr(1), V2gr(2) );
    intvec T2blowgr = mablowGrading(T2gr,J, N);

    // Inflate the induced morphism between the webs
    matrix webmap = mablow( ZZtensor( alpha(1), alpha(2) ), J );
    
    // Reduce this inflated differential:
    list l2 = mfReduce(T2blow,1);
    matrix RT2 = l2[1];
    matrix F2(1) = l2[2]; // A homotopy equivalence T2blow -> RT2
    matrix G2(1) = l2[3]; // A homotopy equivalence RT2 -> T2blow
    
    intvec RT2gr = computeGradingFromInjection(G2(1),T2blowgr);
    
    // Define d1(1) to be the product over all outgoing edges labelled by x-variables
    // of the derivatives of V1(1) with respect to these variables, and
    // define d1(2) to be the product over all outgoing edges labelled by x-variables
    // of the derivatives of V1(2) with respect to these variables, and
    // similarly for d2(1) and d2(2):
    
    matrix d2(1) = unitmat( ncols( V2(1) ) );
    matrix d2(2) = unitmat( ncols( V2(2) ) );
    for( i=1; i<=2; i++ )
    {
        // vertex V1(1):
        if( x(1) == varis(1)[i] )
        {
            d2(1) = d2(1) * diff( V2(1), x(1) );
        }
        
        if( x(2) == varis(1)[i] )
        {
            d2(1) = d2(1) * diff( V2(1), x(2) );
        }
        
        // vertex V1(2):
        if( x(1) == varis(2)[i] )
        {
            d2(2) = d2(2) * diff( V2(2), x(1) );
        }
        
        if( x(2) == varis(2)[i] )
        {
            d2(2) = d2(2) * diff( V2(2), x(2) );
        }
    }
    // TODO: possible signs?
    
    matrix diff2(1) = ZZtensor( d2(1), unitmat( ncols( V2(2) ) ) );
    matrix diff2(2) = ZZtensor( unitmat( ncols( V2(1) ) ), d2(2) );
    matrix iddQ2 = mablow( det(C) * diff2(1) * diff2(2), J );

    matrix delta2(1) = mablow_delta(T2, 1, N, J);
    matrix delta2(2) = mablow_delta(T2, 2, N, J);
    matrix delQ2 = delta2(1) * delta2(2);
    
    // And finally the idempotents e1,e2 on T1blow,T2blow
    matrix e2 = iddQ2 * delQ2;

    matrix ep2 = F2(1) * e2 * G2(1);
    
    // Sanity checks:
    if( ep2 * RT2 != RT2 * ep2 )
    {
        print("[mfCompileWeb3] The reduced idempotent (up to homotopy) ep2 is not an endomorphism of RT2, exiting.");
        return();
    }
    
    if( paranoidChecks )
    {
        matrix ep2ck = ep2;
        ep2ck = subst( ep2ck, y(1), 0 );
        ep2ck = subst( ep2ck, y(2), 0 );
        ep2ck = subst( ep2ck, y(3), 0 );
        ep2ck = subst( ep2ck, y(4), 0 );
        if( ep2ck * ep2ck != ep2ck )
        {
            // TODO DEBUG DEBUG WARNING UGLY HACK
            ep2 = -ep2;
            
            // print("[mfCompileWeb3] ep2 is not idempotent up to homotopy, exiting.");
            // return();
        }
        
        // Check that ep1 and ep2 are degree zero
        if( !checkMorphismDegree(RT2,RT2gr,RT2,RT2gr,ep2,0) )
        {
            print("[mfCompileWeb3] ep2 is not degree zero, exiting.");
            return();
        }
    }
    
    // Strictify these idempotents:
    matrix epstrict2 = mfStrictifyIdempotent(RT2, ep2);
    
    // Sanity checks:
    if( epstrict2 * RT2 != RT2 * epstrict2 || epstrict2 * epstrict2 != epstrict2 )
    {
        print("[mfCompileWeb3] The strictified idempotent epstrict2 is not an endomorphism of RT2, or not an idempotent on the nose, exiting.");
        return();
    }

    list l2 = mfSplitIdempotent(RT2, epstrict2, RT2gr);

    matrix final2 = mfSuspend( l2[1], 2 );
    
    intvec final2gr = mfSuspendGrading( l2[4], 2 );
    
    // Grading sanity check
    if( isGradingValid(final2,final2gr) != 1 )
    {
        print("[mfCompileWeb3] Something has gone wrong with the grading, exiting.");
        return();
    }
    
    // Determine the outgoing and incoming labels of final1 and final2
    // (in terms of the integer labels in {1,...,2*websize}). 
    // As final1 and final2 both depend only on y(1),...,y(4), their incident
    // edges are labelled by ext(1),...,ext(4). We need to determine i1,i2 such
    // that the vertices labelled by ext(i1) and ext(i2) are outgoing. 
    // Then we define a list finalvaris whose first two entries are ext(i1),ext(i2),
    // and whose third and fourth entry is given by the remaining two labellings.
    list templist;
    for( i=1; i<=4; i++ )
    {
        for( i1=1; i1<=2; i1++ )
        {
            for( i2=1; i2<=2; i2++ )
            {
                if( ext(i) == D2[1][2][i1] || ext(i) == D2[2][2][i2] )
                {
                    templist = templist + list(i);
                    i = i + 1;
                }
            }
        }
    }    
    for( i=1; i<=4; i++ )
    {
        if( i != templist[1] && i != templist[2] )
        {
            templist = templist + list(i);
        }
    }
    list finalvaris;
    for( i=1; i<=4; i++ )
    {
        finalvaris[i] = ext(templist[i]);
    }
    
    // Compute the transformation matrices:
    matrix s2(1) = mfSuspendMorph( l2[2], 2 );    // final2 --> RT2
    matrix t2(1) = mfSuspendMorph( l2[3], 2 );    // RT2 --> final2
    
    // Compute the induced map between the reductions
    webmap = t2(1) * F2(1) * webmap * GTransWeb[1] * STransWeb[1];
    
    kill T2, T2blow, l2, RT2, d2(1), d2(2), diff2(1), diff2(2), iddQ2, delta2(1), delta2(2), delQ2, e2, ep2, epstrict2; 
    
    // Now repeat the above steps analogously and iteratively until all vertices but
    // the last one in the webs are fused:
    dbprint(printlevel, "[mfCompileWeb3] Beginning induction step.");
    
    for( k=3; k<=websize-1; k++ )
    {
        // NOTE: the ext(i) will not necessarily be ordered "clockwise" with respect
        // to the underlying directed graph of the current web.
        // Identify which two numbers in D1[k][2] are not in {ext(i)}_{i=1,...,4}
        // and call them newlabel(1) and newlabel(2):
        int count = 1;
        for( i1=1; i1<=4; i1++ )
        {
            int z;
            for( i2=1; i2<=4; i2++ )
            {
                if( D2[k][2][i1] != ext(i2) )
                {
                    z = z + 1;
                }
            }
            if( z == 4 )
            {
                int newlabel(count) = D2[k][2][i1];
                count = count + 1;
            }
        }
        
        // Determine which of the numbers in {ext(i)}_{i=1,...,4} also appear 
        // in D1[k][2], and let us define i1,i2 such that these are ext(i1) and ext(i2).
        // These keep the ordering given in D1[k][2].
        list extlabel;
        for( i1=1; i1<=4; i1++ )
        {
            for( i2=1; i2<=4; i2++ )
            {
                if( D2[k][2][i1] == ext(i2) )
                {
                    extlabel = extlabel + list(i2);
                    break;
                }
            }
        }
        int i1 = extlabel[1]; // TODO: mondo confusing notation
        int i2 = extlabel[2];

        // At this stage, the variable listOfCVariableNames[i] corresponds to 
        // the edge label listOfEdgeLabels[i] for i=1,...,6:
        //          x(1) cooresponds to ext(i1),
        //          x(2) cooresponds to ext(i2),
        //          y(k) corresponds to ext(k) for k in {1,2,3,4}\{i1,i2},
        //          y(i1) cooresponds to n(1),
        //          y(i2) cooresponds to n(2).
        int assotox1,assotox2 = ext(i1),ext(i2);
        list newexternals; int count = 1;
        for( i=1; i<=4; i++ )
        {
            if( i != i1 && i != i2 )
            {
                newexternals[i] = ext(i);
            }
            else
            {
                newexternals[i] = newlabel(count);
                count = count + 1;
            }
        }
        for( i=1; i<=4; i++ )
        {
            ext(i) = newexternals[i];
        }
        list listOfCVariableNames = x(1),x(2),y(1),y(2),y(3),y(4);
        list listOfEdgeLabels = assotox1,assotox2,ext(1),ext(2),ext(3),ext(4);
    
        // Find the variable dependence of the "blob" MF which is the fusion of the
        // first k-1 vertices and the k-th MF:    
        list blobvaris, varis(k);
        for( i3=1; i3<=4; i3++ )
        {
            for( i4=1; i4<=6; i4++ )
            {
                if( finalvaris[i3] == listOfEdgeLabels[i4] )
                {
                    blobvaris[i3] = listOfCVariableNames[i4];
                }
                if( D2[k][2][i3] == listOfEdgeLabels[i4] )
                {
                    varis(k)[i3] = listOfCVariableNames[i4];
                }
            }
        }
        
        // Redefine the results of step k-1 according to the new identifications:
        final2 = subst( final2, y(i1), x(1) ); final2 = subst( final2, y(i2), x(2) );
        webmap = subst( webmap, y(i1), x(1) ); webmap = subst( webmap, y(i2), x(2) );
        s2(k-2) = subst( s2(k-2), y(i1), x(1) ); s2(k-2) = subst( s2(k-2), y(i2), x(2) );
        t2(k-2) = subst( t2(k-2), y(i1), x(1) ); t2(k-2) = subst( t2(k-2), y(i2), x(2) );
        F2(k-2) = subst( F2(k-2), y(i1), x(1) ); F2(k-2) = subst( F2(k-2), y(i2), x(2) );
        
        // V2(k) is the MF associated to the k-th vertex in web 2: 
        matrix V2(k) = mfVertex( D2[k][1], varis(k), N );
    
        intvec V2gr(k) = mfVertexGrading( D2[k][1], varis(k), N );
        
        // Now start to reduce final1 x V1(k), final2 x V2(k) and the map between them:
        
        ideal J = x(1)^N, x(2)^N;
        intvec q = N, N;
        number Nn = N + 1;
        matrix C[2][2] = 1/Nn, 0, 0, 1/Nn;
        
        if( k == chiposition )
        {
            alpha(k) = mfChi(chitype, varis(k)[1], varis(k)[2], varis(k)[3], varis(k)[4], N);
        }
        
        // Compute the ordinary tensor product:
        matrix T2 = MFtensor( final2, V2(k) );
        matrix T2blow = mablow(T2,J);

        intvec T2gr = MFtensorGradings( final2gr, V2gr(k) );
        intvec T2blowgr = mablowGrading(T2gr,J,N);

        // blown-up version of the map between the first k vertices:
        webmap = mablow( ZZtensor( webmap, alpha(k) ), J );
        
        // Reduce this inflated differential:
        list l2 = mfReduce(T2blow,1);
        matrix RT2 = l2[1];
        matrix F2(k-1) = l2[2]; // A homotopy equivalence T2blow -> RT2
        matrix G2(k-1) = l2[3]; // A homotopy equivalence RT2 -> T2blow
    
        intvec RT2gr = computeGradingFromInjection(G2(k-1),T2blowgr);
    
        // Define d1(1) to be the product over all outgoing edges labelled by x-variables
        // of the derivatives of final1 with respect to these variables, and
        // define d1(k) to be the product over all outgoing edges labelled by x-variables
        // of the derivatives of V1(k) with respect to these variables, and
        // similarly for d2(1) and d2(2):
        matrix d2(1) = unitmat( ncols( final2 ) );
        matrix d2(k) = unitmat( ncols( V2(k) ) );
        for( i=1; i<=2; i++ )
        {
            // vertex final1:
            if( x(1) == blobvaris[i] )
            {
                d2(1) = d2(1) * diff( final2, x(1) );
            }
        
            if( x(2) == blobvaris[i] )
            {
                d2(1) = d2(1) * diff( final2, x(2) );
            }
        
            // vertex V1(2):
            if( x(1) == varis(k)[i] )
            {
                d2(k) = d2(k) * diff( V2(k), x(1) );
            }
        
            if( x(2) == varis(k)[i] )
            {
                d2(k) = d2(k) * diff( V2(k), x(2) );
            }
        }
        
        matrix diff2(1) = ZZtensor( d2(1), unitmat( ncols( V2(k) ) ) );
        matrix diff2(2) = ZZtensor( unitmat( ncols( final2 ) ), d2(k) );
        matrix iddQ2 = mablow( det(C) * diff2(1) * diff2(2), J );

        matrix delta2(1) = mablow_delta(T2, 1, N, J);
        matrix delta2(2) = mablow_delta(T2, 2, N, J);
        matrix delQ2 = delta2(1) * delta2(2);
    
        // And finally the idempotents e1,e2 on T1blow,T2blow:
        matrix e2 = (-1)^k * iddQ2 * delQ2;   // TODO: is the factor (-1)^k correct?
    
        matrix ep2 = F2(k-1) * e2 * G2(k-1);
        
        // Sanity checks:
        if( ep2 * RT2 != RT2 * ep2 )
        {
            print("[mfCompileWeb3] The reduced idempotent (up to homotopy) ep2 at level "+string(k)+" is not an endomorphism of RT2, exiting.");
            return();
        }
    
        if( paranoidChecks )
        {
            // Check that ep1 and ep2 are idempotent up to homotopy
            matrix ep2ck = ep2;
            ep2ck = subst( ep2ck, y(1), 0 );
            ep2ck = subst( ep2ck, y(2), 0 );
            ep2ck = subst( ep2ck, y(3), 0 );
            ep2ck = subst( ep2ck, y(4), 0 );
            if( ep2ck * ep2ck != ep2ck )
            {
                // TODO DEBUG DEBUG WARNING UGLY HACK
                ep2 = -ep2;
                
                //print("[mfCompileWeb3] ep2 at level "+string(k)+" is not idempotent up to homotopy, exiting.");
                //return();
            }
        }
        
        // Strictify these idempotents:
        matrix epstrict2 = mfStrictifyIdempotent(RT2, ep2);
    
        // Sanity checks:
        if( epstrict2 * RT2 != RT2 * epstrict2 || epstrict2 * epstrict2 != epstrict2 )
        {
            print("[mfCompileWeb3] The strictified idempotent epstrict2 at level "+string(k)+" is not an endomorphism of RT2, or not an idempotent on the nose, exiting.");
            return();
        }

        list l2 = mfSplitIdempotent(RT2, epstrict2, RT2gr);

        final2 = mfSuspend( l2[1], 2 );
    
        final2gr = mfSuspendGrading( l2[4], 2 );
        
        // Grading sanity check
        if( isGradingValid(final2,final2gr) != 1 )
        {
            print("[mfCompileWeb3] Something has gone wrong with the grading in induction, exiting.");
            return();
        }
        
        // Determine the outgoing and incoming labels of final1 and final2
        // (in terms of the integer labels in {1,...,2*websize}). 
        // As final1 and final2 both depend only on y(1),...,y(4), their incident
        // edges are labelled by ext(1),...,ext(4). We need to determine i1,i2 such
        // that the vertices labelled by ext(i1) and ext(i2) are incoming. 
        // Then we define a list finalvaris whose first two entries are ext(i1),ext(i2),
        // and whose third and fourth entry is given by the remaning two labellings.
        list templist;
        for( i=1; i<=4; i++ )
        {
            for( i1=1; i1<=2; i1++ )
            {
                for( i2=1; i2<=2; i2++ )
                {
                    if( ext(i) == finalvaris[i1] || ext(i) == D2[k][2][i2] )
                    {
                        templist = templist + list(i);
                        i = i + 1;
                    }
                }
            }
        }    
        for( i=1; i<=4; i++ )
        {
            if( i != templist[1] && i != templist[2] )
            {
                templist = templist + list(i);
            }
        }
        list finalvaris;
        for( i=1; i<=4; i++ )
        {
            finalvaris[i] = ext(templist[i]);
        }
    
        // Compute the transformation matrices:

        matrix s2(k-1) = mfSuspendMorph( l2[2], 2 );    // final2 --> RT2
        matrix t2(k-1) = mfSuspendMorph( l2[3], 2 );    // RT2 --> final2

        // Compute the induced map between the reductions
        webmap = t2(k-1) * F2(k-1) * webmap * GTransWeb[k-1] * STransWeb[k-1];
            
        kill T2, T2blow, l2, RT2, d2(1), d2(k), diff2(1), diff2(2), iddQ2, delta2(1), delta2(2), delQ2, e2, ep2, epstrict2; 
        
    }//end of k-loop
    
    // Now do the final fusion of the first websize-1 vertices with the last one.
    dbprint(printlevel, "[mfCompileWeb3] Performing final fusion.");
    
    // Rename y(i) to x(i) for all i=1,...,4:
    int k = websize;
    int i;
    def lastvertex = D2[websize][2];
    int nx=4;
    int ny=4;
    ring rr2=0,(x(1..nx),y(1..ny)),dp;
    matrix final2 = imap(RRR,final2);
    matrix s2(k-2) = imap(RRR,s2(k-2));
    matrix t2(k-2) = imap(RRR,t2(k-2));
    matrix F2(k-2) = imap(RRR,F2(k-2));
    matrix webmap = imap(RRR,webmap);
    for( i=1; i<=4; i++ )
    {
        final2 = subst(final2,y(i),x(i));    
        s2(k-2) = subst(s2(k-2),y(i),x(i));
        t2(k-2) = subst(t2(k-2),y(i),x(i));
        F2(k-2) = subst(F2(k-2),y(i),x(i));
        webmap = subst(webmap,y(i),x(i));
    }
    int nx=4;
    ring rr3=0,(x(1..nx)),dp;
    int i,j,i1,i2,i3,i4;
    matrix final2 = imap(rr2,final2);
    matrix s2(k-2) = imap(rr2,s2(k-2));
    matrix t2(k-2) = imap(rr2,t2(k-2));
    matrix F2(k-2) = imap(rr2,F2(k-2));
    matrix webmap = imap(rr2,webmap);

    list listOfCVariableNames = x(1),x(2),x(3),x(4);
    list listOfEdgeLabels = ext(1),ext(2),ext(3),ext(4);
    
    // Find the variable dependence of the "blob" MF which is the fusion of the
    // first k-1 vertices and the k-th MF:    
    list blobvaris, varis(k);
    for( i3=1; i3<=4; i3++ )
    {
        for( i4=1; i4<=4; i4++ )
        {
            if( finalvaris[i3] == listOfEdgeLabels[i4] )
            {
                blobvaris[i3] = listOfCVariableNames[i4];
            }
            if( lastvertex[i3] == listOfEdgeLabels[i4] )
            {
                varis(k)[i3] = listOfCVariableNames[i4];
            }
        }
    }
    
    // V2(k) is the MF associated to the k-th vertex in web 2: 
    matrix V2(k) = mfVertex( D2[k][1], varis(k), N );

    intvec V2gr(k) = mfVertexGrading( D2[k][1], varis(k), N );
    
    // Now start to reduce final1 x V1(k), final2 x V2(k) and the map between them:

    ideal J = x(1)^N, x(2)^N, x(3)^N, x(4)^N;
    intvec q = N, N, N, N;
    number Nn = N + 1;
    matrix C[4][4] = 1/Nn * unitmat(4);
    
    matrix alpha(k) = unitmat(4);
    if( k == chiposition )
    {
        matrix alpha(k) = mfChi(chitype, varis(k)[1], varis(k)[2], varis(k)[3], varis(k)[4], N);
    }

    // Compute the ordinary tensor product:
    matrix T2 = MFtensor( final2, V2(k) );
    matrix T2blow = mablow(T2,J);
    
    T2gr = MFtensorGradings( final2gr, V2gr(k) );
    T2blowgr = mablowGrading(T2gr,J,N);
    
    // blow up webmap
    webmap = mablow( ZZtensor( webmap, alpha(k) ), J );
        
    // Reduce this inflated differential:
    list l2 = mfReduce(T2blow,1);
    matrix RT2 = l2[1];
    matrix F2(k-1) = l2[2]; // A homotopy equivalence T2blow -> RT2
    matrix G2(k-1) = l2[3]; // A homotopy equivalence RT2 -> T2blow

    RT2gr = computeGradingFromInjection(G2(k-1),T2blowgr);
    
    matrix lastG = imap(RRR,finalG);
    webmap = F2(k-1) * webmap * lastG;
    
    // Define d1(1) to be the product over all outgoing edges labelled by x-variables
    // of the derivatives of final1 with respect to these variables, and
    // define d1(k) to be the product over all outgoing edges labelled by x-variables
    // of the derivatives of V1(k) with respect to these variables, and
    // similarly for d2(1) and d2(2):
    matrix d2(1) = unitmat( ncols( final2 ) );
    matrix d2(k) = unitmat( ncols( V2(k) ) );
    for( i=1; i<=2; i++ )
    {
        // vertex final1:
        if( x(1) == blobvaris[i] )
        {
            d2(1) = d2(1) * diff( final2, x(1) );
        }
        if( x(2) == blobvaris[i] )
        {
            d2(1) = d2(1) * diff( final2, x(2) );
        }
        if( x(3) == blobvaris[i] )
        {
            d2(1) = d2(1) * diff( final2, x(3) );
        }
        if( x(4) == blobvaris[i] )
        {
            d2(1) = d2(1) * diff( final2, x(4) );
        }
            
        // vertex V1(k):
        if( x(1) == varis(k)[i] )
        {
            d2(k) = d2(k) * diff( V2(k), x(1) );
        }        
        if( x(2) == varis(k)[i] )
        {
            d2(k) = d2(k) * diff( V2(k), x(2) );
        }
        if( x(3) == varis(k)[i] )
        {
            d2(k) = d2(k) * diff( V2(k), x(3) );
        }        
        if( x(4) == varis(k)[i] )
        {
            d2(k) = d2(k) * diff( V2(k), x(4) );
        }
    }
        
    matrix diff2(1) = ZZtensor( d2(1), unitmat( ncols( V2(k) ) ) );
    matrix diff2(2) = ZZtensor( unitmat( ncols( final2 ) ), d2(k) );
    matrix iddQ2 = mablow( det(C) * diff2(1) * diff2(2), J );

    matrix delta2(1) = mablow_delta(T2, 1, N, J);
    matrix delta2(2) = mablow_delta(T2, 2, N, J);
    matrix delta2(3) = mablow_delta(T2, 3, N, J);
    matrix delta2(4) = mablow_delta(T2, 4, N, J);
    matrix delQ2 = delta2(1) * delta2(2) * delta2(3) * delta2(4);
    
    // And finally the idempotents e1,e2 on T1blow,T2blow:
    // Note the sign factor is binom(4,2) = 6 so we ignore it
    matrix e2 = (-1)^k * iddQ2 * delQ2;   // TODO: is the factor (-1)^k correct?
    
    matrix ep2 = F2(k-1) * e2 * G2(k-1);
    
    matrix epstrict2 = mfStrictifyIdempotent(RT2, ep2);
    
    matrix ep0r = extractblockmat(epstrict2)[1];
    matrix ep1r = extractblockmat(epstrict2)[4];
    int rank0r = mat_rk(ep0r);
    int rank1r = mat_rk(ep1r);

    int z2degree;
    intvec splitgrr;
    
    // Now compute the non-zero part of the map of the above two complexes:
    if( rank1r != 0 )
    {
        z2degree = 1;
        matrix eq0fr = ep1r;

        // Now split the idempotent eq0fr by hand:
        LIB "control.lib";
        module ker0r = rightKernel(unitmat(ncols(eq0fr)) - eq0fr);
        matrix f0r = ker0r;
        matrix g0r[ncols(f0r)][nrows(f0r)];
    
        if( ker0r[1] != [0] )
        {
            matrix g0r = leftInverse(f0r) * eq0fr;
        };

        // The grading on the odd part of RT2 is given by
        intvec RT2gr1 = RT2gr[(size(RT2gr)/2+1)..size(RT2gr)];
        splitgrr = computeGradingFromInjection(f0r,RT2gr1);
        
        // Finally, to get the (non-zero part of the) map from web1 to web2:
        
        matrix lastS = imap(RRR, finalS);
        webmap = g0r * extractblockmat(webmap)[4] * lastS;
    }
    if( rank0r != 0 )
    {
        z2degree = 0;
        matrix eq0fr = ep0r;

        // Now split the idempotent eq0fr by hand:
        LIB "control.lib";
        module ker0r = rightKernel(unitmat(ncols(eq0fr)) - eq0fr);
        matrix f0r = ker0r;
        matrix g0r[ncols(f0r)][nrows(f0r)];
    
        if( ker0r[1] != [0] )
        {
            matrix g0r = leftInverse(f0r) * eq0fr;
        };

        // The grading on the even part of RT2 is given by
        intvec RT2gr0 = RT2gr[1..(size(RT2gr)/2)];
        splitgrr = computeGradingFromInjection(f0r, RT2gr0);

        // Finally, to get the (non-zero part of the) map from web1 to web2:

        matrix lastS = imap(RRR, finalS);
        webmap = g0r * extractblockmat(webmap)[1] * lastS;
    }
    
            kill V2(k), J, C, T2, T2blow, l2, RT2, diff2(1), diff2(2), iddQ2, delta2(1), delta2(2), delta2(3), delta2(4), delQ2, e2, epstrict2, ep0r, ep1r;
    
    // The reduced MFs of zero are concentrated in Z2-degree z2degree, 
    // and webmap is the non-zero map between them:
    
    setring RRR;
    
    // Define lists populated by the transformation maps G1,F2,s1,t1,f0,g0r
    // (to be used if the alternate versions of mfCompileWeb are called in
    // mfCompileLink, which happens if D1 and/or D2 has already been compiled):
    list transformationMaps2;
    for( i=1; i<=2; i++ )
    {
        transformationMaps2[i] = list();
    }
    for( i=1; i<=k-2; i++ )
    {
        transformationMaps2[1][i] = F2(i);
        transformationMaps2[2][i] = t2(i);
    }
    transformationMaps2[1][k-1] = imap(rr3,F2(k-1));
    transformationMaps2[2][k-1] = imap(rr3,g0r);
    
    matrix webmap = imap(rr3,webmap);
    
    list finaloutput = webmap, z2degree, weightsOfWeb1[1], splitgrr, transformationMaps2;
    kill webmap, z2degree, splitgrr;
    return(finaloutput);
}


proc mfCompileWeb4(list linkData, GTransWeb, STransWeb, FTransWeb, TTransWeb, weightsOfWeb1, weightsOfWeb2, int z2deg, int chitype, int chiposition, int N)
{
    dbprint(printlevel, "[mfCompileWeb4] Beginning induction step.");
    
    def RRR = basering;
    int websize = size(GTransWeb) + 1;
    
    matrix finalG = GTransWeb[websize-1];
    matrix finalS = STransWeb[websize-1];    
    matrix finalF = FTransWeb[websize-1];
    matrix finalT = TTransWeb[websize-1];    
    
    int i,j,k,i1,i2,i3,i4;
    
    // Define the morphisms between the unreduced tensor factors to be
    // identity maps (only later redefine the chipositions-th alpha to
    // be the appropriate chi map):
    
    for( i=1; i<=websize; i++ )
    {
        matrix alpha(i) = unitmat(4);
    }
        
    list L1,L2;
    for( i=1; i<=4; i++ )
    {
        L1[i] = linkData[2][1][i]; 
        L2[i] = linkData[2][2][i];
    }
    
    int z = 1;
    for( i1=1; i1<=4; i1++ )
    {
        for( i2=1; i2<=4; i2++ )
        {
            if( L1[i1] == L2[i2] )
            {
                int inter(z) = L1[i1];
                z = z + 1;
            }
        }
    }

    L1 = removefromlist(removefromlist( L1, inter(1) ), inter(2) );
    L2 = removefromlist(removefromlist( L2, inter(1) ), inter(2) );     
    for( i=1; i<=2; i++ )
    {
        int ext(i) = L1[i];
        int ext(i+2) = L2[i];
    }
    
    list listOfCVariableNames = x(1),x(2),y(1),y(2),y(3),y(4);
    list listOfEdgeLabels = inter(1),inter(2),ext(1),ext(2),ext(3),ext(4);
    
    list varis(1), varis(2);
    for( i1=1; i1<=4; i1++ )
    {
        for( i2=1; i2<=6; i2++ )
        {
            if( linkData[2][1][i1] == listOfEdgeLabels[i2] )
            {
                varis(1)[i1] = listOfCVariableNames[i2];
            }
            if( linkData[2][2][i1] == listOfEdgeLabels[i2] )
            {
                varis(2)[i1] = listOfCVariableNames[i2];
            }

        }
    }
    
    ideal J = x(1)^N, x(2)^N;
    intvec q = N, N;
    number Nn = N + 1;
    matrix C[2][2] = 1/Nn, 0, 0, 1/Nn;

    for( i=1; i<=2; i++ )
    {
        if( i == chiposition )
        {
            alpha(i) = mfChi(chitype, varis(i)[1], varis(i)[2], varis(i)[3], varis(i)[4], N);
            break;
        }
    }

    matrix webmap = mablow( ZZtensor( alpha(1), alpha(2) ), J );
    
    webmap = TTransWeb[1] * FTransWeb[1] * webmap * GTransWeb[1] * STransWeb[1];
    
    for( k=3; k<=websize-1; k++ )
    {
        int count = 1;
        for( i1=1; i1<=4; i1++ )
        {
            int z;
            for( i2=1; i2<=4; i2++ )
            {
                if( linkData[2][k][i1] != ext(i2) )
                {
                    z = z + 1;
                }
            }
            if( z == 4 )
            {
                int newlabel(count) = linkData[2][k][i1];
                count = count + 1;
            }
        }
        
        list extlabel;
        for( i1=1; i1<=4; i1++ )
        {
            for( i2=1; i2<=4; i2++ )
            {
                if( linkData[2][k][i1] == ext(i2) )
                {
                    extlabel = extlabel + list(i2);
                    break;
                }
            }
        }
        int i1 = extlabel[1]; // TODO: mondo confusing notation
        int i2 = extlabel[2];

        int assotox1,assotox2 = ext(i1),ext(i2);
        list newexternals; int count = 1;
        for( i=1; i<=4; i++ )
        {
            if( i != i1 && i != i2 )
            {
                newexternals[i] = ext(i);
            }
            else
            {
                newexternals[i] = newlabel(count);
                count = count + 1;
            }
        }
        for( i=1; i<=4; i++ )
        {
            ext(i) = newexternals[i];
        }
        list listOfCVariableNames = x(1),x(2),y(1),y(2),y(3),y(4);
        list listOfEdgeLabels = assotox1,assotox2,ext(1),ext(2),ext(3),ext(4);
    
        list varis(k);
        for( i3=1; i3<=4; i3++ )
        {
            for( i4=1; i4<=6; i4++ )
            {
                if( linkData[2][k][i3] == listOfEdgeLabels[i4] )
                {
                    varis(k)[i3] = listOfCVariableNames[i4];
                }
            }
        }
        
        webmap = subst( webmap, y(i1), x(1) ); webmap = subst( webmap, y(i2), x(2) );
        
        ideal J = x(1)^N, x(2)^N;
        intvec q = N, N;
        number Nn = N + 1;
        matrix C[2][2] = 1/Nn, 0, 0, 1/Nn;
        
        if( k == chiposition )
        {
            alpha(k) = mfChi(chitype, varis(k)[1], varis(k)[2], varis(k)[3], varis(k)[4], N);
        }
        
        webmap = mablow( ZZtensor( webmap, alpha(k) ), J );
        
        webmap = TTransWeb[k-1] * FTransWeb[k-1] * webmap * GTransWeb[k-1] * STransWeb[k-1];
        
    }//end of k-loop
    
    int k = websize;
    int i;
    def lastvertex = linkData[2][websize];
    int nx=4;
    int ny=4;
    ring rr2=0,(x(1..nx),y(1..ny)),dp;
    matrix webmap = imap(RRR,webmap);
    for( i=1; i<=4; i++ )
    {
        webmap = subst(webmap,y(i),x(i));
    }
    int nx=4;
    ring rr3=0,(x(1..nx)),dp;
    int i,j,i1,i2,i3,i4;
    matrix webmap = imap(rr2,webmap);

    list listOfCVariableNames = x(1),x(2),x(3),x(4);
    list listOfEdgeLabels = ext(1),ext(2),ext(3),ext(4);
    
    list varis(k);
    for( i3=1; i3<=4; i3++ )
    {
        for( i4=1; i4<=4; i4++ )
        {
            if( lastvertex[i3] == listOfEdgeLabels[i4] )
            {
                varis(k)[i3] = listOfCVariableNames[i4];
            }
        }
    }
    
    ideal J = x(1)^N, x(2)^N, x(3)^N, x(4)^N;
    intvec q = N, N, N, N;
    number Nn = N + 1;
    matrix C[4][4] = 1/Nn * unitmat(4);
    
    matrix alpha(k) = unitmat(4);
    if( k == chiposition )
    {
        matrix alpha(k) = mfChi(chitype, varis(k)[1], varis(k)[2], varis(k)[3], varis(k)[4], N);
    }

    dbprint(printlevel, "[mfCompileWeb4] Performing final fusion.");

    webmap = mablow( ZZtensor( webmap, alpha(k) ), J );
        
    matrix lastG = imap(RRR,finalG);
    matrix lastF = imap(RRR,finalF);
    webmap = lastF * webmap * lastG;
    
    int z2degree;
        
    if( z2deg == 0 )
    {
        z2degree = 1;

        matrix lastS = imap(RRR, finalS);
        matrix lastT = imap(RRR, finalT);
        webmap = lastT * extractblockmat(webmap)[1] * lastS;
    }
    if( z2deg != 0 )
    {
        z2degree = 0;

        matrix lastS = imap(RRR, finalS);
        matrix lastT = imap(RRR, finalT);
        webmap = lastT * extractblockmat(webmap)[4] * lastS;
    }
        
    setring RRR;
        
    matrix webmap = imap(rr3,webmap);
    
    list finaloutput = webmap, z2degree, weightsOfWeb1[1], weightsOfWeb2[1];
    kill webmap, z2degree;
    return(finaloutput);
}

