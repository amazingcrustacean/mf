version="0.1";
category="Miscellaneous";
// summary description of the library
info="
LIBRARY:   linkhom.lib  Computation of link homology using foam compilation
AUTHOR:    Nils Carqueville, Daniel Murfet
KEYWORDS:  matrix factorization, link homology

PROCEDURES:
";

LIB "linalg.lib";
LIB "matrix.lib";
LIB "ring.lib";
LIB "blow.lib"

////////////////////////////////////////////////////////////////////
// USAGE GUIDE
//
// We expect our ambient ring to be of the type
//
//     0,(x(1..nx),y(1..ny)),dp
// 
// where nx, ny are integer variables that we expect to be defined before calling
// any of the routines in this library. The x variables are the "internal" variables.
// The references to [KR] are to Khovanov and Rozansky "Matrix factorizations and
// link homology" arXiv:math/0401268v2.

////////////////////////////////////////////////////////////////////
// NOTES ON GRADING
//
// In [KR, p.47] all variables are assigned degree two. The conventions for graded
// matrix factorisations are explained in [KR, p.44]
//
// Note that the Jacobi algebra A = QQ[x]/(x^n) (notation of [KR]) is naturally graded,
// but this grading is shifted up by n - 1 so that |1| = n - 1 and |x^i| = 2i + n - 1.
// Note this shift is the opposite direction to the one given in (see [KR,p.45]), but
// actual calculations seem to suggest that this is an error in [KR]. See blow-example-grading.

/////////////////////////////////////////////////////////////////////////////////////
// g - returns the polynomial g of [KR] p.48.
/////////////////////////////////////////////////////////////////////////////////////

proc gpoly(poly s1, poly s2, int n)
{
    poly g = s1^(n+1);
    
    int i;
    for(i=1;i<=(n+1)/2;i++)
    {
        g = g + (n+1) * (-1)^(i) * ( binomial(n-i,i-1) * s2^(i) * s1^(n+1-2*i) )/i;
    }
    
    return(g);
}

////////////////////////////////////////////////////////////////////
// mfWideEdge
//
// We are given four variables a,b,c,d and an integer N, and we return
// the matrix factorisation of a^(n+1) + b^(n+1) - c^(n+1) - d^(n+1)
// associated by Khovanov and Rozansky to a wide edge in the planar
// diagram of a link (see p.48 of [KR]). Let us include the
// following picture of a wide edge
//
//       a        b
//         \   /
//          \/
//          |
//          |
//         /\
//       /   \
//     d       c
//
// where a,b,c,d are variables labelled on the edges as shown. Note that this
// is the ordering convention of Figure 8 on p.9 of [KR]. With this convention
// if you call
//
// matrix D = mfWideEdge(x(1),x(2),x(3),x(4),N);
//
// Then the matrix D you get will be the (Q1,Q2) pair written on p.50 of [KR]. Note however
// that everything is symmetric for the exchange x(1) <-> x(2) and x(4) <-> x(3).
////////////////////////////////////////////////////////////////////

proc mfWideEdge(poly a, poly b, poly c, poly d, int n)
{
    poly W = a^(n+1) + b^(n+1) - c^(n+1) - d^(n+1);
    
    // Following KR we write W = (a + b - c - d)u1 + (ab - cd)u2 
    poly u1 = (gpoly(a + b, a*b, n) - gpoly(c + d, a*b, n))/(a+b-c-d);
    poly u2 = (gpoly(c + d, a*b, n) - gpoly(c + d, c*d, n))/(a*b-c*d);
    
    if( W != u1 * (a + b - c - d) + u2 * (a * b - c * d) )
    {
        print("[mfWideEdge] Something wrong in the calculation, exiting.");
        return();
    }
    
    matrix koszul1[2][2] = 0, a + b - c - d, u1, 0;
    matrix koszul2[2][2] = 0, a * b - c * d, u2, 0;
    
    // Note the order that we tensor these two Koszul complexes is opposite
    // to the order suggested on p.48 of [KR]. This is done so as to agree
    // with the matrices written on p.50.
    matrix D = MFtensor(koszul2, koszul1);
    
    return(D);
}

proc mfWideEdgeGrading(int n)
{
    // Note that deg(u1) = n and deg(u2) = n - 1 so as written on 
    // [KR, p.48] the Koszul factorisations koszul1 and koszul2 have
    // respective grading vectors
    intvec g = 0, 1-n;
    intvec h = 0, 3-n;
    
    // Grading vector on the tensor product
    intvec r = MFtensorGradings(h, g);
    
    // The grading is then shifted by -1, as defined on [KR, p.48]
    int i;
    for(i=1;i<=size(r);i++){ r[i] = r[i] - 1; }
    
    return(r);
}

////////////////////////////////////////////////////////////////////
// mfIdentityDefect
//
// We are given two potentials W1 and W2 and two variables y and x.
// We assume that W1 = W(y) and W2 = W(x) for some fixed polynomial
// W and we return the identity defect W2 -> W1
////////////////////////////////////////////////////////////////////

proc mfIdentityDefect(poly W1, poly W2, poly y, poly x)
{
    matrix koszul1[2][2] = 0, y - x, (W1 - W2)/(y - x), 0;
    return(koszul1);
}

// We are given the degree of some homogeneous potential
proc mfIdentityDefectGrading(int dg)
{
    int n = dg - 1;
    
    // We have |W| = 2(n+1) and the identity defect is given the grading
    // R ---> R{1+n-|(W1-W2)/(y-x)|} --> R, but |(W1-W2)/(y-x)| = 2 * n so
    // this is R ---> R{1-n} ---> R, see [KR, p.45].
    
    intvec g = 0, 1-n;
    return(g);
}

////////////////////////////////////////////////////////////////////
// mfIdentityEdge
//
// We are given four variables a,b,c,d and an integer N, and we return
// the matrix factorisation of a^(n+1) + b^(n+1) - c^(n+1) - d^(n+1)
// associated by Khovanov and Rozansky to the Gamma0 diagram of Figure 8
// Let us include the following picture of a wide edge
//
//       a        b
//         \   /
//          \/
//          |
//          |
//         /\
//       /   \
//     d       c
//
// where a,b,c,d are variables labelled on the edges as shown. The return
// is the tensor product of L^b_c with L^a_d (in KR's notation), in that
// order. Note that this is not symmetric with respect to the interchange
// a <-> b or c <-> d, so the ordering of the variables matters.
////////////////////////////////////////////////////////////////////

proc mfIdentityEdge(poly a, poly b, poly c, poly d, int n)
{
    matrix Aa = mfIdentityDefect( a^(n+1), d^(n+1), a, d );
    matrix Ab = mfIdentityDefect( b^(n+1), c^(n+1), b, c );
    
    // Note the order of the tensor factors (this is opposite to what
    // a first reading of the third line of [KR, p.50] would suggest,
    // but is necessary to reproduce the matrices P0 and P1 there, and
    // to make chi0 = (U0,U1) into a morphism of MFs).
    matrix A = MFtensor(Ab, Aa);
    
    return(A);
}

proc mfIdentityEdgeGrading(int n)
{
    intvec Aagr = mfIdentityDefectGrading( n+1 );
    intvec Abgr = mfIdentityDefectGrading( n+1 );
    intvec Agr = MFtensorGradings(Abgr, Aagr);
    
    return(Agr);
}

////////////////////////////////////////////////////////////////////
// checklist
//
// checklist(l,p) gives 1 if p is an element of the list l,
// otherwise it gives 0.
////////////////////////////////////////////////////////////////////

proc checklist(list l, p)
{
    int inlist;
    for(int i=1; i<=size(l); i++)
    {
        def li = l[i];
        if(p==li)
        {
            inlist=1;
        }
    }
    return(inlist);
}


////////////////////////////////////////////////////////////////////
// removefromlist
//
// removefromlist(l,p) gives back the list l, but with all instances of
// entries p deleted. For example:
// removefromlist( list(1,2,2,3,2), 2 ) = list(1,3). 
////////////////////////////////////////////////////////////////////

proc removefromlist(list l, poly p)
{
    for(int i=1; i<=size(l); i++)
    {
        def li = l[i];
        if(p==li)
        {
            l = delete(l,i);
            i=i-1;
        }
    }
    return(l);
}


////////////////////////////////////////////////////////////////////
// mfVertex
//
// mfVertex(zeroOrOne, varis, N) gives the "KR-vertex" of type 0
// (tensor product of two identity defects) or of type 1 (wide edge
// defect) in the list of variables varis. N as in sl(N). The ordering
// of the variables in varis corresponds to 
//
//     varis[1]   varis[2]
//           \   /
//            \/
//            |
//            |
//           /\
//         /   \
//   varis[4]    varis[3]
//
// See the comments preceeding mfIdentityEdge for an idea of why the
// ordering here is significant.
////////////////////////////////////////////////////////////////////

proc mfVertex(int zeroOrOne, list varis, int N)
{
    if( zeroOrOne == 0 )
    {
        matrix A = mfIdentityEdge( varis[1], varis[2], varis[3], varis[4], N );
        return(A);
    }
        
    if( zeroOrOne == 1 )
    {
        matrix A = mfWideEdge( varis[1], varis[2], varis[3], varis[4], N );
        return(A);
    }
}

////////////////////////////////////////////////////////////////////
// mfVertexGrading
////////////////////////////////////////////////////////////////////

proc mfVertexGrading(int zeroOrOne, list varis, int N)
{
   if( zeroOrOne == 0 )
   {
       intvec Agr = mfIdentityEdgeGrading(N);
       return(Agr);
   }
   
   if( zeroOrOne == 1 )
   {
       intvec Agr = mfWideEdgeGrading(N);
       return(Agr);
   }
}

////////////////////////////////////////////////////////////////////
// mfChi
//
// mfChi(zeroOrOne,x(1),x(2),x(3),x(4),N) is the map C(Gamma^0) --> C(Gamma^1)
// from [KR, p.50] for zeroOrOne=0, and the map C(Gamma^1) --> C(Gamma^0)
// from [KR, p.51] for zeroOrOne=1.
////////////////////////////////////////////////////////////////////

proc mfChi(int zeroOrOne, poly p(1), p(2), p(3), p(4), int N)
{
    if( zeroOrOne == 0 )
    {
        poly pi23 = ( p(2)^(N+1) - p(3)^(N+1) )/( p(2)-p(3) );
        poly u1 = ( gpoly(p(1)+p(2), p(1)*p(2), N) - gpoly(p(3)+p(4), p(1)*p(2), N) )/( p(1)+p(2)-p(3)-p(4) );
        poly u2 = ( gpoly(p(3)+p(4), p(1)*p(2), N) - gpoly(p(3)+p(4), p(3)*p(4), N) )/( p(1)*p(2)-p(3)*p(4) );
        poly aa1 = -u2 + ( u1 +  p(1) * u2 - pi23 )/( p(1) - p(4) );

        matrix chi0[4][4] = p(4)-p(2), 0, 0,    0,
                        aa1,        1, 0,    0,
                        0,         0, p(4), -p(2),
                        0,         0, -1,   1;            // We set mu=0.                    
        return(chi0);
    }

    if( zeroOrOne == 1 )
    {
        poly pi23 = ( p(2)^(N+1) - p(3)^(N+1) )/( p(2)-p(3) );
        poly u1 = ( gpoly(p(1)+p(2), p(1)*p(2), N) - gpoly(p(3)+p(4), p(1)*p(2), N) )/( p(1)+p(2)-p(3)-p(4) );
        poly u2 = ( gpoly(p(3)+p(4), p(1)*p(2), N) - gpoly(p(3)+p(4), p(3)*p(4), N) )/( p(1)*p(2)-p(3)*p(4) );
        poly aa2 = ( u1 + p(1) * u2 - pi23 )/( p(4)-p(1) );
        poly aa3 = p(1) - p(3);

        matrix chi1[4][4] = 1, 0, 0,    0,
                        aa2,        aa3, 0,    0,
                        0,         0, 1, p(3),
                        0,         0, 1, p(1);            // We set lambda=0.
    
        return(chi1);
    }
}

////////////////////////////////////////////////////////////////////
// mfCompileWeb
//
// mfCompileWeb(D1, D2, chitype, chiposition, N) compiles two webs
// given by D1 and D2 as described below, together with a map
// between the two webs that is a tensor product of identity maps
// and one chi-map as the chiposition-th tensor factor. The output
// of mfCompileWeb is a list with four entries: the second entry
// is the component (0 or 1) of the reduced MFs of zero, i.e. 
// rational complexes ofvector spaces, that is non-zero, 
// and the first entry gives the reduced map between these two
// components. (Of course, we can read off from the number of rows
// and columns of this map what the two complexes are.)
// The third and fourth entries are the grading vectors on the
// source and target vector spaces respectively.
// NOTE that we should only call mfCompileWeb in a ring defined by
//     int nx=2; int ny=4; ring rr=0,(x(1..nx),y(1..ny)),dp;.
// For example, we can run 
//     mfCompileWeb(D1, D2, chitype, chiposition, N);
// after having defined:
// intvec edgevec(1) = 1,7,5,8;
// intvec edgevec(2) = 6,8,2,7;
// intvec edgevec(3) = 3,5,4,6;
// intvec edgevec(4) = 4,2,3,1;
// list D1 = list(0,edgevec(1) ), list(0,edgevec(2) ), list(1,edgevec(3) ), list(1,edgevec(4) );
// list D2 = list(0,edgevec(1) ), list(0,edgevec(2) ), list(1,edgevec(3) ), list(0,edgevec(4) );
// N=2
// int chitype = 1;
// int chiposition = 4;
// NOTE that we order the entries of the intvecs e = edgevec(i) such
// that the two outgoing edges at vertex i are labelled by the
// first two entries of edgevec(i), and so that the labels continue
// clockwise (orientations being up the page)
//
//        e[1]    e[2]
//           \   /
//            \/
//            |
//            |
//           /\
//         /   \
//      e[4]    e[3]
//
// SKETCH of how to compile (certain) webs automatically:
//
//  (1) We assume that we are given a KR-type web, i.e. a planar graph with only two
//      kinds of 4-valent vertices, two of whose incident edges are incoming and the other 
//      two are outgoing, and there are no external edges. 
//  (2) We further assume that the vertices can be assigned distinct labels 1,...,v where
//      v=(total number of vertices) such that vertices 1 and 2 are joined by precisely two
//      edges, that the fusion of vertices 1 and 2 is joined with vertex 3 by precisely two
//      edges etc.; only the fusion of the first v-1 vertices is joined by precisely four
//      edges with the final vertex v.
//      NOTE: We make no assumption that the two edges between 1 and 2 are both oriented
//      from 1 to 2 (in fact the orientations on the two edges could be opposite).
//  (3) Hence we can represent such a web by the following data D: D is a list of v elements,
//      each of which is again a list of two elements: D[i] = list(vertextype(i),edgevec(i)) for
//      i=1,...,v where vertextype(i) is a string that indicates whether the vertex is the tensor
//      product of two identity defects (label A) or a wide edge defect (label B), and edgevec(i)
//      is an intvec of length 4 such that its first two entries label the outgoing edges and 
//      its last two entries label the incoming edges of the i-th vertex. (There are 2*v edges,
//      and the D uniquely determines the kind of web that we consider.)
//  (4) The only morphisms of webs with v vertices that we will encounter are tensor products 
//      of v-1 identity maps and either one chi0 or one chi1. Thus to specify a morphism of webs
//      we only have to indicate at which position i chi0 oder chi1 sits. Its variable dependence
//      will be given by edgevec(i) and the identifications with x- and y-variables made below.
//  (5) Let us be given two web data D1 and D2 with D1[i] = list(vertextype1(i),edgevec1(i)) and
//      similarly for D2, and let us be given a map alpha between D1 and D2. Our aim is to reduce
//      this (where by reducing we mean both our usual blowing-up and idempotent-splitting).
//      We start by identifying which of the eight entries in edgevec1(1) and edgevec1(2) 
//      occur twice and call them int(1) and int(2). The remaining four entries we call 
//      ext(1),...,ext(4). The ordering is not important. Then we make the idenfication:
//          x(i) corresponds to int(i) for i=1,2,
//          y(i) corresponds to ext(i) for i=1,2,3,4.
//  (6) Using this and the data D1, D2, alpha, we compute the fusions of the first two vertices
//      in both webs as well as the morphism between these two fused subwebs in the usual way 
//      (see linkhom-example-figure-eight-knot).
//  (7) Identify which two numbers in edgevec1(3) are not in {ext(i)}_{i=1,...,4} and call them
//      n(1) and n(2). Furthermore, determine which of the numbers in {ext(i)}_{i=1,...,4} also
//      appear in edgevec1(3). Let us say these are ext(i1) and ext(i2). Now we make new
//      identifications as follows:
//          x(1) cooresponds to ext(i1),
//          x(2) cooresponds to ext(i2),
//          y(k) corresponds to ext(k) for k in {1,2,3,4}\{i1,i2},
//          y(i1) cooresponds to n(1),
//          x(i2) cooresponds to n(2).
//  (8) Redefine everything that was produced in step (6):
//      bla = subst( bla, y(i1), x(1) ); bla = subst( bla, y(i2), x(2) );.
//  (9) Now compute the next fusion as usual, i.e. repeat the obvious adaptation of steps
//      (7) to (9) until the first v-1 vertices are fused.
// (10) Rename y(1),...,y(4) into x(1),...x(4), write the last vertex in the correct
//      x-variables (as encoded in edgevec1(v) and the most recent identifications of variables
//      and edge labels), and do the last fusion as usual. 
////////////////////////////////////////////////////////////////////

// TODO: Will mfCompileWeb work when there are only two vertices in the web?
// TODO: possible signs due to the ordering of internal variables?
proc mfCompileWeb(list D1, D2, int chitype, int chiposition, int N)
{
    def RRR = basering;
    int websize = size(D1);
    int i,j,k,i1,i2,i3,i4;
    
    // Sanity checks
    if( websize != size(D2) )
    {
        print("[mfCompileWeb] Passed webs of different sizes, exiting.");
        return();
    }
    if( chitype != 0 && chitype != 1 || chiposition > websize )
    {
        print("[mfCompileWeb] chitype not in {0,1} or chiposition > web size, exiting.");
        return();
    }
    
    // Define the morphisms between the unreduced tensor factors to be
    // identity maps (only later redefine the chipositions-th alpha to
    // be the appropriate chi map):
    
    for( i=1; i<=websize; i++ )
    {
        matrix alpha(i) = unitmat(4);
    }
    
    // Fusion of the first two vertices.
    // Find out which are the two internal variables inter(1) and inter(2)
    // between vertices 1 and 2:
    
    list L1,L2;
    for( i=1; i<=4; i++ )
    {
        L1[i] = edgevec(1)[i];
        L2[i] = edgevec(2)[i];
    }
    
    int z = 1;
    for( i1=1; i1<=4; i1++ )
    {
        for( i2=1; i2<=4; i2++ )
        {
            if( L1[i1] == L2[i2] )
            {
                int inter(z) = L1[i1];
                z = z + 1;
            }
        }
    }
    // Note that inter(1),inter(2) occur in the same order which these edges
    // appear in edgevec(1).
    
    // Call the remaining labels of edges incident on either of the two
    // vertices ext(1),...,ext(4). The order is to enumerate the external
    // edges in edgevec(1) and then those in edgevec(2).
    
    L1 = removefromlist(removefromlist( L1, inter(1) ), inter(2) );
    L2 = removefromlist(removefromlist( L2, inter(1) ), inter(2) );     
    for( i=1; i<=2; i++ )
    {
        int ext(i) = L1[i];
        int ext(i+2) = L2[i];
    }
    
    // At this stage, the variable listOfCVariableNames[i] corresponds to 
    // the edge label listOfEdgeLabels[i] for i=1,...,6:
    
    list listOfCVariableNames = x(1),x(2),y(1),y(2),y(3),y(4);
    list listOfEdgeLabels = inter(1),inter(2),ext(1),ext(2),ext(3),ext(4);
    
    // Find the variable dependence of the first two vertices:
    list varis(1), varis(2);
    for( i1=1; i1<=4; i1++ )
    {
        for( i2=1; i2<=6; i2++ )
        {
            if( D1[1][2][i1] == listOfEdgeLabels[i2] )
            {
                varis(1)[i1] = listOfCVariableNames[i2];
            }
            if( D1[2][2][i1] == listOfEdgeLabels[i2] )
            {
                varis(2)[i1] = listOfCVariableNames[i2];
            }

        }
    }
    
    // V1(i) is the MF associated to the i-th vertex in web 1, 
    // V2(i) is the MF associated to the i-th vertex in web 2: 
    matrix V1(1) = mfVertex( D1[1][1], varis(1), N ); 
    matrix V1(2) = mfVertex( D1[2][1], varis(2), N );
    matrix V2(1) = mfVertex( D2[1][1], varis(1), N );
    matrix V2(2) = mfVertex( D2[2][1], varis(2), N );
    
    intvec V1gr(1) = mfVertexGrading( D1[1][1], varis(1), N );
    intvec V1gr(2) = mfVertexGrading( D1[2][1], varis(2), N );
    intvec V2gr(1) = mfVertexGrading( D2[1][1], varis(1), N );
    intvec V2gr(2) = mfVertexGrading( D2[2][1], varis(2), N );
    
    // Now start to reduce V1(1) x V1(2), V2(1) x V2(2) and the map between them:
        
    ideal J = x(1)^N, x(2)^N;
    intvec q = N, N;
    number Nn = N + 1;
    matrix C[2][2] = 1/Nn, 0, 0, 1/Nn;

    // The matrix webmap will eventually be the reduced map between the two
    // webs. At the moment, it is simply the map V1(1) x V1(2) --> V2(1) x V2(2):
    
    for( i=1; i<=2; i++ )
    {
        if( i == chiposition )
        {
            alpha(i) = mfChi(chitype, varis(i)[1], varis(i)[2], varis(i)[3], varis(i)[4], N);
            break;
        }
    }
    
    // Compute the ordinary tensor product:
    matrix T1 = MFtensor( V1(1), V1(2) );
    matrix T1blow = mablow(T1,J);
    matrix T2 = MFtensor( V2(1), V2(2) );
    matrix T2blow = mablow(T2,J);
    
    intvec T1gr = MFtensorGradings( V1gr(1), V1gr(2) );
    intvec T1blowgr = mablowGrading( T1gr, J );
    intvec T2gr = MFtensorGradings( V2gr(1), V2gr(2) );
    intvec T2blowgr = mablowGrading(T2gr,J);

    // Inflate the induced morphism between the webs
    matrix webmap = mablow( ZZtensor( alpha(1), alpha(2) ), J );
    
    // Reduce this inflated differential:
    list l1 = mfReduce(T1blow,1);
    matrix RT1 = l1[1];
    matrix F1(1) = l1[2]; // A homotopy equivalence T1blow -> RT1
    matrix G1(1) = l1[3]; // A homotopy equivalence RT1 -> T1blow
    list l2 = mfReduce(T2blow,1);
    matrix RT2 = l2[1];
    matrix F2(1) = l2[2]; // A homotopy equivalence T2blow -> RT2
    matrix G2(1) = l2[3]; // A homotopy equivalence RT2 -> T2blow
    
    intvec RT1gr = computeGradingFromInjection(G1(1),T1blowgr);
    intvec RT2gr = computeGradingFromInjection(G2(1),T2blowgr);
    
    // Define d1(1) to be the product over all outgoing edges labelled by x-variables
    // of the derivatives of V1(1) with respect to these variables, and
    // define d1(2) to be the product over all outgoing edges labelled by x-variables
    // of the derivatives of V1(2) with respect to these variables, and
    // similarly for d2(1) and d2(2):
    
    matrix d1(1) = unitmat( ncols( V1(1) ) );
    matrix d1(2) = unitmat( ncols( V1(2) ) );
    matrix d2(1) = unitmat( ncols( V2(1) ) );
    matrix d2(2) = unitmat( ncols( V2(2) ) );
    for( i=1; i<=2; i++ )
    {
        // vertex V1(1):
        if( x(1) == varis(1)[i] )
        {
            d1(1) = d1(1) * diff( V1(1), x(1) );
            d2(1) = d2(1) * diff( V2(1), x(1) );
        }
        
        if( x(2) == varis(1)[i] )
        {
            d1(1) = d1(1) * diff( V1(1), x(2) );
            d2(1) = d2(1) * diff( V2(1), x(2) );
        }
        
        // vertex V1(2):
        if( x(1) == varis(2)[i] )
        {
            d1(2) = d1(2) * diff( V1(2), x(1) );
            d2(2) = d2(2) * diff( V2(2), x(1) );
        }
        
        if( x(2) == varis(2)[i] )
        {
            d1(2) = d1(2) * diff( V1(2), x(2) );
            d2(2) = d2(2) * diff( V2(2), x(2) );
        }
    }
    // TODO: possible signs?
    
    matrix diff1(1) = ZZtensor( d1(1), unitmat( ncols( V1(2) ) ) );
    matrix diff1(2) = ZZtensor( unitmat( ncols( V1(1) ) ), d1(2) );
    matrix iddQ1 = mablow( det(C) * diff1(1) * diff1(2), J );
    matrix diff2(1) = ZZtensor( d2(1), unitmat( ncols( V2(2) ) ) );
    matrix diff2(2) = ZZtensor( unitmat( ncols( V2(1) ) ), d2(2) );
    matrix iddQ2 = mablow( det(C) * diff2(1) * diff2(2), J );

    matrix delta1(1) = mablow_delta(T1, 1, N, J);
    matrix delta1(2) = mablow_delta(T1, 2, N, J);
    matrix delQ1 = delta1(1) * delta1(2);
    matrix delta2(1) = mablow_delta(T2, 1, N, J);
    matrix delta2(2) = mablow_delta(T2, 2, N, J);
    matrix delQ2 = delta2(1) * delta2(2);
    
    // And finally the idempotents e1,e2 on T1blow,T2blow
    int sign = (nx * (nx-1)) div 2;
    matrix e1 = (-1)^(sign) * iddQ1 * delQ1;
    matrix e2 = (-1)^(sign) * iddQ2 * delQ2;

    matrix ep1 = F1(1) * e1 * G1(1);
    matrix ep2 = F2(1) * e2 * G2(1);
    
    // Sanity checks:
    if( ep1 * RT1 != RT1 * ep1 )
    {
        print("[mfCompileWeb] The reduced idempotent (up to homotopy) ep1 is not an endomorphism of RT1, exiting.");
        return();
    }
    if( ep2 * RT2 != RT2 * ep2 )
    {
        print("[mfCompileWeb] The reduced idempotent (up to homotopy) ep2 is not an endomorphism of RT2, exiting.");
        return();
    }
    
    // Strictify these idempotents:
    matrix epstrict1 = mfStrictifyIdempotent(RT1, ep1);
    matrix epstrict2 = mfStrictifyIdempotent(RT2, ep2);
    
    // Sanity checks:
    if( epstrict1 * RT1 != RT1 * epstrict1 || epstrict1 * epstrict1 != epstrict1 )
    {
        print("[mfCompileWeb] The strictified idempotent epstrict1 is not an endomorphism of RT1, or not an idempotent on the nose, exiting.");
        return();
    }
    if( epstrict2 * RT2 != RT2 * epstrict2 || epstrict2 * epstrict2 != epstrict2 )
    {
        print("[mfCompileWeb] The strictified idempotent epstrict2 is not an endomorphism of RT2, or not an idempotent on the nose, exiting.");
        return();
    }

    list l1 = mfSplitIdempotent(RT1, epstrict1, RT1gr);
    list l2 = mfSplitIdempotent(RT2, epstrict2, RT2gr);

    matrix final1 = mfSuspend( l1[1], nx );
    matrix final2 = mfSuspend( l2[1], nx );
    
    intvec final1gr = mfSuspendGrading( l1[4], nx );
    intvec final2gr = mfSuspendGrading( l2[4], nx );
    
    // Grading sanity check
    if( isGradingValid(final1, final1gr) != 1 || isGradingValid(final2,final2gr) != 1 )
    {
        print("[mfCompileWeb] Something has gone wrong with the grading, exiting.");
        return();
    }
    
    // Determine the outgoing and incoming labels of final1 and final2
    // (in terms of the integer labels in {1,...,2*websize}). 
    // As final1 and final2 both depend only on y(1),...,y(4), their incident
    // edges are labelled by ext(1),...,ext(4). We need to determine i1,i2 such
    // that the vertices labelled by ext(i1) and ext(i2) are outgoing. 
    // Then we define a list finalvaris whose first two entries are ext(i1),ext(i2),
    // and whose third and fourth entry is given by the remaining two labellings.
    list templist;
    for( i=1; i<=4; i++ )
    {
        for( i1=1; i1<=2; i1++ )
        {
            for( i2=1; i2<=2; i2++ )
            {
                if( ext(i) == D1[1][2][i1] || ext(i) == D1[2][2][i2] )
                {
                    templist = templist + list(i);
                    i = i + 1;
                }
            }
        }
    }    
    for( i=1; i<=4; i++ )
    {
        if( i != templist[1] && i != templist[2] )
        {
            templist = templist + list(i);
        }
    }
    list finalvaris;
    for( i=1; i<=4; i++ )
    {
        finalvaris[i] = ext(templist[i]);
    }
    
    // Compute the transformation matrices:
    matrix s1(1) = mfSuspendMorph( l1[2], nx );    // final1 --> RT1
    matrix t1(1) = mfSuspendMorph( l1[3], nx );    // RT1 --> final1
    matrix s2(1) = mfSuspendMorph( l2[2], nx );    // final2 --> RT2
    matrix t2(1) = mfSuspendMorph( l2[3], nx );    // RT2 --> final2
    
    // Compute the induced map between the reductions
    webmap = t2(1) * F2(1) * webmap * G1(1) * s1(1);
    
    // Sanity check (DEBUG, can be removed)
    if( final2 * webmap != webmap * final1 )
    {
        print("[mfCompileWeb] webmap is not a morphism, exiting.");
        return();
    }
    
    // Now repeat the above steps analogously and iteratively until all vertices but
    // the last one in the webs are fused:
    dbprint(printlevel, "[mfCompileWeb] Beginning induction step.");
    
    for( k=3; k<=websize-1; k++ )
    {
        // NOTE: the ext(i) will not necessarily be ordered "clockwise" with respect
        // to the underlying directed graph of the current web.
        // Identify which two numbers in D1[k][2] are not in {ext(i)}_{i=1,...,4}
        // and call them newlabel(1) and newlabel(2):
        int count = 1;
        for( i1=1; i1<=4; i1++ )
        {
            int z;
            for( i2=1; i2<=4; i2++ )
            {
                if( D1[k][2][i1] != ext(i2) )
                {
                    z = z + 1;
                }
            }
            if( z == 4 )
            {
                int newlabel(count) = D1[k][2][i1];
                count = count + 1;
            }
        }
        
        // Determine which of the numbers in {ext(i)}_{i=1,...,4} also appear 
        // in D1[k][2], and let us define i1,i2 such that these are ext(i1) and ext(i2).
        // These keep the ordering given in D1[k][2].
        list extlabel;
        for( i1=1; i1<=4; i1++ )
        {
            for( i2=1; i2<=4; i2++ )
            {
                if( D1[k][2][i1] == ext(i2) )
                {
                    extlabel = extlabel + list(i2);
                    break;
                }
            }
        }
        int i1 = extlabel[1]; // TODO: mondo confusing notation
        int i2 = extlabel[2];

        // At this stage, the variable listOfCVariableNames[i] corresponds to 
        // the edge label listOfEdgeLabels[i] for i=1,...,6:
        //          x(1) cooresponds to ext(i1),
        //          x(2) cooresponds to ext(i2),
        //          y(k) corresponds to ext(k) for k in {1,2,3,4}\{i1,i2},
        //          y(i1) cooresponds to n(1),
        //          y(i2) cooresponds to n(2).
        int assotox1,assotox2 = ext(i1),ext(i2);
        list newexternals; int count = 1;
        for( i=1; i<=4; i++ )
        {
            if( i != i1 && i != i2 )
            {
                newexternals[i] = ext(i);
            }
            else
            {
                newexternals[i] = newlabel(count);
                count = count + 1;
            }
        }
        for( i=1; i<=4; i++ )
        {
            ext(i) = newexternals[i];
        }
        list listOfCVariableNames = x(1),x(2),y(1),y(2),y(3),y(4);
        list listOfEdgeLabels = assotox1,assotox2,ext(1),ext(2),ext(3),ext(4);
    
        // Find the variable dependence of the "blob" MF which is the fusion of the
        // first k-1 vertices and the k-th MF:    
        list blobvaris, varis(k);
        for( i3=1; i3<=4; i3++ )
        {
            for( i4=1; i4<=6; i4++ )
            {
                if( finalvaris[i3] == listOfEdgeLabels[i4] )
                {
                    blobvaris[i3] = listOfCVariableNames[i4];
                }
                if( D1[k][2][i3] == listOfEdgeLabels[i4] )
                {
                    varis(k)[i3] = listOfCVariableNames[i4];
                }
            }
        }
        
        // Redefine the results of step k-1 according to the new identifications:
        final1 = subst( final1, y(i1), x(1) ); final1 = subst( final1, y(i2), x(2) );
        final2 = subst( final2, y(i1), x(1) ); final2 = subst( final2, y(i2), x(2) );
        webmap = subst( webmap, y(i1), x(1) ); webmap = subst( webmap, y(i2), x(2) );
        s1(k-2) = subst( s1(k-2), y(i1), x(1) ); s1(k-2) = subst( s1(k-2), y(i2), x(2) );
        t1(k-2) = subst( t1(k-2), y(i1), x(1) ); t1(k-2) = subst( t1(k-2), y(i2), x(2) );
        s2(k-2) = subst( s2(k-2), y(i1), x(1) ); s2(k-2) = subst( s2(k-2), y(i2), x(2) );
        t2(k-2) = subst( t2(k-2), y(i1), x(1) ); t2(k-2) = subst( t2(k-2), y(i2), x(2) );
        G1(k-2) = subst( G1(k-2), y(i1), x(1) ); G1(k-2) = subst( G1(k-2), y(i2), x(2) );
        F2(k-2) = subst( F2(k-2), y(i1), x(1) ); F2(k-2) = subst( F2(k-2), y(i2), x(2) );
        
        // V1(k) is the MF associated to the k-th vertex in web 1, 
        // V2(k) is the MF associated to the k-th vertex in web 2: 
        matrix V1(k) = mfVertex( D1[k][1], varis(k), N );
        matrix V2(k) = mfVertex( D2[k][1], varis(k), N );
    
        intvec V1gr(k) = mfVertexGrading( D1[k][1], varis(k), N );
        intvec V2gr(k) = mfVertexGrading( D2[k][1], varis(k), N );
        
        // Now start to reduce final1 x V1(k), final2 x V2(k) and the map between them:
        
        ideal J = x(1)^N, x(2)^N;
        intvec q = N, N;
        number Nn = N + 1;
        matrix C[2][2] = 1/Nn, 0, 0, 1/Nn;
        
        if( k == chiposition )
        {
            alpha(k) = mfChi(chitype, varis(k)[1], varis(k)[2], varis(k)[3], varis(k)[4], N);
        }
        
        // Compute the ordinary tensor product:
        matrix T1 = MFtensor( final1, V1(k) );
        matrix T1blow = mablow(T1,J);
        matrix T2 = MFtensor( final2, V2(k) );
        matrix T2blow = mablow(T2,J);

        intvec T1gr = MFtensorGradings( final1gr, V1gr(k) );
        intvec T1blowgr = mablowGrading(T1gr,J);
        intvec T2gr = MFtensorGradings( final2gr, V2gr(k) );
        intvec T2blowgr = mablowGrading(T2gr,J);

        // blown-up version of the map between the first k vertices:
        webmap = mablow( ZZtensor( webmap, alpha(k) ), J );
        
        // Reduce this inflated differential:
        list l1 = mfReduce(T1blow,1);
        matrix RT1 = l1[1];
        matrix F1(k-1) = l1[2]; // A homotopy equivalence T1blow -> RT1
        matrix G1(k-1) = l1[3]; // A homotopy equivalence RT1 -> T1blow
        list l2 = mfReduce(T2blow,1);
        matrix RT2 = l2[1];
        matrix F2(k-1) = l2[2]; // A homotopy equivalence T2blow -> RT2
        matrix G2(k-1) = l2[3]; // A homotopy equivalence RT2 -> T2blow
    
        intvec RT1gr = computeGradingFromInjection(G1(k-1),T1blowgr);
        intvec RT2gr = computeGradingFromInjection(G2(k-1),T2blowgr);
    
        // Define d1(1) to be the product over all outgoing edges labelled by x-variables
        // of the derivatives of final1 with respect to these variables, and
        // define d1(k) to be the product over all outgoing edges labelled by x-variables
        // of the derivatives of V1(k) with respect to these variables, and
        // similarly for d2(1) and d2(2):
        matrix d1(1) = unitmat( ncols( final1 ) );
        matrix d1(k) = unitmat( ncols( V1(k) ) );
        matrix d2(1) = unitmat( ncols( final2 ) );
        matrix d2(k) = unitmat( ncols( V2(k) ) );
        for( i=1; i<=2; i++ )
        {
            // vertex final1:
            if( x(1) == blobvaris[i] )
            {
                d1(1) = d1(1) * diff( final1, x(1) );
                d2(1) = d2(1) * diff( final2, x(1) );
            }
        
            if( x(2) == blobvaris[i] )
            {
                d1(1) = d1(1) * diff( final1, x(2) );
                d2(1) = d2(1) * diff( final2, x(2) );
            }
        
            // vertex V1(2):
            if( x(1) == varis(k)[i] )
            {
                d1(k) = d1(k) * diff( V1(k), x(1) );
                d2(k) = d2(k) * diff( V2(k), x(1) );
            }
        
            if( x(2) == varis(k)[i] )
            {
                d1(k) = d1(k) * diff( V1(k), x(2) );
                d2(k) = d2(k) * diff( V2(k), x(2) );
            }
        }
        
        matrix diff1(1) = ZZtensor( d1(1), unitmat( ncols( V1(k) ) ) );
        matrix diff1(2) = ZZtensor( unitmat( ncols( final1 ) ), d1(k) );
        matrix iddQ1 = mablow( det(C) * diff1(1) * diff1(2), J );
        matrix diff2(1) = ZZtensor( d2(1), unitmat( ncols( V2(k) ) ) );
        matrix diff2(2) = ZZtensor( unitmat( ncols( final2 ) ), d2(k) );
        matrix iddQ2 = mablow( det(C) * diff2(1) * diff2(2), J );

        matrix delta1(1) = mablow_delta(T1, 1, N, J);
        matrix delta1(2) = mablow_delta(T1, 2, N, J);
        matrix delQ1 = delta1(1) * delta1(2);
        matrix delta2(1) = mablow_delta(T2, 1, N, J);
        matrix delta2(2) = mablow_delta(T2, 2, N, J);
        matrix delQ2 = delta2(1) * delta2(2);
    
        // And finally the idempotents e1,e2 on T1blow,T2blow:
        int sign = (nx * (nx-1)) div 2;
        matrix e1 = (-1)^k * (-1)^(sign) * iddQ1 * delQ1;   // TODO: is the factor (-1)^k correct?
        matrix e2 = (-1)^k * (-1)^(sign) * iddQ2 * delQ2;   // TODO: is the factor (-1)^k correct?
    
        matrix ep1 = F1(k-1) * e1 * G1(k-1);
        matrix ep2 = F2(k-1) * e2 * G2(k-1);
        
        // Sanity checks:
        if( ep1 * RT1 != RT1 * ep1 )
        {
            print("[mfCompileWeb] The reduced idempotent (up to homotopy) ep1 at level "+string(k)+" is not an endomorphism of RT1, exiting.");
            return();
        }
        if( ep2 * RT2 != RT2 * ep2 )
        {
            print("[mfCompileWeb] The reduced idempotent (up to homotopy) ep2 at level "+string(k)+" is not an endomorphism of RT2, exiting.");
            return();
        }
    
        // Strictify these idempotents:
        matrix epstrict1 = mfStrictifyIdempotent(RT1, ep1);
        matrix epstrict2 = mfStrictifyIdempotent(RT2, ep2);
    
      // Sanity checks:
        if( epstrict1 * RT1 != RT1 * epstrict1 || epstrict1 * epstrict1 != epstrict1 )
        {
            print("[mfCompileWeb] The strictified idempotent epstrict1 at level "+string(k)+" is not an endomorphism of RT1, or not an idempotent on the nose, exiting.");
            return();
        }
        if( epstrict2 * RT2 != RT2 * epstrict2 || epstrict2 * epstrict2 != epstrict2 )
        {
            print("[mfCompileWeb] The strictified idempotent epstrict2 at level "+string(k)+" is not an endomorphism of RT2, or not an idempotent on the nose, exiting.");
            return();
        }

        list l1 = mfSplitIdempotent(RT1, epstrict1, RT1gr);   // TODO: swap 1 with intvec here...
        list l2 = mfSplitIdempotent(RT2, epstrict2, RT2gr);   // TODO: swap 1 with intvec here...

        final1 = mfSuspend( l1[1], nx );
        final2 = mfSuspend( l2[1], nx );
    
        final1gr = mfSuspendGrading( l1[4], nx );
        final2gr = mfSuspendGrading( l2[4], nx );
        
        // Grading sanity check
        if( isGradingValid(final1, final1gr) != 1 || isGradingValid(final2,final2gr) != 1 )
        {
            print("[mfCompileWeb] Something has gone wrong with the grading in induction, exiting.");
            return();
        }
        
        // Determine the outgoing and incoming labels of final1 and final2
        // (in terms of the integer labels in {1,...,2*websize}). 
        // As final1 and final2 both depend only on y(1),...,y(4), their incident
        // edges are labelled by ext(1),...,ext(4). We need to determine i1,i2 such
        // that the vertices labelled by ext(i1) and ext(i2) are incoming. 
        // Then we define a list finalvaris whose first two entries are ext(i1),ext(i2),
        // and whose third and fourth entry is given by the remaning two labellings.
        list templist;
        for( i=1; i<=4; i++ )
        {
            for( i1=1; i1<=2; i1++ )
            {
                for( i2=1; i2<=2; i2++ )
                {
                    if( ext(i) == finalvaris[i1] || ext(i) == D1[k][2][i2] )
                    {
                        templist = templist + list(i);
                        i = i + 1;
                    }
                }
            }
        }    
        for( i=1; i<=4; i++ )
        {
            if( i != templist[1] && i != templist[2] )
            {
                templist = templist + list(i);
            }
        }
        list finalvaris;
        for( i=1; i<=4; i++ )
        {
            finalvaris[i] = ext(templist[i]);
        }
    
        // Compute the transformation matrices:

        matrix s1(k-1) = mfSuspendMorph( l1[2], nx );    // final1 --> RT1
        matrix t1(k-1) = mfSuspendMorph( l1[3], nx );    // RT1 --> final1
        matrix s2(k-1) = mfSuspendMorph( l2[2], nx );    // final2 --> RT2
        matrix t2(k-1) = mfSuspendMorph( l2[3], nx );    // RT2 --> final2

        // Compute the induced map between the reductions
        webmap = t2(k-1) * F2(k-1) * webmap * G1(k-1) * s1(k-1);
    
        // Sanity check (DEBUG, can be removed)
        if( final2 * webmap != webmap * final1 )
        {
            print("[mfCompileWeb] inductive webmap is not a morphism, exiting.");
            return();
        }
    }//end of k-loop
    
    // Now do the final fusion of the first websize-1 vertices with the last one.
    dbprint(printlevel, "[mfCompileWeb] Performing final fusion.");
    
    // Rename y(i) to x(i) for all i=1,...,4:
    int k = websize;
    int i;
    def lastvertex = D1[websize][2];
    int nx=4;
    int ny=4;
    ring rr2=0,(x(1..nx),y(1..ny)),dp;
//    def lastvertex = imap(RRR,lastvertex);
    //print(lastvertex);
    matrix final1 = imap(RRR,final1);
    matrix final2 = imap(RRR,final2);
    matrix s1(k-2) = imap(RRR,s1(k-2));
    matrix t1(k-2) = imap(RRR,t1(k-2));
    matrix s2(k-2) = imap(RRR,s2(k-2));
    matrix t2(k-2) = imap(RRR,t2(k-2));
    matrix G1(k-2) = imap(RRR,G2(k-2));
    matrix F2(k-2) = imap(RRR,F2(k-2));
    matrix webmap = imap(RRR,webmap);
    for( i=1; i<=4; i++ )
    {
        final1 = subst(final1,y(i),x(i));
        final2 = subst(final2,y(i),x(i));    
        s1(k-2) = subst(s1(k-2),y(i),x(i));
        t1(k-2) = subst(t1(k-2),y(i),x(i));
        s2(k-2) = subst(s2(k-2),y(i),x(i));
        t2(k-2) = subst(t2(k-2),y(i),x(i));
        G1(k-2) = subst(G1(k-2),y(i),x(i));
        F2(k-2) = subst(F2(k-2),y(i),x(i));
        webmap = subst(webmap,y(i),x(i));
    }
    int nx=4;
    ring rr3=0,(x(1..nx)),dp;
    int i,j,i1,i2,i3,i4;
//    def lastvertex = imap(rr2,lastvertex);
    matrix final1 = imap(rr2,final1);
    matrix final2 = imap(rr2,final2);
    matrix s1(k-2) = imap(rr2,s1(k-2));
    matrix t1(k-2) = imap(rr2,t1(k-2));
    matrix s2(k-2) = imap(rr2,s2(k-2));
    matrix t2(k-2) = imap(rr2,t2(k-2));
    matrix G1(k-2) = imap(rr2,G1(k-2));
    matrix F2(k-2) = imap(rr2,F2(k-2));
    matrix webmap = imap(rr2,webmap);

    list listOfCVariableNames = x(1),x(2),x(3),x(4);
    list listOfEdgeLabels = ext(1),ext(2),ext(3),ext(4);
    
    // Find the variable dependence of the "blob" MF which is the fusion of the
    // first k-1 vertices and the k-th MF:    
    list blobvaris, varis(k);
    for( i3=1; i3<=4; i3++ )
    {
        for( i4=1; i4<=4; i4++ )
        {
            if( finalvaris[i3] == listOfEdgeLabels[i4] )
            {
                blobvaris[i3] = listOfCVariableNames[i4];
            }
            if( lastvertex[i3] == listOfEdgeLabels[i4] )
            {
                varis(k)[i3] = listOfCVariableNames[i4];
            }
        }
    }
    
    // V1(k) is the MF associated to the k-th vertex in web 1, 
    // V2(k) is the MF associated to the k-th vertex in web 2: 
    matrix V1(k) = mfVertex( D1[k][1], varis(k), N );
    matrix V2(k) = mfVertex( D2[k][1], varis(k), N );

    intvec V1gr(k) = mfVertexGrading( D1[k][1], varis(k), N );
    intvec V2gr(k) = mfVertexGrading( D2[k][1], varis(k), N );
    
    // Now start to reduce final1 x V1(k), final2 x V2(k) and the map between them:

    ideal J = x(1)^N, x(2)^N, x(3)^N, x(4)^N;
    intvec q = N, N, N, N;
    number Nn = N + 1;
    matrix C[4][4] = 1/Nn * unitmat(4);
    
    matrix alpha(k) = unitmat(4); // TODO: this has any point? We define alpha(k) at the beginning.
                                  // Yes, but it was only defined in the ring RRR.
    if( k == chiposition )
    {
        matrix alpha(k) = mfChi(chitype, varis(k)[1], varis(k)[2], varis(k)[3], varis(k)[4], N);
    }

    // Compute the ordinary tensor product:
    matrix T1 = MFtensor( final1, V1(k) );
    matrix T1blow = mablow(T1,J);
    matrix T2 = MFtensor( final2, V2(k) );
    matrix T2blow = mablow(T2,J);
    
    T1gr = MFtensorGradings( final1gr, V1gr(k) );
    T1blowgr = mablowGrading(T1gr,J);
    T2gr = MFtensorGradings( final2gr, V2gr(k) );
    T2blowgr = mablowGrading(T2gr,J);
    
    // blow up webmap
    webmap = mablow( ZZtensor( webmap, alpha(k) ), J );
        
    // Reduce this inflated differential:
    list l1 = mfReduce(T1blow,1);
    matrix RT1 = l1[1];
    matrix F1(k-1) = l1[2]; // A homotopy equivalence T1blow -> RT1
    matrix G1(k-1) = l1[3]; // A homotopy equivalence RT1 -> T1blow
    list l2 = mfReduce(T2blow,1);
    matrix RT2 = l2[1];
    matrix F2(k-1) = l2[2]; // A homotopy equivalence T2blow -> RT2
    matrix G2(k-1) = l2[3]; // A homotopy equivalence RT2 -> T2blow

    RT1gr = computeGradingFromInjection(G1(k-1),T1blowgr);
    RT2gr = computeGradingFromInjection(G2(k-1),T2blowgr);
    
    webmap = F2(k-1) * webmap * G1(k-1);
    
    // Define d1(1) to be the product over all outgoing edges labelled by x-variables
    // of the derivatives of final1 with respect to these variables, and
    // define d1(k) to be the product over all outgoing edges labelled by x-variables
    // of the derivatives of V1(k) with respect to these variables, and
    // similarly for d2(1) and d2(2):
    matrix d1(1) = unitmat( ncols( final1 ) );
    matrix d1(k) = unitmat( ncols( V1(k) ) );
    matrix d2(1) = unitmat( ncols( final2 ) );
    matrix d2(k) = unitmat( ncols( V2(k) ) );
    for( i=1; i<=2; i++ )
    {
        // vertex final1:
        if( x(1) == blobvaris[i] )
        {
            d1(1) = d1(1) * diff( final1, x(1) );
            d2(1) = d2(1) * diff( final2, x(1) );
        }
        if( x(2) == blobvaris[i] )
        {
            d1(1) = d1(1) * diff( final1, x(2) );
            d2(1) = d2(1) * diff( final2, x(2) );
        }
        if( x(3) == blobvaris[i] )
        {
            d1(1) = d1(1) * diff( final1, x(3) );
            d2(1) = d2(1) * diff( final2, x(3) );
        }
        if( x(4) == blobvaris[i] )
        {
            d1(1) = d1(1) * diff( final1, x(4) );
            d2(1) = d2(1) * diff( final2, x(4) );
        }
            
        // vertex V1(k):
        if( x(1) == varis(k)[i] )
        {
            d1(k) = d1(k) * diff( V1(k), x(1) );
            d2(k) = d2(k) * diff( V2(k), x(1) );
        }        
        if( x(2) == varis(k)[i] )
        {
            d1(k) = d1(k) * diff( V1(k), x(2) );
            d2(k) = d2(k) * diff( V2(k), x(2) );
        }
        if( x(3) == varis(k)[i] )
        {
            d1(k) = d1(k) * diff( V1(k), x(3) );
            d2(k) = d2(k) * diff( V2(k), x(3) );
        }        
        if( x(4) == varis(k)[i] )
        {
            d1(k) = d1(k) * diff( V1(k), x(4) );
            d2(k) = d2(k) * diff( V2(k), x(4) );
        }
    }
        
    matrix diff1(1) = ZZtensor( d1(1), unitmat( ncols( V1(k) ) ) );
    matrix diff1(2) = ZZtensor( unitmat( ncols( final1 ) ), d1(k) );
    matrix iddQ1 = mablow( det(C) * diff1(1) * diff1(2), J );
    matrix diff2(1) = ZZtensor( d2(1), unitmat( ncols( V2(k) ) ) );
    matrix diff2(2) = ZZtensor( unitmat( ncols( final2 ) ), d2(k) );
    matrix iddQ2 = mablow( det(C) * diff2(1) * diff2(2), J );

    matrix delta1(1) = mablow_delta(T1, 1, N, J);
    matrix delta1(2) = mablow_delta(T1, 2, N, J);
    matrix delta1(3) = mablow_delta(T1, 3, N, J);
    matrix delta1(4) = mablow_delta(T1, 4, N, J);
    matrix delQ1 = delta1(1) * delta1(2) * delta1(3) * delta1(4);
    matrix delta2(1) = mablow_delta(T2, 1, N, J);
    matrix delta2(2) = mablow_delta(T2, 2, N, J);
    matrix delta2(3) = mablow_delta(T2, 3, N, J);
    matrix delta2(4) = mablow_delta(T2, 4, N, J);
    matrix delQ2 = delta2(1) * delta2(2) * delta2(3) * delta2(4);
    
    // And finally the idempotents e1,e2 on T1blow,T2blow:
    int sign = (nx * (nx-1)) div 2;
    matrix e1 = (-1)^k * (-1)^(sign) * iddQ1 * delQ1;   // TODO: is the factor (-1)^k correct?
    matrix e2 = (-1)^k * (-1)^(sign) * iddQ2 * delQ2;   // TODO: is the factor (-1)^k correct?
    
    matrix ep1 = F1(k-1) * e1 * G1(k-1);
    matrix ep2 = F2(k-1) * e2 * G2(k-1);
    
    matrix epstrict1 = mfStrictifyIdempotent(RT1, ep1);
    matrix epstrict2 = mfStrictifyIdempotent(RT2, ep2);

    matrix ep0 = extractblockmat(epstrict1)[1];
    matrix ep1 = extractblockmat(epstrict1)[4];
    int rank0 = mat_rk(ep0);
    int rank1 = mat_rk(ep1);
    
    matrix ep0r = extractblockmat(epstrict2)[1];
    matrix ep1r = extractblockmat(epstrict2)[4];
    int rank0r = mat_rk(ep0r);
    int rank1r = mat_rk(ep1r);

    //print("");
    //print("The reduced form of the first web is QQ^"+string(rank0)+" --> QQ^"+string(rank1)+" --> QQ^"+string(rank0)+", where QQ = rationals, and QQ^0=0.");
    //print("");
    //print("The reduced form of the second web is QQ^"+string(rank0r)+" --> QQ^"+string(rank1r)+" --> QQ^"+string(rank0r)+", where QQ = rationals, and QQ^0=0.");
    int z2degree;
    
    intvec splitgr, splitgrr;
    
    // Now compute the non-zero part of the map of the above two complexes:
    if( rank1 != 0 )
    {
        z2degree = 1;
        matrix eq0f = ep1;
        matrix eq0fr = ep1r;

        // Now split the idempotent eq0f by hand:
        LIB "control.lib";
        module ker0 = rightKernel(unitmat(ncols(eq0f)) - eq0f);
        matrix f0 = ker0;
        matrix g0[ncols(f0)][nrows(f0)]; // Defaults to zero
    
        if( ker0[1] != [0] )
        {
            matrix g0 = leftInverse(f0) * eq0f; // Solves f0 * g0 = eq0f.
        };
        
        // The grading on the odd part of RT1 is given by
        intvec RT1gr1 = RT1gr[(size(RT1gr)/2+1)..size(RT1gr)];
        splitgr = computeGradingFromInjection(f0, RT1gr1);

        // Now split the idempotent eq0fr by hand:
        module ker0r = rightKernel(unitmat(ncols(eq0fr)) - eq0fr);
        matrix f0r = ker0r;
        matrix g0r[ncols(f0r)][nrows(f0r)];
    
        if( ker0r[1] != [0] )
        {
            matrix g0r = leftInverse(f0r) * eq0fr;
        };

        // The grading on the odd part of RT2 is given by
        intvec RT2gr1 = RT2gr[(size(RT2gr)/2+1)..size(RT2gr)];
        splitgrr = computeGradingFromInjection(f0r,RT2gr1);
        
        // Finally, to get the (non-zero part of the) map from web1 to web2:

        webmap = g0r * extractblockmat(webmap)[4] * f0;
    }
    if( rank0 != 0 )
    {
        z2degree = 0;
        matrix eq0f = ep0;
        matrix eq0fr = ep0r;

        // Now split the idempotent eq0f by hand:
        LIB "control.lib";
        module ker0 = rightKernel(unitmat(ncols(eq0f)) - eq0f);
        matrix f0 = ker0;
        matrix g0[ncols(f0)][nrows(f0)]; // Defaults to zero
    
        if( ker0[1] != [0] )
        {
            matrix g0 = leftInverse(f0) * eq0f; // Solves f0 * g0 = eq0f.
        };
        
        // The grading on the even part of RT1 is given by
        intvec RT1gr0 = RT1gr[1..(size(RT1gr)/2)];
        splitgr = computeGradingFromInjection(f0, RT1gr0);

        // Now split the idempotent eq0fr by hand:
        module ker0r = rightKernel(unitmat(ncols(eq0fr)) - eq0fr);
        matrix f0r = ker0r;
        matrix g0r[ncols(f0r)][nrows(f0r)];
    
        if( ker0r[1] != [0] )
        {
            matrix g0r = leftInverse(f0r) * eq0fr;
        };

        // The grading on the even part of RT2 is given by
        intvec RT2gr0 = RT2gr[1..(size(RT2gr)/2)];
        splitgrr = computeGradingFromInjection(f0r, RT2gr0);

        // Finally, to get the (non-zero part of the) map from web1 to web2:

        webmap = g0r * extractblockmat(webmap)[1] * f0;
    }
    
    // The reduced MFs of zero are concentrated in Z2-degree z2degree, 
    // and webmap is the non-zero map between them:

    setring RRR;
    matrix webmap = imap(rr3,webmap);
    
    list finaloutput = webmap, z2degree, splitgr, splitgrr;
    return(finaloutput);
}

/////////////////////////////////////////
// powervec
//
// Given an integer m returns a list of all intvecs of length m with entries 0,1.

proc powervec(int m)
{
    if( m == 1 )
    {
        intvec a = 0;
        intvec b = 1;
        list r = a,b;
        kill a,b;
        return(r);
    }
    
    list l = powervec(m-1);
    list r;
    
    int i;
    for(i=1;i<=size(l);i++)
    {
       // Prepend either 0 or 1 to each entry of l
        intvec v = l[i];
        intvec a = 0,v;
        intvec b = 1,v;
        r = r + list(a,b);
        kill v,a,b;
    }
    
    kill l;
    return(r):
}

/////////////////////////////////////////
// intvecToString
/////////////////////////////////////////

proc intvecToString(intvec v)
{
    string s;
    int i;
    for( i = 1; i <= size(v); i++ )
    {
        s = s + string(v[i]);
    }
    
    return(s);
}

/////////////////////////////////////////
// Link datatype
//
// Suppose we are given a link with m crossings, on which we fix a particular ordering.
// We represent this as a list (X,Y) consisting of an intvec X and a list Y, such that
//
// - X is an intvec of size m with X[i] = 1 if the i-th crossing of the link is positive
// and X[i] = -1 if the crossing is negative.
// - each entry of Y is an intvec of size 4, and together the entries of Y give a
// partition of the set 1,2,...,4*m where Y[i] labels the edges incident at the i-th crossing
// of the link, oriented in the usual clockwise fashion.

////////////////////////////////////////////////////////////////////
// mfCompileLink
//
// Takes as arguments a link, defined as a pair in the sense explained above, the name
// of a file to use for storing intermediate results, and a flag useSaveFile specifying
// whether or not to make use of this datafile. The return is a list of tuples
//
//      T = (intvec state1,intvec state2,int chitype,int chiposition,data).
//
// Suppose we have m crossings in our link. A "state diagram" is an assignment of integers 0,1
// (or the letters A,B) to crossings, represented by an intvec with entries 0,1. So the tuple T
// consists of two state diagrams state1,state2 related by a map of type chitype in position
// chiposition. The final entry is the result of calling mfCompileWeb on this data. 
//
// The return of mfCompileWeb is the list of all such tuples, over all possible pairs
// (state1,state2) connected by maps.
//
// To facilitate the computations we store the results of mfCompileWeb to disk, using writelist.
// To illustrate the scheme, take the state 010 and state 110, let us say that the underlying
// link has a positive crossing in the first position so that there is a map 010 -> 110 of
// chitype 0. Internally to mfCompileWeb we would then run
//
//      list map010to110 = mfCompileWeb( suitable params );
//
// Then a call to writelist:
//
//      writelist("filename","map010to110",map010to110);
//
// This will either create "filename" or append to it if it exists, writing a line to the file
// consisting of a Singular command which will recreate the list map010to110. To read from the
// file and execute this command one calls 
//
//      execute(read("filename"));
//
// which will run each line of "filename" in Singular.
//
// Before computing a given tuple T we load in the contents of the datafile and see if it has
// already been computed.

proc mfCompileLink(list linkData, string fileName, int useSaveFile)
{
    intvec vertexParity = linkData[1];
    list edgeList = linkData[2];
    
    int webSize = size(vertexParity);
    
    list stateDiagrams = powervec(webSize);
    list returnList;
    
    // Read in the save file, if it exists
    if( status(fileName,"exists") == "yes" && useSaveFile )
    {
        dbprint(printlevel, "[mfCompileLink] Reading in savefile.");
        execute(read(fileName));
    }

    int i;
    int numStateDiagrams = size(stateDiagrams);
    
    for( i = 1; i <= numStateDiagrams; i++ )
    {
        // Our current state diagram
        intvec v = stateDiagrams[i];
        dbprint(printlevel, "[mfCompileLink] Looking at state [" + string(v) + "] number " + string(i) + "/" + string(numStateDiagrams));
    
        // Look at each position and the possible maps given by chis
        int j;
        for( j = 1; j <= size(v); j++ )
        {
            // If either the current position in v is a 0 and the crossing is positive, or
            // if the current position is 1 and the crossing is negative, then there is a map
            // originating in this state diagram with a chi in this position
            intvec w = v;
            int somethingToDo = 0;
        
            if(v[j] == 0 && vertexParity[j] == 1) // chitype is 0
            {
                w[j] = w[j]+1;
                somethingToDo = 1;
            }
        
            if(v[j] == 1 && vertexParity[j] == -1) // chitype is 1
            {
                w[j] = w[j]-1;
                somethingToDo = 1;
            }
        
            if( somethingToDo )
            {
                dbprint(printlevel, "[mfCompileLink] Looking at the map to [" + string(w) + "]");
                string listName = "map" + intvecToString(v) + "to" + intvecToString(w);
            
                // Populate an integer definedCheck with the result of defined(map???to???)
                string cmd = "int definedCheck = defined(" + listName + ");";
                execute(cmd);
                
                // See if this list already exists (having been loaded from the file)
                if( definedCheck && useSaveFile )
                {
                    dbprint(printlevel, "[mfCompileLink] Already computed, skipping.");
                }
                else
                {
                    // Run mfCompileWeb
                    string cmd = "list " + listName + " = ";
                    cmd = cmd + "mfCompileWeb(linkweb(" + string(v) + ",edgeList),linkweb(" + string(w) + ",edgeList),";
                    cmd = cmd + string(v[j]) + "," + string(j) + "," + string(N) + ");";
                    //print(cmd);
                    execute(cmd);
            
                    // And add the output to our file
                    string cmd2 = "writelist(\"" + fileName + "\",\"" + listName + "\",";
                    cmd2 = cmd2 + listName + ");";
                    //print(cmd2);
                    dbprint(printlevel, "[mfCompileLink] Writing result to disk.");
                    execute(cmd2);
                }
                
                // Add the computed list to the end of compiledEntry
                list compiledEntry = v, w, v[j], j;
                string cmd = "compiledEntry = compiledEntry + list(" + listName + ");";
                execute(cmd);
                
                returnList = returnList + list(compiledEntry);
            }
        }
    }
    
    return(returnList);
}

proc linkweb(int v1, int v2, int v3, int v4, list edgeList)
{
    list output = list( v1, edgeList[1] ), list( v2, edgeList[2] ), list( v3, edgeList[3] ), list( v4, edgeList[4] );
    return(output);
}

proc externalDegreeOfWeb(intvec v, intvec vertexParity)
{
    // 0 is always degree zero, and 1 is either degree -1 or +1 depending on the crossing type
    int i;
    int d;
    for( i = 1; i <= size(v); i++ )
    {
        d = d + v[i] * vertexParity[i];
    }
    
    return(d);
}

////////////////////////////////////////////////////////////////////
// superblockmat
//
// We are given a list of matrices which are supposed to fit into
// a block matrix with "numCols" columns, and we return the block matrix.
// The list is interpreted as a block matrix as follows: the first numCols
// entries form the first row, the second numCols entries the second row, etc.

proc superblockmat(int numCols, list #)
{
    int numRows = size(#)/numCols;
    
    // We first collect each row of the block matrix into a list
    list l;
    
    int i,j,k,t,s;
    for(s = 1;s<=numRows;s++)
    {
        // In this row of the block matrix we have the matrices
        // #[(s-1)*numCols + 1], ...., #[s * numCols]
        int b = nrows(#[s*numCols]);
        
        for(j=1;j<=b;j++)
        {
            list thisrow;
            
            for(k=1;k<=numCols;k++)
            {
                // We are now inside #[(s-1)*numCols + k]
                matrix cMat = #[(s-1)*numCols +k];
                for(t=1;t<=ncols(cMat);t++)
                {
                    thisrow = thisrow + list(cMat[j,t]);
                }
                kill cMat;
            }
            
            l = l + list(thisrow);
        }
    }
    
    // Convert l to a matrix
    matrix A[size(l)][size(l[1])];
    for(i=1;i<=size(l);i++)
    {
        for(j=1;j<=size(l[1]);j++)
        {
            A[i,j] = l[i][j];
        }
    }
    
    return(A);
}