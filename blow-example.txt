//////////////////////////////////////////////////////////////////////////////////////
// EXAMPLE 1 (identity defect acting on (x,x^4))
//////////////////////////////////////////////////////////////////////////////////////

option(noredefine);option(noloadLib);option(redSB);
LIB "blow.lib";
LIB "matrix.lib";
int nx=1;
int ny=1;
ring rr=(0,eta),(x(1..nx),y(1..ny)),dp;
minpoly = rootofUnity(5);

int baa=5;
poly W = x(1)^baa;

// Define X, Y and D = Y x X:

matrix fY[1][1] = y(1)-x(1); 
matrix gY[1][1] = (y(1)^5 - x(1)^5)/(y(1)-x(1));
matrix fX[1][1] = x(1); 
matrix gX[1][1] = x(1)^4;
matrix fD = MFtensorF(fY,gY,fX,gX);
matrix gD = MFtensorG(fY,gY,fX,gX);
matrix n1[1][1];
matrix n2[2][2];
matrix X = blockmat(n1,gX,fX,n1);
matrix Y = blockmat(n1,gY,fY,n1);
matrix D = blockmat(n2,gD,fD,n2);

// This is dQ_X: 

matrix dq = dQ(X, W, nx, baa);
print(dq);

// "iddQ" is "id x dQ_X":

matrix iddQ = tensor(unitmat(2), dq); 
print(iddQ);

// This is deltaQ_D:

matrix delQ = deltaQ(D, W, nx, baa);
print(delQ);

// This is e':

matrix e = iddQ * delQ;
print(e);

// Now one should reduce Y x X x Jac(W) and see what happens to e in this process, but I haven't written any code to automate this yet (though it should be easy).


//////////////////////////////////////////////////////////////////////////////////////
// EXAMPLE 2 (silly)
//////////////////////////////////////////////////////////////////////////////////////

option(noredefine);option(noloadLib);option(redSB);
LIB "blow.lib";
int nx=2;
int ny=2;
ring rr=0,(x(1..nx),y(1..ny)),dp;
//ring rr=(0,r),(x(1..nx),y(1..ny)),dp;
//minpoly = r^2 + 1;

int baa = 3;
poly W = x(1)^baa + x(2)^baa;

// The matrix factorisations X is the tensor product of two "minimal model matrix factorisations":

matrix f1[1][1] = x(1);
matrix g1[1][1] = x(1)^(baa - 1);
matrix f2[1][1] = x(2)^2;
matrix g2[1][1] = x(2)^(baa - 2);
matrix f = MFtensorF(f1,g1,f2,g2);
matrix g = MFtensorG(f1,g1,f2,g2);
matrix n2[2][2];
matrix X = blockmat(n2,g,f,n2);
print(X);

// The matrix factorisations Y is a silly tensor product of "minimal model matrix factorisations":

matrix fa[1][1] = -x(1);
matrix ga[1][1] = x(1)^(baa - 1);
matrix fb[1][1] = x(2)^2;
matrix gb[1][1] = -x(2)^(baa - 2);
matrix fc = MFtensorF(fa,ga,fb,gb);
matrix gc = MFtensorG(fa,ga,fb,gb);
matrix fay[1][1] = y(1);
matrix gay[1][1] = y(1)^(baa - 1);
matrix fby[1][1] = y(2)^2;
matrix gby[1][1] = y(2)^(baa - 2);
matrix fcy = MFtensorF(fay,gay,fby,gby);
matrix gcy = MFtensorG(fay,gay,fby,gby);
matrix F = MFtensorF(fc,gc,fcy,gcy);
matrix G = MFtensorG(fc,gc,fcy,gcy);
matrix n8[8][8];
matrix Y = blockmat(n8,G,F,n8);
print(Y);

// D = Y x X:

matrix fd = MFtensorF(f,g,F,G);
matrix gd = MFtensorG(f,g,F,G);
matrix n32[32][32];
matrix D = blockmat(n32,gd,fd,n32);
print(D);

// deltaQ_D:

print(deltaQ(D, W, nx, baa));

// dQ_X (not yet tensored with the identity...):

print(dQ(X, W, nx, baa));

// Hence e is the identity in this example. 


