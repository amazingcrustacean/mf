Notes on Singular codebase
==========================

The following notes refer to the source for Singular version 3-1-1-5 downloaded from http://www.mathematik.uni-kl.de/ftp/pub/Math/Singular/SOURCES/3-1-1/ on 16/9/2010. Files are found in the directory ./kernel unless specified otherwise.

structs.h tells us that matrix is typedefed to a pointer to an object of class ip_smatrix. ip_smatrix is defined in matpol.h as follows:

class ip_smatrix
{
  public:

  poly *m;
  long rank;
  int nrows;
  int ncols;

  inline int& rows() { return nrows; }
  inline int& cols() { return ncols; }

  #define MATROWS(i) ((i)->nrows)
  #define MATCOLS(i) ((i)->ncols)
  #define MATELEM(mat,i,j) ((mat)->m)[MATCOLS((mat)) * ((i)-1) + (j)-1]
};

The interesting thing is that the entries of the matrix are stored in the pointer m. If we look in matpol.cc at the initialiser for the class (some pieces snipped)

matrix mpNew(int r, int c)
{
  ....
  matrix rc = (matrix)omAllocBin(ip_smatrix_bin);
  rc->nrows = r;
  rc->ncols = c;
  rc->rank = r;
  if (c != 0)
  {
    int s=r*c*sizeof(poly);
    rc->m = (polyset)omAlloc0(s);
  }
  return rc;
}

So we allocate enough memory to hold r * c polynomials (probably this is very small, as a poly is probably just a pointer) and m is assigned to be a pointer to a "polyset". Again in struct.h we find typedef poly * polyset.

What is a polynomial?
=====================

This is a bit complicated. It is clear that the fundamental data type in Singular is the polynomial. In structs.h we find

typedef struct spolyrec    polyrec;
typedef polyrec *          poly;
typedef poly *             polyset;

So we just need to understand what a spolyrec is. For this we look to polys-impl.h where we find

struct  spolyrec
{
  poly      next;           // next needs to be the first field
  number    coef;           // and coef the second --- do not change this !!!
  unsigned long exp[VARS];  // make sure that exp is aligned
};

There are a several additional files with polynomial operations, for example polys.h (polynomials of the current ring) and p_polys.h (polynomial routines independent of the current ring). We learn from the above definition that a polynomial is ultimately a linked list, with each node representing a monomial consisting of a number and an exponent, stored along with a pointer to the "next" node/monomial.

The fancy C++ class Poly can be found in Poly.h, complete with overloaded operators, etc. Probably this is the contact point with the interpreter. See testpoly.cc for how to use this class. Although from grep we learn that only Number and Poly seem to have such class wrappers around the base structs with == operators, etc. Probably in the interpreter every == or + boils down to one between Polys or Numbers.

When we look at some of the functions in matpol.cc we see things like

matrix b = mpNew(m, n);
b->m[i] = ??;

Recall that b is a pointer to a class of type ip_smatrix, and b->m is a pointer to a class of type poly. But more than that, in mpNew we allocate storage for a poly for every entry of the matrix, so b->m[i] simply moves the pointer to the ith polynomial stored in this block of memory, that is, it is a pointer to the ith polynomial entry in the matrix.

Note that using grep "operator\[\]" * we find that only Ideal.h and some things to do with intvec have overloaded array operators, so there is no confusion.

Polynomials are intialised with pNew and pInit (see polys.h, pInline1.h for pInit = p_Init and pInline2.h for pNew = p_New). If you look in pInline1.h probably the real initialisation takes place in the following three lines (line 116-119)

p_ExpVectorCopy(np, p, r);
pNext(np) = NULL;
pSetCoeff0(np, NULL);

So when a polynomial is initialised (to zero) we get a zero exponent vector, a NULL pointer for the next monomial, and a zero coefficient.

So what about sparse matrices?
==============================

Singular's storage strategy for matrices is pretty cool, but there does not seem to anything in the standard matrix source files that deals with sparseness. The sparsmat.h header is included in matpol.cc, but is only used in 

mp_permmatrix::mpElimBareiss
mpElimBar

where SM_MULT and SM_DIV show up. So the few sparse matrix methods that appear are probably used for this one algorithm (bareiss??). The conclusion is that there is no automatic use of sparse matrix techniques within Singular for e.g. multiplication of large (sparse) matrices.