/////////////////////////////////////////////////////////////////////////////////////////
// Compute KR cohomology of "twisted unknot".
/////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////
// Part TK0: Treat the Gamma0-resolution of the crossing. The relevant web has three vertices,
// two of which are "marks" in the KR terminology and one of which is the "null crossing"
// where the crossing has been removed. Reading from left to right on the diagram "OO" we
// index these vertices by 3, 1, 2 and orient the edges as KR do, towards the top of the
// page. The variables are x(1),x(2),x(3),x(4), with the first two outgoing from the null
// crossing and the latter two incoming.
//
// The vertices 2,3 are decorated by the appropriate identity defects, and 1 is decorated
// by the tensor product of two identity defects.
//
// Note with this indexing the sign factor B is +1.

option(noredefine);option(noloadLib);option(redSB);
LIB "blow.lib";
LIB "linkhom.lib";
LIB "matrix.lib";
int nx=4;
ring rr0=0,(x(1..nx)),dp;
int N = 2; // The N in sl(N) link homology

////////// SECTION A ///////////
matrix D1a = mfIdentityDefect( x(1)^(N+1), x(4)^(N+1), x(1), x(4) );
matrix D1b = mfIdentityDefect( x(2)^(N+1), x(3)^(N+1), x(2), x(3) );
matrix D1 = MFtensor(D1b, D1a);
matrix D2 = mfIdentityDefect( x(3)^(N+1), x(2)^(N+1), x(3), x(2) );
matrix D3 = mfIdentityDefect( x(4)^(N+1), x(1)^(N+1), x(4), x(1) );
////////// END SECTION A /////////

// The internal algebra is defined by the ideal J
ideal J = x(1)^N, x(2)^N, x(3)^N, x(4)^N;
intvec q = N, N, N, N;
number Nn = N + 1;
matrix C = 1/Nn * unitmat(4);

// Compute the ordinary tensor product, which is a two-periodic complex
// NOTE: bracketing matters in tensor products, because different bracketing
// determines a different basis ordering. That is, MFtensor(-,MFtensor(-,-))
// is not the same as MFtensor(MFtensor(-,-),-). Obvious but it caught me!
// This bracketing must be consistent with the choice of bracketing used
// for the computation of diff1,diff2 etc. below
matrix D = MFtensor(D1, MFtensor(D2,D3));
print(D*D);

// Inflate the differential on this tensor product
matrix Dblow = mablow(D,J);

// Reduce this inflated differential:
list l = mfReduce(Dblow,1);
matrix RD = l[1];
matrix F = l[2]; // A homotopy equivalence F: Dblow -> RD
matrix G = l[3]; // A homotopy equivalence G: RD -> Dblow

// The idempotent e is given by
//
//  e = (-1)^(nx choose 2) * det(C) * partial(D1) * partial(D2) * partial(D3) * delta(D)

matrix diff1 = ZZtensor( diff(D1, x(1)) * diff(D1,x(2)), unitmat(ncols(D2)*ncols(D3)) );
matrix diff2 = ZZtensor( unitmat(ncols(D1)), ZZtensor( diff(D2,x(3)), unitmat(ncols(D3))) );
matrix diff3 = ZZtensor( unitmat(ncols(D1)), ZZtensor( unitmat(ncols(D2)), diff(D3,x(4))));

matrix iddQ = mablow( det(C) * diff1 * diff2 * diff3, J );
matrix delQ = deltaQ(D,q);

// And finally the idempotent e on Dblow
int sign = (nx * (nx-1)) div 2;
matrix e = (-1)^(sign) * iddQ * delQ; 
matrix z[ncols(e)][ncols(e)];
print((e * Dblow - Dblow * e)==z);

// The induced idempotent on the reduction is denoted ep
matrix ep = F * e * G;
matrix zn[ncols(ep)][ncols(ep)];
print((ep * RD - RD * ep)==zn); // ep is at least a morphism

// ep is an idempotent on the nose
print((ep * ep - ep)==zn); 

matrix ep0 = extractblockmat(ep)[1];
matrix ep1 = extractblockmat(ep)[4];

print(mat_rk(ep0));       // Gives N * N, as expected
print(mat_rk(ep1));       // Gives 0

/////////////////////////////////////////////////////////////////////////////////////////
// Part TK1: Treat the Gamma1-resolution of the crossing. This means compiling a closed 
//           web with two 2-valent vertices decorated by identity defects which are 
//           connected to a 4-valent vertex decorated by the "wide edge defect". 
//           The identity defect D2 has one incoming edge labelled by x1 and one outgoing
//           edge labelled by x3. 
//           The identity defect D3 has one incoming edge labelled by x2 and one outgoing
//           edge labelled by x4. 
//           The wide edge defect D1 has two incoming edges labelled by x3, x4, and two
//           outgoing edges labelled by x1, x2. 
/////////////////////////////////////////////////////////////////////////////////////////

// Just run the above with "Section A" replaced by the following:
matrix D1 = mfWideEdge( x(1), x(2), x(3), x(4), N);
matrix D2 = mfIdentityDefect( x(3)^(N+1), x(2)^(N+1), x(3), x(2) );
matrix D3 = mfIdentityDefect( x(4)^(N+1), x(1)^(N+1), x(4), x(1) );

/////////////////////////////////////////////////////////////////////////////////////////
// Part TK2: Compute the map between the two resolutions of the twisted unknot.
/////////////////////////////////////////////////////////////////////////////////////////

option(noredefine);option(noloadLib);option(redSB);
LIB "blow.lib";
LIB "linkhom.lib";
LIB "matrix.lib";
int nx=4;
ring rr0=0,(x(1..nx)),dp;
int N = 2; // The N in sl(N) link homology

// First we produce the matrix representing the morphism chi of [KR] p.50.
poly pi23 = ( x(2)^(N+1) - x(3)^(N+1) )/( x(2)-x(3) );
poly u1 = ( gpoly(x(1)+x(2), x(1)*x(2), N) - gpoly(x(3)+x(4), x(1)*x(2), N) )/( x(1)+x(2)-x(3)-x(4) );
poly u2 = ( gpoly(x(3)+x(4), x(1)*x(2), N) - gpoly(x(3)+x(4), x(3)*x(4), N) )/( x(1)*x(2)-x(3)*x(4) );
poly aa1 = -u2 + ( u1 +  x(1) * u2 - pi23 )/( x(1) - x(4) );

matrix chi[4][4] = x(4)-x(2), 0, 0,    0,
                    aa1,        1, 0,    0,
                    0,         0, x(4), -x(2),
                    0,         0, -1,   1;            // We set mu=0.

// Check it is a morphism from the tensor product of two identity defects to the wide edge
// Below t1 agrees with what KR give as the MF P on p.50, and t2 agrees with Q
matrix t1 = MFtensor( mfIdentityDefect(x(2)^(N+1),x(3)^(N+1),x(2),x(3)), mfIdentityDefect(x(1)^(N+1),x(4)^(N+1),x(1),x(4)));
matrix t2 = mfWideEdge( x(1), x(2), x(3), x(4), N);
matrix tzz[ncols(t1)][ncols(t1)];
print( (t2 * chi - chi * t1) == tzz );

// The map induced by chi from, in the above notation, t1 x L41 x L32 -> t2 x L41 x L32 is chiT
matrix chiT = ZZtensor( chi, ZZtensor( unitmat(2), unitmat(2) ));

// Using the above code, let us compute Gamma0 and Gamma1 before reduction, and
// check that chiT is a morphism between them
matrix D2 = mfIdentityDefect( x(3)^(N+1), x(2)^(N+1), x(3), x(2) );
matrix D3 = mfIdentityDefect( x(4)^(N+1), x(1)^(N+1), x(4), x(1) );
matrix Gamma0 = MFtensor(t1, MFtensor(D2,D3));
matrix Gamma1 = MFtensor(t2, MFtensor(D2,D3));
matrix gzz[ncols(Gamma0)][ncols(Gamma0)];
print( (chiT * Gamma0 - Gamma1 * chiT) == gzz );

// Now blow up the Gammas and chiT, and check the latter is still a morphism
ideal J = x(1)^N, x(2)^N, x(3)^N, x(4)^N;
intvec q = N, N, N, N;
number Nn = N + 1;
matrix C = 1/Nn * unitmat(4);

matrix Gamma0blow = mablow(Gamma0,J);
matrix Gamma1blow = mablow(Gamma1,J);
matrix chiTblow = mablow(chiT,J);
matrix gzzb[ncols(Gamma0blow)][ncols(Gamma0blow)];
print( (chiTblow * Gamma0blow - Gamma1blow * chiTblow) == gzzb );

// Now reduce both the Gammas and compute the induced map chir between them
list l = mfReduce(Gamma0blow,1);
matrix RD0 = l[1];
matrix F0 = l[2]; // A homotopy equivalence F: Gamma0blow -> RD0
matrix G0 = l[3]; // A homotopy equivalence G: RD0 -> Gamma0blow

l = mfReduce(Gamma1blow,1);
matrix RD1 = l[1];
matrix F1 = l[2]; // A homotopy equivalence F: Gamma0blow -> RD1
matrix G1 = l[3]; // A homotopy equivalence G: RD1 -> Gamma0blow

// chir gives a map between these two complexes (both of which have zero differential)
matrix chir = F1 * chiTblow * G0;

// Now since our link has two components, we know that the reduced C(Gamma0) and
// C(Gamma1), which split the idempotents on RD0 and RD1 respectively, live only
// in degree zero. So it suffices to study the map induced by chir on these degree
// zero pieces. We find these spaces by splitting the idempotents in degree zero.
// We write eq0 for the idempotent on RD0 and eq1 for the idempotent on RD1.

/////////// OBTAINING IDEMPOTENT eq0 ///////////
matrix diff1 = ZZtensor( diff(t1, x(1)) * diff(t1,x(2)), unitmat(ncols(D2)*ncols(D3)) );
matrix diff2 = ZZtensor( unitmat(ncols(t1)), ZZtensor( diff(D2,x(3)), unitmat(ncols(D3))) );
matrix diff3 = ZZtensor( unitmat(ncols(t1)), ZZtensor( unitmat(ncols(D2)), diff(D3,x(4))));
matrix iddQ = mablow( det(C) * diff1 * diff2 * diff3, J );
matrix delQ = deltaQ(Gamma0,q);
int sign = (nx * (nx-1)) div 2;
matrix e = (-1)^(sign) * iddQ * delQ; 
matrix z[ncols(e)][ncols(e)];
print((e * Gamma0blow - Gamma0blow * e)==z); // Endo of Gamma0blow
matrix eq0 = F0 * e * G0;
matrix zn[ncols(eq0)][ncols(eq0)];
print((eq0 * eq0 - eq0)==zn); 

/////////// OBTAINING IDEMPOTENT eq1 ///////////
matrix diff1 = ZZtensor( diff(t2, x(1)) * diff(t2,x(2)), unitmat(ncols(D2)*ncols(D3)) );
matrix diff2 = ZZtensor( unitmat(ncols(t2)), ZZtensor( diff(D2,x(3)), unitmat(ncols(D3))) );
matrix diff3 = ZZtensor( unitmat(ncols(t2)), ZZtensor( unitmat(ncols(D2)), diff(D3,x(4))));
matrix iddQ = mablow( det(C) * diff1 * diff2 * diff3, J );
matrix delQ = deltaQ(Gamma1,q);
int sign = (nx * (nx-1)) div 2;
matrix e = (-1)^(sign) * iddQ * delQ; 
matrix z[ncols(e)][ncols(e)];
print((e * Gamma1blow - Gamma1blow * e)==z);
matrix eq1 = F1 * e * G1;
matrix zn[ncols(eq1)][ncols(eq1)];
print((eq1 * eq1 - eq1)==zn);

// Now replace both idempotents by their degree zero components (which are the only
// nonzero bits) and also chir by its degree zero component

matrix eq0f = extractblockmat(eq0)[1];
matrix eq1f = extractblockmat(eq1)[1];
matrix chirf = extractblockmat(chir)[1];

// Now split each of the idempotents by hand
LIB "control.lib";
module ker0 = rightKernel(unitmat(ncols(eq0f)) - eq0f);
matrix f0 = ker0;
matrix g0[ncols(f0)][nrows(f0)]; // Defaults to zero
    
if( ker0[1] != [0] )
{
    matrix g0 = leftInverse(f0) * eq0f; // Solves f0 * g0 = eq0f.
};

// Split eq1
module ker1 = rightKernel(unitmat(ncols(eq1f)) - eq1f);
matrix f1 = ker1;
matrix g1[ncols(f1)][nrows(f1)]; // Defaults to zero
    
if( ker1[1] != [0] )
{
    matrix g1 = leftInverse(f1) * eq1f; // Solves f1 * g1 = eq1.
};

matrix finalMap = g1 * chirf * f0;
print(nrows(g1) - mat_rk(finalMap)); // Dimension of H^1
matrix k = rightKernel(finalMap);
print(ncols(k)); // Dimension of H^0