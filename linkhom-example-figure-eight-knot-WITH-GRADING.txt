/////////////////////////////////////////////////////////////////////////////////////////
// Compute KR cohomology of "figure-eight knot".
/////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////
// We use the conventions and labellings of the note [FEK] from 2010-08-09. 
//
// Part 1: Try to reduce the matrix factorisations "((AA)B)B" from [FEK, p.3].
/////////////////////////////////////////////////////////////////////////////////////////

// Let (f x g) x h : (A x B) x C --> (A' x B') x C' be a morphism, and let
// F1: (A x B)_blow --> (A x B)_reduced (where here and below "reduced" means
// reduced in two senses: first getting rid of non-zero constant entried, and 
// then splitting the idempotent, hence (A x B)_reduced is isomorphic to A x B)
// be a morphism with homotopy inverse G1, 
// F2: ((A x B)_reduced x C)_blow --> ((A x B)_reduced x C)_reduced be a 
// morphism with homotopy inverse G2. Then
//     (((f x g)_blow o G1) x h)_blow o G2
// is the associated morphism ((A x B)_reduced x C)_reduced --> (A' x B') x C'.
// Similarly, we get a morphism 
// ((A x B)_reduced x C)_reduced --> ((A' x B')_reduced x C')_reduced by also
// making use of primed versions of F1 and F2 "from the left".
//
// Iterating this construction one more time and using the various maps F,G, we
// obtain the map (AABB)_reduced --> (AABA+AAAB+BABB+ABBB)_reduced 
// between the degree -2 piece and the degree -1 piece of KR cohomology.

// Step 1.1: Compile "AA"

option(noredefine);option(noloadLib);option(redSB);
LIB "blow.lib";
LIB "linkhom.lib";
LIB "matrix.lib";
int nx=2;
int ny=4;
ring rr=0,(x(1..nx),y(1..ny)),dp;
int N = 2; // The N in sl(N) link homology
printlevel = 1;

// In the notation of [FEK, p.1] the Figure eight knot has four crossings, which
// we refer to by the tuple of variables incident at the crossing (e.g. 1578). At the
// crossing 1578 we place A1 and at 2678 we place A2, defined as follows:

matrix A1a = mfIdentityDefect( y(1)^(N+1), y(2)^(N+1), y(1), y(2) );
matrix A1b = mfIdentityDefect( x(1)^(N+1), x(2)^(N+1), x(1), x(2) );
matrix A1 = MFtensor(A1a, A1b);
matrix A2a = mfIdentityDefect( y(3)^(N+1), y(4)^(N+1), y(3), y(4) );
matrix A2b = mfIdentityDefect( x(2)^(N+1), x(1)^(N+1), x(2), x(1) );
matrix A2 = MFtensor(A2a, A2b);

intvec A1agr = mfIdentityDefectGrading( N+1 );
intvec A1bgr = mfIdentityDefectGrading( N+1 );
intvec A1gr = MFtensorGradings(A1agr, A1bgr);
intvec A2agr = mfIdentityDefectGrading( N+1 );
intvec A2bgr = mfIdentityDefectGrading( N+1 );
intvec A2gr = MFtensorGradings(A2agr, A2bgr);

// Here the mapping between Singular variables and edge labels of [FEK] is
// x(1) = 7, x(2) = 8, y(1) = 1, y(2) = 5, y(3) = 6, y(4) = 2

// The above A1,A2 will contribute to the degree -2 piece of KR cohomology.
// To reduce the map between the degree -2 piece and the degree -1 piece
// (and eventually compute KR cohomology), we have to simultaneously reduce
// the degree -1 piece of KR cohomology.
// However, for the moment and for testing purposes we will only reduce the
// "AABA" part of the degree -1 piece and reduce the map 
// ((id x id) x id) x chi1 between AABB and AABA. The degree -1 contributions
// will be denoted like the degree -2 ones, but always with an "r" at the end:

matrix A1r = A1;
matrix A2r = A2;
intvec A1rgr = A1gr;
intvec A2rgr = A2gr;

ideal J = x(1)^N, x(2)^N;
intvec q = N, N;
number Nn = N + 1;
matrix C[2][2] = 1/Nn, 0, 0, 1/Nn;

// The blockmatrices c1,c2,c3,c4 will eventually make up the map between
// AABB and AABA+AAAB+BABB+ABBB. At each compilation step we will a) take
// care of one more tensor factor, b) change variable names if necessary, 
// c) blow the ci up with mablow.

matrix c(1) = mablow( ZZtensor( unitmat(4), unitmat(4) ), J );
matrix c(2) = mablow( ZZtensor( unitmat(4), unitmat(4) ), J );
matrix c(3) = mablow( ZZtensor( mfChi0(y(1),x(1),y(2),x(2),N), unitmat(4) ), J );
matrix c(4) = mablow( ZZtensor( unitmat(4), mfChi0(y(3),x(2),y(4),x(1),N) ), J );

// Compute the ordinary tensor product
matrix D = MFtensor(A1,A2);
intvec Dgr = MFtensorGradings(A1gr, A2gr);
matrix Dblow = mablow(D,J);
intvec Dblowgr = mablowGrading(Dgr,J);
matrix Dr = MFtensor(A1r,A2r);
intvec Drgr = MFtensorGradings(A1rgr, A2rgr);
matrix Dblowr = mablow(Dr,J);
intvec Dblowrgr = mablowGrading(Drgr,J);

// Reduce this inflated differential
list l = mfReduce(Dblow,1);
matrix RD = l[1];
matrix F1 = l[2]; // A homotopy equivalence F: Dblow -> RD
matrix G1 = l[3]; // A homotopy equivalence G: RD -> Dblow
intvec RDgr = computeGradingFromInjection(G1,Dblowgr);
list lr = mfReduce(Dblowr,1);
matrix RDr = lr[1];
matrix F1r = lr[2];
matrix G1r = lr[3];
intvec RDrgr = computeGradingFromInjection(G1r,Dblowrgr);

matrix diff1 = ZZtensor( diff(A1, x(1)), unitmat(ncols(A2)) );
matrix diff2 = ZZtensor( unitmat(ncols(A1)), diff(A2, x(2)) );
matrix iddQ = mablow( det(C) * diff1 * diff2, J );
matrix diff1r = ZZtensor( diff(A1r, x(1)), unitmat(ncols(A2r)) );
matrix diff2r = ZZtensor( unitmat(ncols(A1r)), diff(A2r, x(2)) );
matrix iddQr = mablow( det(C) * diff1r * diff2r, J );

matrix delta1 = mablow_delta(D, 1, 2, J);
matrix delta2 = mablow_delta(D, 2, 2, J);
matrix delQ = delta1 * delta2;
matrix delta1r = mablow_delta(Dr, 1, 2, J);
matrix delta2r = mablow_delta(Dr, 2, 2, J);
matrix delQr = delta1r * delta2r;

// And finally the idempotent e on Dblow
int sign = (nx * (nx-1)) div 2;
matrix e = (-1)^(sign) * iddQ * delQ;
matrix er = (-1)^(sign) * iddQr * delQr;

matrix ep = F1 * e * G1;
matrix epr = F1r * er * G1r;
ep * RD == RD * ep;
ep * ep == ep;

// Strictify this idempotent (ep is already idempotent on the nose, so this is not really necessary):
matrix epfinal = mfStrictifyIdempotent(RD, ep);
matrix epfinalr = mfStrictifyIdempotent(RDr, epr);
epfinal * RD == RD * epfinal;
epfinal * epfinal == epfinal;

l = mfSplitIdempotent(RD, epfinal, RDgr);
lr = mfSplitIdempotent(RDr, epfinalr, RDrgr);

matrix finalAA = mfSuspend( l[1], nx );
matrix finalAAr = mfSuspend( lr[1], nx );
intvec finalAAgr = mfSuspendGrading( l[4], nx );
intvec finalAArgr = mfSuspendGrading( lr[4], nx );

matrix s1 = mfSuspendMorph( l[2], nx );    // finalAA --> RD
matrix t1 = mfSuspendMorph( l[3], nx );    // RD --> finalAA
matrix s1r = mfSuspendMorph( lr[2], nx );
matrix t1r = mfSuspendMorph( lr[3], nx );


// Step 1.2: Compile "AAB"

// We now collapse the top two crossings of the figure-eight into a single vertex, where
// we place finalAA, which in the notation of [FEK] has outgoing edges labelled 1 and 6
// and incoming edges 2 and 5. If we consider the web with this vertex and the vertex
// 3456 then there are four external variables (1,2,3,4) and two internal variables (5,6).
// Note that finalAA only involves y(1),...,y(4) which map to 1,5,6,2. If we run

matrix AAv = subst(finalAA,y(2),x(1));
matrix AA = subst(AAv,y(3),x(2));
intvec AAgr = finalAAgr;
G1 = subst(G1,y(2),x(1)); G1 = subst(G1,y(3),x(2));

matrix AAvr = subst(finalAAr,y(2),x(1));
matrix AAr = subst(AAvr,y(3),x(2));
intvec AArgr = finalAArgr;
F1r = subst(F1r,y(2),x(1)); F1r = subst(F1r,y(3),x(2));

// Then finalAA involves y(1),x(1),x(2),y(4). The remaining variables y(2),y(3) we now
// consider to represent the edges 3,4. So the current mapping of Singular variables
// to edge labels is
// x(1) = 5, x(2) = 6, y(1) = 1, y(2) = 3, y(3) = 4, y(4) = 2

matrix B3 = mfWideEdge( y(2), x(1), y(3), x(2), N );
intvec B3gr = mfWideEdgeGrading( N );
matrix B3r = B3;
intvec B3rgr = mfWideEdgeGrading( N );

// c-matices (from here on c(2),c(3),c(4) are not correctly defined because we
// we do not treat the pieces AAAB+BABB+ABBB for which we would have different
// s1r,t1r,etc.; I still kept them to see what happens roughly):

c(3) = subst(c(3),y(2),x(1));
c(4) = subst(c(4),y(3),x(2));
c(1) = mablow( ZZtensor( t1r * F1r * c(1) * G1 * s1, unitmat(4) ), J );
c(2) = mablow( ZZtensor( t1r * F1r * c(2) * G1 * s1, mfChi1(y(2),x(1),y(3),x(2),N) ), J );
c(3) = mablow( ZZtensor( t1r * F1r * c(3) * G1 * s1, unitmat(4) ), J );
c(4) = mablow( ZZtensor( t1r * F1r * c(4) * G1 * s1, unitmat(4) ), J );

// Compute the ordinary tensor product
matrix D = MFtensor(AA,B3);
intvec Dgr = MFtensorGradings(AAgr,B3gr);
matrix Dblow = mablow(D,J);
intvec Dblowgr = mablowGrading(Dgr,J);
matrix Dr = MFtensor(AAr,B3r);
intvec Drgr = MFtensorGradings(AArgr,B3rgr);
matrix Dblowr = mablow(Dr,J);
intvec Dblowrgr = mablowGrading(Drgr,J);

// Reduce this inflated differential
list l = mfReduce(Dblow,1);
matrix RD = l[1];
matrix F2 = l[2]; // A homotopy equivalence F: Dblow -> RD
matrix G2 = l[3]; // A homotopy equivalence G: RD -> Dblow
intvec RDgr = computeGradingFromInjection(G2,Dblowgr);
list lr = mfReduce(Dblowr,1);
matrix RDr = lr[1];
matrix F2r = lr[2];
matrix G2r = lr[3];
intvec RDrgr = computeGradingFromInjection(G2r,Dblowrgr);

matrix diff1 = ZZtensor( diff(AA, x(2)), unitmat(ncols(B3)) );
matrix diff2 = ZZtensor( unitmat(ncols(AA)), diff(B3, x(1)) );
matrix iddQ = mablow( det(C) * diff1 * diff2, J );
matrix diff1r = ZZtensor( diff(AAr, x(2)), unitmat(ncols(B3r)) );
matrix diff2r = ZZtensor( unitmat(ncols(AAr)), diff(B3r, x(1)) );
matrix iddQr = mablow( det(C) * diff1r * diff2r, J );

matrix delta1 = mablow_delta(D, 1, 2, J);
matrix delta2 = mablow_delta(D, 2, 2, J);
matrix delQ = delta1 * delta2;
matrix delta1r = mablow_delta(Dr, 1, 2, J);
matrix delta2r = mablow_delta(Dr, 2, 2, J);
matrix delQr = delta1r * delta2r;

// And finally the idempotent e on Dblow
int sign = (nx * (nx-1)) div 2;
matrix e = -1 * (-1)^(sign) * iddQ * delQ;
matrix er = -1 * (-1)^(sign) * iddQr * delQr;

matrix ep = F2 * e * G2;
matrix epr = F2r * er * G2r;
ep * RD == RD * ep;
ep * ep == ep;

// Strictify this idempotent (ep is already idempotent on the nose, so this is not really necessary):
matrix epfinal = mfStrictifyIdempotent(RD, ep);
matrix epfinalr = mfStrictifyIdempotent(RDr, epr);
epfinal * RD == RD * epfinal;
epfinal * epfinal == epfinal;

l = mfSplitIdempotent(RD, epfinal, RDgr);
lr = mfSplitIdempotent(RDr, epfinalr, RDrgr);

matrix finalAAB = mfSuspend( l[1], nx );
intvec finalAABgr = mfSuspendGrading( l[4], nx );
matrix finalAABr = mfSuspend( lr[1], nx );
intvec finalAABrgr = mfSuspendGrading( lr[4], nx );

matrix s2 = mfSuspendMorph( l[2], nx );    // finalAAB --> RD
matrix t2 = mfSuspendMorph( l[3], nx );    // RD --> finalAAB
matrix s2r = mfSuspendMorph( lr[2], nx );
matrix t2r = mfSuspendMorph( lr[3], nx );


// Step 1.3: Compile "AABB"

// So finalAAB involves y(1),y(2),y(3),y(4) which currently represent the labels 1,3,4,2.
// We transfer finalAAB into a new ring, relabelling y(i) into x(i)

// Relabel variables:
int nx=4;
int ny=4;
ring rr2=0,(x(1..nx),y(1..ny)),dp;
int N = 2; // The N in sl(N) link homology
matrix finalAAB = imap(rr,finalAAB);
matrix AAB1 = subst(finalAAB,y(1),x(1));
matrix AAB2 = subst(AAB1,y(2),x(2));
matrix AAB3 = subst(AAB2,y(3),x(3));
matrix AAB = subst(AAB3,y(4),x(4));
intvec AABgr = finalAABgr;
matrix finalAABr = imap(rr,finalAABr);
matrix AAB1r = subst(finalAABr,y(1),x(1));
matrix AAB2r = subst(AAB1r,y(2),x(2));
matrix AAB3r = subst(AAB2r,y(3),x(3));
matrix AABr = subst(AAB3r,y(4),x(4));
intvec AABrgr = finalAABrgr;

matrix s2 = imap(rr,s2);
matrix t2 = imap(rr,t2);
matrix s2r = imap(rr,s2r);
matrix t2r = imap(rr,t2r);
matrix G2 = imap(rr,G2);
matrix F2r = imap(rr,F2r);

int i1,i2;
for( i1=1; i1<=4; i1++)
{
    s2 = subst(s2,y(i1),x(i1));
    s2r = subst(s2r,y(i1),x(i1));
    t2 = subst(t2,y(i1),x(i1));
    t2r = subst(t2r,y(i1),x(i1));
    G2 = subst(G2,y(i1),x(i1));
    F2r = subst(F2r,y(i1),x(i1));
}

// c-matices:
matrix c(1) = imap(rr,c(1));
matrix c(2) = imap(rr,c(2));
matrix c(3) = imap(rr,c(3));
matrix c(4) = imap(rr,c(4));
for( i1=1; i1<=4; i1++)
{
    for( i2=1; i2<=4; i2++)
    {
        c(i1) = subst(c(i1),y(i2),x(i2));
    }
}

int nx=4;
ring rr3=0,(x(1..nx)),dp;
int N = 2;
matrix AAB = imap(rr2,AAB);
matrix AABr = imap(rr2,AABr);

matrix s2 = imap(rr2,s2);
matrix t2 = imap(rr2,t2);
matrix s2r = imap(rr2,s2r);
matrix t2r = imap(rr2,t2r);

// c-matices:
matrix c(1) = imap(rr2,c(1));
matrix c(2) = imap(rr2,c(2));
matrix c(3) = imap(rr2,c(3));
matrix c(4) = imap(rr2,c(4));

matrix G2 = imap(rr2,G2);
matrix F2r = imap(rr2,F2r);

// Our current mapping is x(1) = 1, x(2) = 3, x(3) = 4, x(4) = 2.

matrix B4 = mfWideEdge( x(3), x(4), x(2), x(1), N );
intvec B4gr = mfWideEdgeGrading( N );
matrix A4ar = mfIdentityDefect( x(3)^(N+1), x(2)^(N+1), x(3), x(2) );
matrix A4br = mfIdentityDefect( x(4)^(N+1), x(1)^(N+1), x(4), x(1) );
matrix A4r = MFtensor(A4ar, A4br);
intvec A4agr = mfIdentityDefectGrading( N+1 );
intvec A4bgr = mfIdentityDefectGrading( N+1 );
intvec A4rgr = MFtensorGradings(A4agr, A4bgr);

ideal J = x(1)^N, x(2)^N, x(3)^N, x(4)^N;
intvec q = N, N, N, N;
number Nn = N + 1;
matrix C[4][4] = 1/Nn * unitmat(4);

// Compute the ordinary tensor product
matrix D = MFtensor(AAB,B4);
intvec Dgr = MFtensorGradings(AABgr,B4gr);
matrix Dblow = mablow(D,J);
intvec Dblowgr = mablowGrading(Dgr, J);
matrix Dr = MFtensor(AABr,A4r);
intvec Drgr = MFtensorGradings(AABrgr,A4rgr);
matrix Dblowr = mablow(Dr,J);
intvec Dblowrgr = mablowGrading(Drgr, J);

// Reduce this inflated differential
list l = mfReduce(Dblow,1);
matrix RD = l[1];
matrix F3 = l[2]; // A homotopy equivalence F: Dblow -> RD
matrix G3 = l[3]; // A homotopy equivalence G: RD -> Dblow
intvec RDgr = computeGradingFromInjection(G3,Dblowgr);
list lr = mfReduce(Dblowr,1);
matrix RDr = lr[1];
matrix F3r = lr[2];
matrix G3r = lr[3];
intvec RDrgr = computeGradingFromInjection(G3r,Dblowrgr);

// RD is the zero matrix:
RD == zeromat(ncols(RD));

// c-matices from RD to RDr (or to one of the other reduced forms of
// AAAB, BABB, ABBB):
c(1) = F3r * mablow( ZZtensor( t2r * F2r * c(1) * G2 * s2, mfChi1(x(3),x(4),x(2),x(1),N) ), J ) * G3;
c(2) = F3r * mablow( ZZtensor( t2r * F2r * c(2) * G2 * s2, unitmat(4) ), J ) * G3;
c(3) = F3r * mablow( ZZtensor( t2r * F2r * c(3) * G2 * s2, unitmat(4) ), J ) * G3;
c(4) = F3r * mablow( ZZtensor( t2r * F2r * c(4) * G2 * s2, unitmat(4) ), J ) * G3;
// Remark: After we will have split the final idempotents below, we will have to
//         conjugate the c(i) with the splitting morphisms to get the final answer.

matrix diff1 = ZZtensor( diff(AAB, x(1)) * diff(AAB, x(2)), unitmat(ncols(B4)) );
matrix diff2 = ZZtensor( unitmat(ncols(AAB)), diff(B4, x(3)) * diff(B4, x(4)) );
matrix iddQ = mablow( det(C) * diff1 * diff2, J );
matrix diff1r = ZZtensor( diff(AABr, x(1)) * diff(AABr, x(2)), unitmat(ncols(A4r)) );
matrix diff2r = ZZtensor( unitmat(ncols(AABr)), diff(A4r, x(3)) * diff(A4r, x(4)) );
matrix iddQr = mablow( det(C) * diff1r * diff2r, J );

matrix delta1 = mablow_delta(D, 1, 2, J);
matrix delta2 = mablow_delta(D, 2, 2, J);
matrix delta3 = mablow_delta(D, 3, 2, J);
matrix delta4 = mablow_delta(D, 4, 2, J);
matrix delQ = delta1 * delta2 * delta3 * delta4;
matrix delta1r = mablow_delta(Dr, 1, 2, J);
matrix delta2r = mablow_delta(Dr, 2, 2, J);
matrix delta3r = mablow_delta(Dr, 3, 2, J);
matrix delta4r = mablow_delta(Dr, 4, 2, J);
matrix delQr = delta1r * delta2r * delta3r * delta4r;

// And finally the idempotent e on Dblow
int sign = (nx * (nx-1)) div 2;
matrix e = (-1)^(sign) * iddQ * delQ;
matrix er = (-1)^(sign) * iddQr * delQr;

matrix ep = F3 * e * G3;
matrix epr = F3r * er * G3r;
ep * ep == ep;

// Strictify this idempotent:
matrix epfinal = mfStrictifyIdempotent(RD, ep);
matrix epfinalr = mfStrictifyIdempotent(RDr, epr);
epfinal * epfinal == epfinal;

matrix finalAABB = mfSuspend( mfSplitIdempotent(RD, epfinal), nx );
matrix finalAABA = mfSuspend( mfSplitIdempotent(RDr, epfinalr), nx );
// This gives (since mfSplitIdempotent is not equipped to deal with MFs of zero): 
// [mfSplitIdempotent] Debug break 3
// [mfSplitIdempotent] Splitting produced nonsquare matrices, exiting.

matrix ep0 = extractblockmat(epfinal)[1];
matrix ep1 = extractblockmat(epfinal)[4];
print(mat_rk(ep0));
print(mat_rk(ep1));
matrix ep0r = extractblockmat(epfinalr)[1];
matrix ep1r = extractblockmat(epfinalr)[4];
print(mat_rk(ep0r));
print(mat_rk(ep1r));

// Hence the reduced form of AABB is 0 -> QQ^8 -> 0, where QQ = rationals.
// and the reduced form of AABA is 0 -> QQ^4 -> 0.

// We can also check this using the following Chern character calculation
// In the following the variable x(i) maps to the edge i.
// option(noredefine);option(noloadLib);option(redSB);
// LIB "blow.lib";
// LIB "linkhom.lib";
// LIB "matrix.lib";
// int nx=8;
// int N = 2; // The N in sl(N) link homology
// ring rr=0,(x(1..nx)),dp;
// matrix A1a = mfIdentityDefect( x(7)^(N+1), x(8)^(N+1), x(7), x(8) );
// matrix A1b = mfIdentityDefect( x(1)^(N+1), x(5)^(N+1), x(1), x(5) );
// matrix A1 = MFtensor(A1a, A1b);
// poly ch1 = supertrace( diff(A1, x(1)) * diff(A1, x(5)) * diff(A1, x(7)) * diff(A1, x(8)) );
// matrix A2a = mfIdentityDefect( x(8)^(N+1), x(7)^(N+1), x(8), x(7) );
// matrix A2b = mfIdentityDefect( x(6)^(N+1), x(2)^(N+1), x(6), x(2) );
// matrix A2 = MFtensor(A2a, A2b);
// poly ch2 = supertrace( diff(A2, x(2)) * diff(A2,x(6)) * diff(A2,x(7)) * diff(A2,x(8)));
// matrix B3 = mfWideEdge( x(3), x(5), x(6), x(4), N );
// poly ch3 = supertrace( diff(B3, x(3)) * diff(B3,x(5)) * diff(B3,x(6)) * diff(B3,x(4)));
// matrix B4 = mfWideEdge( x(2), x(4), x(1), x(3), N );
// poly ch4 = supertrace( diff(B4, x(2)) * diff(B4,x(4)) * diff(B4,x(1)) * diff(B4,x(3)));
// ideal J = x(1)^N, x(2)^N, x(3)^N, x(4)^N, x(5)^N, x(6)^N, x(7)^N, x(8)^N;
// poly chernFinal = reduce( ch1 * ch2 * ch3 * ch4, std(J) );
// The total Chern character is this divided by (N+1)^8 and with Res( - / x(1)^N ... x(8)^N ) applied.
// For N = 2 this yields 8 (up to a sign), confirming the calculation above.

matrix eq0f = ep1;
matrix eq0fr = ep1r;

// Now split the idempotent eq0f by hand:
LIB "control.lib";
module ker0 = rightKernel(unitmat(ncols(eq0f)) - eq0f);
matrix f0 = ker0;
matrix g0[ncols(f0)][nrows(f0)]; // Defaults to zero
    
if( ker0[1] != [0] )
{
    matrix g0 = leftInverse(f0) * eq0f; // Solves f0 * g0 = eq0f.
};

// Check that (f0,g0) is a splitting of ep1:
f0 * g0 == ep1;
g0 * f0 == unitmat(ncols(g0 * f0));

// The grading on RD1 is given by
intvec RDgr1 = RDgr[(size(RDgr)/2+1)..size(RDgr)];

// Hence the induced grading on QQ^8 is 9,7,7,5,11,9,9,7:
intvec splitgr = computeGradingFromInjection(f0, RDgr1);

// Now split the idempotent eq0fr by hand:
module ker0r = rightKernel(unitmat(ncols(eq0fr)) - eq0fr);
matrix f0r = ker0r;
matrix g0r[ncols(f0r)][nrows(f0r)];
    
if( ker0r[1] != [0] )
{
    matrix g0r = leftInverse(f0r) * eq0fr;
};

// Check that (f0r,g0r) is a splitting of ep1r:
f0r * g0r == ep1r;
g0r * f0r == unitmat(ncols(g0r * f0r));

// The grading on RDr1 is given by
intvec RDrgr1 = RDrgr[(size(RDrgr)/2+1)..size(RDrgr)];

// Hence the induced grading on QQ^4 is 8,10,8,6:
intvec splitrgr = computeGradingFromInjection(f0r, RDrgr1);

// Finally, to get the (non-zero part of the) map from AABB to AABA:

c(1) = g0r * extractblockmat(c(1))[4] * f0;

// The kernel of c(1) is 4-dimensional:

rightKernel( c(1) );
// Result:
// _[1]=gen(1)
// _[2]=5*gen(3)+gen(2)
// _[3]=gen(5)
// _[4]=57*gen(7)-170*gen(6)

// Note that by line 482 above, components 2,3 and 6,7 have the same degree (7 and 9,
// respectively) as it must be for the kernel of c(1) to be graded. 


// The other c(i) work similarly, but as we have not treated the terms AAAB+BABB+ABBB,
// the above c(2),c(3),c(4) are are not the correct ones, as one needs the
// appropriate s1r,t1r,s2r etc. for this. 
// Maybe now the time has come to write some more general and more efficient piece
// of code so that we don't have to do all this by hand. We should split this into at
// least two parts: (a) compilation of the relevant webs and the associated reduction of
// maps between them, and (b) computation of the KR complex of MFs of a given knot. 

// SKETCH of how to compile (certain) webs automatically:
//
//  (1) We assume that we are given a KR-type web, i.e. a planar graph with only two
//      kinds of 4-valent vertices, two of whose incident edges are incoming and the other 
//      two are outgoing, and there are no external edges. 
//  (2) We further assume that the vertices can be assigned distinct labels 1,...,v where
//      v=(total number of vertices) such that vertices 1 and 2 are joined by precisely two
//      edges, that the fusion of vertices 1 and 2 is joined with vertex 3 by precisely two
//      edges etc.; only the fusion of the first v-1 vertices is joined by precisely four
//      edges with the final vertex v.
//  (3) Hence we can represent such a web by the following data D: D is a list of v elements,
//      each of which is again a list of two elements: D[i] = list(vertextype(i),edgevec(i)) for
//      i=1,...,v where vertextype(i) is a string that indicates whether the vertex is the tensor
//      product of two identity defects (label A) or a wide edge defect (label B), and edgevec(i)
//      is an intvec of length 4 such that its first two entries label the outgoing edges and 
//      its last two entries label the incoming edges of the i-th vertex. (There are 2*v edges,
//      and the D uniquely determines the kind of web that we consider.)
//  (4) The only morphisms of webs with v vertices that we will encounter are tensor products 
//      of v-1 identity maps and either one chi0 or one chi1. Thus to specify a morphism of webs
//      we only have to indicate at which position i chi0 oder chi1 sits. Its variable dependence
//      will be given by edgevec(i) and the identifications with x- and y-variables made below.
//  (5) Let us be given two web data D1 and D2 with D1[i] = list(vertextype1(i),edgevec1(i)) and
//      similarly for D2, and let us be given a map alpha between D1 and D2. Our aim is to reduce
//      this (where by reducing we mean both our usual blowing-up and idempotent-splitting).
//      We start by identifying which of the eight entries in edgevec1(1) and edgevec1(2) 
//      occur twice and call them int(1) and int(2). The remaining four entries we call 
//      ext(1),...,ext(4). (The order is not important, as long as we don't forget it.) Then we
//      make the idenfication (we should use a list to keep track of it):
//          x(i) corresponds to int(i) for i=1,2,
//          y(i) corresponds to ext(i) for i=1,2,3,4.
//  (6) Using this and the data D1, D2, alpha, we compute the fusions of the first two vertices
//      in both webs as well as the morphism between these two fused subwebs in the usual way 
//      (see linkhom-example-figure-eight-knot).
//  (7) Identify which two numbers in edgevec1(3) are not in {ext(i)}_{i=1,...,4} and call them
//      n(1) and n(2). Furthermore, determine which of the numbers in {ext(i)}_{i=1,...,4} also
//      appear in edgevec1(3). Let us say these are ext(i1) and ext(i2). Now we make new
//      identifications as follows:
//          x(1) cooresponds to ext(i1),
//          x(2) cooresponds to ext(i2),
//          y(k) corresponds to ext(k) for k in {1,2,3,4}\{i1,i2},
//          y(i1) cooresponds to n(1),
//          x(i2) cooresponds to n(2).
//  (8) Redefine everything that was produced in step (6):
//      bla = subst( bla, y(i1), x(1) ); bla = subst( bla, y(i2), x(2) );.
//  (9) Now compute the next fusion as usual, i.e. repeat the obvious adaptation of steps
//      (7) to (9) until the first v-1 vertices are fused.
// (10) Rename y(1),...,y(4) into x(1),...x(4), write the last vertex in the correct
//      x-variables (as encoded in edgevec1(v) and the most recent identifications of variables
//      and edge labels), and do the last fusion as usual. 



