version="0.1";
category="Miscellaneous";
// summary description of the library
info="
LIBRARY:   mfweb-general.lib  Compilation of defect webs
AUTHOR:    Nils Carqueville, Daniel Murfet
KEYWORDS:  matrix factorization

PROCEDURES:
";

LIB "linalg.lib";
LIB "matrix.lib";
LIB "ring.lib";
LIB "blow.lib";
LIB "linkhom.lib";
LIB "mfweb.lib";

////////////////////////////////////////////////////////////////////
// USAGE GUIDE
//
// A web is an oriented graph where edges are allowed to begin or end, but not
// both, on some unspecified "boundary". All edges are labelled with a set of variables
// and a potential, and every vertex is assigned a matrix factorisation
// of the sum of all the "outgoing" potential minus the sum of all the incoming
// potentials. There must be at least one variable on each edge, disjoint variables
// on distinct edges, and potentials must have isolated singularities. Throughout
// comments in this file, V denotes the total number of vertices in the web (always >0)
// We implicitly order the vertices and consider them as elements in the set {1,...,V}.
//
// WARNING: We do not allow isolated vertices, with no incoming or outgoing vertices.
// The ordering of the variables in L1 and L2 may matter.

////////////////////////////////////////////////////////////////////
// USAGE GUIDE: parameters
//
// We allow rings of the form (0,r),(variables),dp where r is a parameter.
// If this is an algebraic extension with minimum polynomial "minpoly" then 
// there should also be defined a polynomial minpolyblow, in the first ring variable
// var(1), equal to substituting var(1) for r in minpoly.

/////////////////////////////////////////////////
// DATA TYPE: edge
//
// An edge is a list (S,T,L,W) where S,T are integers in the range 0,...,V, L is a
// nonempty list of variables in the ring, and W is a polynomial in the variables
// present in L. Here S, T are the indices, respectively of the "S"ource and "T"arget
// of the edge, where "0" stands for the boundary.

/////////////////////////////////////////////////
// DATA TYPE: augmented edge
//
// An augmented edge is a list (S,T,L,W,B,C) where (S,T,L,W) is an edge, B is a list
// of size n = size(L), and C is a nxn matrix of polynomials such that for each i
// between 1 and n = |L|, we have
//
//      L[i]^B[i] = C[i,1] * diff(W,L[1]) + ... + C[i,n] * diff(W,L[n]).
//
// The existence of such integers B[i] and polynomials C[i,j] follows from the assumption
// that W defines an isolated singularity, hence the partial derivatives of W generate an
// ideal primary for the ideal generated by all the variables on the edge.

/////////////////////////////////////////////////
// TERMINOLOGY
//
// We say that a variable is "adjacent" at a vertex if the variable lies on an edge
// adjacent to the vertex. A variable is "external" if it lies on an edge involving
// the boundary, and "internal" otherwise.
//
// The total potential of a web is the sum of the potentials associated with
// each vertex of the web.

/////////////////////////////////////////////////
// DATA TYPE: web
//
// A web is represented by a tuple (V, L1, L2[,L3]) where V is an integer > 0, giving
// number of vertices in the web, and two or three lists, where
//
//  1. L1 is a list of edges.
//  2. L2 is a list of matrices, of size V, with the matrix in posn i
//  being the differential of a matrix factorisation defined in the 
//  set of variables adjacent with the vertex i, factorising the potential
//  explained in the Usage Guide.
//  3. L3 is an optional list of intvecs, also of size v, making each
//  of the MFs into a graded MF.
//
// NOTE: Distinct edges in the web MUST be assigned disjoint sets of variables!

/////////////////////////////////////////////////
// DATA TYPE: compilation strategy
//
// Compilation of a web means taking the tensor product over all MFs in the
// web and pushing forward to the ring with all internal variables in the web
// deleted. A compilation strategy represents one way of effecting this pushforward
// in practice.
//
// Precisely, a compilation strategy consists of a pair (L1,L2), where
// L1 is a permutation of the set {1,...,V} and L2 is a list
// containing each internal variable in the web precisely once. The idea is that L1 tells
// us the order in which to tensor the MFs in the web together (for example, if
// L1 were 3,1,2 we should first tensor the MF at vertex 3 with the one at vertex 1,
// and then tensor the result with the MF at vertex 2) and L2 tells us the ordering
// on the variables to use in the reduction/pushforward procedure.

/////////////////////////////////////////////////
// Settor and Accessor methods for an edge.
//
// The point of these being that if we change the structure of the lists underlying
// an edge, or web, then we only need change the following routines.

proc edgeSource(list edge){ return(edge[1]); }
proc edgeTarget(list edge){ return(edge[2]); }
proc edgeVariables(list edge){ return(edge[3]); }
proc edgePotential(list edge){ return(edge[4]); }
proc augedgePowers(list augedge){ return(augedge[5]); }
proc augedgeTransform(list augedge){ return(augedge[6]); }
proc setEdgeSource(list edge, int src){ edge[1] = src; return(edge); }
proc setEdgeTarget(list edge, int tar){ edge[2] = tar; return(edge); }
proc setEdgeVariables(list edge, list var){ edge[3] = var; return(edge); }
proc setEdgePotential(list edge, poly W){ edge[4] = W; return(edge); }
// NOTE: augmentedEdgeForEdge breaks the setter/getter barrier.

/////////////////////////////////////////////////
// Settor and Accessor methods for a web.

proc webSize(list web){ return(web[1]); }
proc webEdges(list web){ return(web[2]); }
proc webMFs(list web){ return(web[3]); }
proc webMFatVertex(list web, int vertex){ return(web[3][vertex]); }
proc webMFgr(list web){ return(web[4]); }
proc webMFgratVertex(list web, int vertex){ return(web[4][vertex]); }
proc webIsGraded(list web){ int t = (size(web) == 4); return(t); }

/////////////////////////////////////////////////
// Basic methods for vertices

proc vertexVariables(list web, int vertex)
{
    list vars;
    list edgeList = webEdges(web);
    
    int i;
    for(i = 1; i <= size(edgeList); i++)
    {
        list edge = edgeList[i];
        if( edgeSource(edge) == vertex || edgeTarget(edge) == vertex )
        {
            vars = vars + edgeVariables(edge);
        }
        kill edge;
    }
    
    kill edgeList;
    return(vars);
}

/////////////////////////////////////////////////
// vertexIncomingEdges
//
// Return a list (possibly empty) of indices into
// the array of edges giving those edges with target
// the given vertex (possibly the boundary 0).

proc vertexIncomingEdges(list web, int vertex)
{
    list eList;
    list edgeList = webEdges(web);
    
    int i;
    for(i = 1; i <= size(edgeList); i++ )
    {
        list edge = edgeList[i];
        if( edgeTarget(edge) == vertex )
        {
            eList = eList + list(i);
        }
        kill edge;
    }
    
    return(eList);
}

proc vertexOutgoingEdges(list web, int vertex)
{
    list eList;
    list edgeList = webEdges(web);
    
    int i;
    for(i = 1; i <= size(edgeList); i++ )
    {
        list edge = edgeList[i];
        if( edgeSource(edge) == vertex )
        {
            eList = eList + list(i);
        }
        kill edge;
    }
    
    return(eList);
}

proc vertexPotential(list web, int vertex)
{
    poly W;
    list edgeList = webEdges(web);
    
    int i;
    for(i=1; i <= size(edgeList); i++ )
    {
        list edge = edgeList[i];
        int nc;
        
        if( edgeSource(edge) == vertex ){ nc = 1; }
        if( edgeTarget(edge) == vertex ){ nc = -1; }
        
        W = W + nc * edgePotential(edge);
        
        kill edge;
    }
    
    return(W);
}

/////////////////////////////////////////////////
// ringWithoutVars
//
// Given a set of variables in the ring, returns
// the ring with those variables deleted (but otherwise
// preserved, for example parameters). We do NOT change
// the current basering. Note that vars should be a list
// of polynomials, not strings.

proc ringWithOnlyVars(list vars)
{
    list exvars;
    int i;
    for(i=1; i<=nvars(basering); i++)
    {
        if( !checklist(vars,var(i)) )
        {
            exvars = exvars + list(var(i));
        }
    }
    
    def nR = ringWithoutVars(exvars);
    return(nR);
}

proc ringWithoutVars(list vars)
{
    if( size(vars) == 0 )
    {
        print("[ringWithoutVars] Asked to create a ring with no variables, exiting.");
        return(0);
    }
    
    def SSS = basering;
    list rlist = ringlist(SSS);
    list newVar;
    
    // Go through and form newVar = current variables minus vars
    int i;
    for(i = 1; i <= size(rlist[2]); i++)
    {
        int found = 0;
        int j;
        for(j = 1; j <= size(vars); j++ )
        {
            if( string(vars[j]) == rlist[2][i] )
            {
                found = 1;
                break;
            }
        }
        
        if( !found ){ newVar = newVar + list(rlist[2][i]); }
    }
    
    list newringList = rlist;
    newringList[2] = newVar;

    // Fix the variable weighting
    intvec kk = (1..size(newVar));
    for(i=1; i<=size(newVar); i++)
    {
        kk[i] = 1;
    }
    newringList[3][1][2] = kk;
    kill kk;
    
    newringList[1][4][1] = 0;     // set minpoly to zero, put it back to the right value below...
    
    // Create our new ring
    def nR = ring(newringList);
    kill rlist, newringList;
    
    // Now complete the correct definition of nR by specifying the right minpoly: 
    if( defined(minpolyblow) && defined(r) )
    {
        setring nR;
        
        // Note that fetch uses the position of the ring variables, not the name, so 
        // that fetch(var(1)) is always var(1).
        poly P = fetch(SSS,minpolyblow); 
        poly z = subst(P,var(1),r);
        number nu = leadcoef(z);
        minpoly = nu;
        setring SSS;
    }
    
    return(nR);
}

/////////////////////////////////////////////////
// augmentedEdgeForEdge
//
// Given an edge, creates an associated augmented edge

proc augmentedEdgeForEdge(list edge)
{
    int powerCutoff = blowFlags("power_cutoff_jacobi"); 
    int useSanityChecks = blowFlags("sanity_checks");
    
    // Recall that an edge has the format (S,T,L,W) and an augmented edge has the format
    // (S,T,L,W,B,C) where B is an intvec and C a matrix.
    
    // First change ourselves into the ring with only the variables present on the given edge    
    def RRR = basering;
    def nR = ringWithOnlyVars(edgeVariables(edge));
    setring nR;

    // Note it's important that we respect the order of the variables in the edge, NOT
    // the natural ordering in the ring.
    list edge = imap(RRR,edge);
    list augEdge = edge;
    
    list L = edgeVariables(edge);
    poly W = edgePotential(edge);
    
    // Build the Jacobi ideal
    ideal J;
    int i;
    for(i=1; i <= size(L); i++)
    {
        J[i] = diff(W,L[i]);
    }
    ideal Jstd = std(J);
    
    list B;
    matrix C;
    for(i=1; i <= size(L); i++)
    {
        // Find a power of the variable va belonging to the ideal generated by the partials of W
        poly va = L[i];
        
        int p;
        int power = 0;
        
        for(p=1; p <= powerCutoff; p++)
        {
            if( reduce(va^p, Jstd) == 0 )
            {
                //print(string(va) + " to the power " + string(p) + " belongs to J"); //debug
                power = p;
                B[i] = p;
                matrix T = lift(J, va^p);
                
                if( ncols(T) != 1 || nrows(T) != size(J) )
                {
                    print("[augmentedEdgeForEdge] Something wrong with the lift, exiting.");
                    return(0);
                }
                
                if( i == 1 )
                {
                    C = T;
                }
                else
                {
                    C = concat(C,T);
                }
                
                break;
            }
        }
        
        if( power == 0 )
        {
            print("[augmentedEdgeForEdge] Failed to find power of variable in Jacobi ideal, exiting.");
            return(0);
        }
    }
    augEdge[5] = B;
    augEdge[6] = C;
    setring RRR;
    list augEdge = imap(nR, augEdge);
    ideal J = imap(nR,J);
    
    // Perform sanity check
    if( useSanityChecks )
    {
        matrix Q = matrix(J) * augEdge[6];
        list edgeVar = edgeVariables(edge);
        
        int i;
        for(i=1; i <= size(edgeVar); i++)
        {
            if( Q[1,i] != edgeVar[i]^(augEdge[5][i]) )
            {
                print("[augmentedEdgeForEdge] Failed to correct compute augmented edge correctly, exiting.");
                return(0);
            }
        }
    }
    
    return(augEdge);
}

/////////////////////////////////////////////////
// isEdgeInternal

proc isEdgeInternal(list edge)
{
    if( edgeSource(edge) != 0 && edgeTarget(edge) != 0 )
    {
        return(1); 
    }
    
    return(0);
}

/////////////////////////////////////////////////
// webVariables
//
// Returns the list consisting of all variables lying
// on all edges in the web.

proc webVariables(list web)
{
    list edgeList = webEdges(web);
    list vars;
    
    int i;
    for(i=1; i<=size(edgeList); i++)
    {
        list edge = edgeList[i];
        vars = vars + edgeVariables(edge);
        kill edge;
    }
    
    return(vars);
}

/////////////////////////////////////////////////
// subwebWithVertices
//
// Returns the subweb consisting of the given vertices in the original web
// together with all edges adjacent to those vertices, EVEN THOSE ENDING ON
// VERTICES NOT IN THE LIST. If an edge begins or ends on a vertex in our
// list, but does not end (resp. begin) on a vertex in our list (or 0, which
// is implicitly in every subweb) then we consider it to have begun or ended
// on the boundary; so that in forming the subweb we "shrink" the boundary until
// it cuts across all edges going outside our set of vertices.
//
// NOTE: You should not pass 0 as a vertex to any routines.

proc subwebWithVertices(list web, list vertices)
{
    int useSanityChecks = blowFlags("sanity_checks");
    
    if( size(vertices) == 0 )
    {
        print("[subwebWithVertices] Given no vertices in list, exiting.");
        return();
    }
    
    int useGrading = webIsGraded(web);
    
    // The easy part is building the list of MFs and gradings, so let us do that first
    list MFlist = webMFs(web);
    if( useGrading ){ list MFgrlist = webMFgr(web); }
    list subMFlist;
    if( useGrading ){ list subMFgrlist; }
    
    int i;
    for(i=1; i<=size(vertices); i++)
    {
        subMFlist = subMFlist + list(MFlist[vertices[i]]);
        if( useGrading ){ subMFgrlist = subMFgrlist + list(MFgrlist[vertices[i]]); }
    }
    
    // Now we need to build up the edges. First of all we discard any edges not
    // beginning or ending at one of the vertices in our list.
    // Then in each of these edges replace the integer vertices[i] by i.
    
    list edgeList = webEdges(web);
    list subEdgeList;
    
    for(i=1; i<=size(edgeList); i++)
    {
        list edge = edgeList[i];
        if( checklist(vertices,edgeSource(edge)) || checklist(vertices,edgeTarget(edge)) )
        {
            // Add this edge to our list. The only modification we make is to set 
            // the source or target to 0 if it was previously a vertex not in our list
            if( !checklist(vertices,edgeSource(edge)) )
            {
                edge = setEdgeSource(edge, 0);
            }
            
            if( !checklist(vertices,edgeTarget(edge)) )
            {
                edge = setEdgeTarget(edge, 0);
            }
            
            subEdgeList = subEdgeList + list(edge);
        }
        kill edge;
    }
    
    list finalEdgeList;
    
    // Now go through and modify all the edges in subEdgeList.
    int j;
    for(j=1; j<=size(subEdgeList); j++)
    {
        list edge = subEdgeList[j];
        int fixedSource;
        int fixedTarget;
        for(i=1; i<=size(vertices); i++)
        {
            
            if( edgeSource(edge) == vertices[i] && !fixedSource )
            {
                edge = setEdgeSource(edge, i);
                
                // After we change the source, in a later i iteration a
                // vertex could recognise us as having them as the source,
                // so to avoid this we use a flag.
                fixedSource = 1;
            }
            
            if( edgeTarget(edge) == vertices[i] && !fixedTarget )
            {
                edge = setEdgeTarget(edge, i);
                fixedTarget = 1;
            }
            
        }
        finalEdgeList = finalEdgeList + list(edge);
        kill edge;    
    }
    kill subEdgeList;
    
    list subweb = size(vertices), finalEdgeList, subMFlist;
    if( useGrading ){ subweb = subweb + list(subMFgrlist); }
    
    if( useSanityChecks )
    {
        if( !webVerifyGeneral(subweb) )
        {
            print("[subwebWithVertices] Produced invalid subweb, exiting.");
            return();
        }
    }
    
    return(subweb);
}

/////////////////////////////////////////////////
// webVerify
//
// Verify that the given list satisfies (some of) the conditions to be a web.

proc webVerifyGeneral(list web)
{
    int useGrading = webIsGraded(web);
    int numVertices = webSize(web);
    
    if( numVertices != size(webMFs(web)) )
    {
        print("[webVerify] There is size mismatch between vertices and MFs, failed.");
        return(0);
    }
    
    int i;
    for(i=1;i<=size(numVertices);i++)
    {
        matrix A = webMFatVertex(web, i);
        poly W = vertexPotential(web, i);
        if( useGrading ){ intvec Agr = webMFgratVertex(web, i); }
        
        if( size(vertexIncomingEdges(web,i)) + size(vertexOutgoingEdges(web,i)) == 0 )
        {
            print("[webVerify] There is an isolated vertex, failed.");
            return(0);
        }
        
        // Is A a MF of this potential?
        if( A * A != W * unitmat(ncols(A)) )
        {
            print("[webVerify] At vertex " + string(i) + " the MF does not factorise the local potential W=" + string(W) + ", failed.");
            return(0);
        }
        
        // Is A a graded MF?
        if( useGrading )
        {
            if( !isGradingValid(A, Agr) )
            {
                print("[webVerify] At vertex " + string(i) + " the grading is not valid, failed.");
                return(0);
            }
        }
    }
    
    return(1);
}

/////////////////////////////////////////////////
// webCompilePair
//
// The backbone of our compilation routines. We are given a web with only
// two vertices and a compilation strategy. Next we describe the output in
// the standard case, but be aware there is an important special case to be
// explained at the end.
//
// We first return a matrix factorisation in the set of external variables
// of the total potential of the given web. Let X denote the tensor product
// over all vertices of the associated MFs, defined in the ordering determined
// by our compilation strategy. Let pX denote the pushforward/restriction of
// scalars to the ring with all internal variables in the web deleted. Our
// first return value is the differential of a MF Y homotopy equivalent to pX.
//
// The second return value is the grading vector for Y, if we are using gradings.
//
// The third (or second, if there is no grading) return value is a list
// R = (F1,G1,x1,exp1),(F1,G2,x2,exp2),... whose length is equal to the number of
// internal variables in the web. These are the maps returned by mfPushforwardInductive
// applied to the set of internal variables ordered according to our compilation strategy.
//
// In more detail: let p1X denote the pushforward of X just to the ring without the
// "first" internal variable, where "first" means first in the compilation strategy.
// This is a direct summand of Xblow[1], and (F1,G1) is a pair splitting, in the
// homotopy category of finite rank MFs, the corresponding idempotent. Say the
// splitting is Y1. Then F1: Xblow[1] -> Y1 and G1: Y1 -> Xblow[1] with F1 * G1 = 1
// and G1 * Y1 the idempotent corresponding to p1X.
//
// Next, we push forward Y1 to the ring without the first and second internal variables,
// and the same yoga produces maps (F2,G2) splitting an idempotent on Y1blow[1], etc.
//
// This list R is referred to as a "splitting record".
//
// NOTE: Special case
//
// If the total potential of the web is zero, and if in the last step of the compilation
// process we end up with non-square matrices (may not happen) then it is not safe to
// return the differential on Y (it will not be square) so our return list looks like
//
// "nonsquare", [r1,r2,] R
//
// where r1,r2 are grading vectors on the even and odd parts of Y resp. (if we are
// using the grading) and R is as described above, but where the last (F,G,x,exp) pair is
// a tuple f0,f1,g0,g1,x,exp with f0,g0 splitting the even part of the very last idempotent
// and similarly for f1,g1.

proc webCompilePairGeneral(list web, list compStrat)
{
    int useSanityChecks = blowFlags("sanity_checks");
    int useGrading = webIsGraded(web);
    
    if( useSanityChecks )
    {
        if( !webVerifyGeneral(web) )
        {
            print("[webCompilePairGeneral] Given web is not valid, exiting.");
            return();
        }
        
        if( webSize(web) != 2 )
        {
            print("[webCompilePairGeneral] We only compile pairs. Duh. Exiting.");
            return();
        }
    }
    
    // Extract the content of the web
    int numVertices = webSize(web);
    list edgeList = webEdges(web);
    list mfList = webMFs(web);
    if( useGrading ){ list mfGradings = webMFgr(web); }
    
    // And the compilation strategy
    list vertexOrder = compStrat[1];
    list varOrder = compStrat[2];
    
    if( size(vertexOrder) != 2 )
    {
        print("[webCompilePairGeneral] We only compile pairs, exiting.");
        return();
    }
    
    // Order the vertices according to the compilation strategy
    int i;
    for(i=1;i<=2;i++)
    {
        matrix mf(i) = mfList[vertexOrder[i]];
        if( useGrading ){ intvec mfgr(i) = mfGradings[vertexOrder[i]]; }
    }
    
    // Our task is to build up the input to mfPushforwardInductive and
    // then interpret its output.
    matrix A = MFtensor( mf(1), mf(2) );
    if( useGrading ){ intvec Agr = MFtensorGradings( mfgr(1), mfgr(2) ); }
    
    // Build up a list of the internal variables, ordered according to the
    // compilation strategy, a list of powers and a list of homotopies. The
    // powers we collect are the powers of the variables which act null-homotopically
    // on A, with associated homotopies stored in H.
    
    // NOTE: As opposed to the original webCompile, we have to work a little harder
    // to get our homotopies, since a priori we only know that certain partial
    // derivatives of the potentials on edges annihilate, via partial derivatives of
    // suitable differentials, and we have to convert these to null-homotopies of 
    // powers of the internal variables using augmentedEdgeForEdge, which tells us 
    // which powers of the variables on an edge can be written in terms of the partial
    // derivatives of the potential on the edge.
    
    list augEdgeList;
    for(i=1; i<=size(edgeList); i++)
    {
        list edge = edgeList[i];
        list augEdge = augmentedEdgeForEdge(edge);
        augEdgeList = augEdgeList + list(augEdge);
        kill augEdge, edge;
    }
    
    list intvars;
    list varPowers;
    list Hlist;
    
    for(i=1;i<=size(varOrder);i++)
    {
        poly u = varOrder[i];
        dbprint(printlevel, "[webCompilePairGeneral] Integrating out internal variable " + string(u)); // debug
        
        // Find out which edge this variable lies on
        int j;
        for(j=1; j<=size(edgeList); j++)
        {
            list edge = edgeList[j];
            list augEdge = augEdgeList[j];
            
            if( checklist(edgeVariables(edge), u) )
            {
                // Yes, u does lie on this edge
                if( !isEdgeInternal(edge) )
                {
                    print("[webCompilePairGeneral] Internal variable lying on external edge, exiting.");
                    return();
                }
                
                intvars = intvars + list(u);
                
                poly W = edgePotential(edge);
                int src = edgeSource(edge);
                list varList = edgeVariables(edge);
                list B = augedgePowers(augEdge);
                matrix C = augedgeTransform(augEdge);
                matrix D = mfList[src];
                
                // Find out where in varList u occurs
                int k;
                int uPos;
                for(k=1; k<=size(varList); k++)
                {
                    if( varList[k] == u )
                    {
                        uPos = k;
                        break;
                    }
                }
                
                // Note that D factorises some potential W' with W as a summand, and that
                // for any variable x in the list varList, i.e. a variable on edge, the
                // variable x only occurs in W' as part of W. Hence if we take the
                // partial derivative of D * D = W' we find that
                //
                //   diff(D,x) * D + D * diff(D,x) = diff(W,x).
                //
                // If we sum over the different variables and multiply by the appropriate
                // factors in C, then on the right hand side we have a power of u.
                
                // Recall that by construction
                //
                // u^B[uPos] = C[uPos,1] * diff(W,varList[1]) + ... + C[uPos,n] * diff(W,varList[n]).
                
                matrix H[nrows(D)][ncols(D)];
                for(k=1; k<=size(varList); k++)
                {
                    matrix h = diff(D,varList[k]);
                    
                    if( h * D + D * h != diff(W,varList[k]) * unitmat(ncols(D)) )
                    {
                        print("[webCompilePairGeneral] Inner homotopy construction failure, exiting.");
                        return();
                    }
                    
                    H = H + C[uPos,k] * h;
                    kill h;
                }
                
                // Convert this from a homotopy on D to a homotopy on A
                if( vertexOrder[1] == src )
                {
                    H = ZZtensor( H, unitmat(ncols(mf(2))) );
                }
                else
                {
                    H = ZZtensor( unitmat(ncols(mf(1))), H );
                }
                
                if( useSanityChecks )
                {
                    if( H * A + A * H != u^(B[uPos]) * unitmat(ncols(A)) )
                    {
                        print("[webCompilePairGeneral] Homotopy construction failure, exiting.");
                        return();
                    }
                }
                
                varPowers = varPowers + list(B[uPos]);
                Hlist = Hlist + list(H);
                kill W, src, B, H, varList;
            }
            
            kill edge, augEdge;
        }
    }
    
    // Now we feed all this to mfPushforwardInductive
    if( !useGrading )
    {
        list L = mfPushforwardInductive(A, intvars, varPowers, Hlist);
    }
    else
    {
        list L = mfPushforwardInductive(A, intvars, varPowers, Hlist, Agr);
    }
    kill A, intvars, varPowers, Hlist;
    
    return(L);
}