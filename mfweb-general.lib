version="0.1";
category="Miscellaneous";
// summary description of the library
info="
LIBRARY:   mfweb-general.lib  Compilation of defect webs
AUTHOR:    Nils Carqueville, Daniel Murfet
KEYWORDS:  matrix factorization

PROCEDURES:
";

LIB "linalg.lib";
LIB "matrix.lib";
LIB "ring.lib";
LIB "blow.lib";
LIB "linkhom.lib";
LIB "mfweb.lib";

////////////////////////////////////////////////////////////////////
// USAGE GUIDE
//
// A web is an oriented graph where edges are allowed to begin or end, but not
// both, on some unspecified "boundary". All edges are labelled with a set of variables
// and a potential, and every vertex is assigned a matrix factorisation
// of the sum of all the "outgoing" potential minus the sum of all the incoming
// potentials. There must be at least one variable on each edge, disjoint variables
// on distinct edges, and potentials must have isolated singularities. Throughout
// comments in this file, V denotes the total number of vertices in the web (always >0)
// We implicitly order the vertices and consider them as elements in the set {1,...,V}.
//
// WARNING: We do not allow isolated vertices, with no incoming or outgoing vertices.
// The ordering of the variables in L1 and L2 may matter.

////////////////////////////////////////////////////////////////////
// USAGE GUIDE: parameters
//
// We allow rings of the form (0,r),(variables),dp where r is a parameter.
// If this is an algebraic extension with minimum polynomial "minpoly" then 
// there should also be defined a polynomial minpolyblow, in the first ring variable
// var(1), equal to substituting var(1) for r in minpoly.

/////////////////////////////////////////////////
// DATA TYPE: edge
//
// An edge is a list (S,T,L,W) where S,T are integers in the range 0,...,V, L is a
// nonempty list of variables in the ring, and W is a polynomial in the variables
// present in L. Here S, T are the indices, respectively of the "S"ource and "T"arget
// of the edge, where "0" stands for the boundary.

/////////////////////////////////////////////////
// DATA TYPE: augmented edge
//
// An augmented edge is a list (S,T,L,W,B,C) where (S,T,L,W) is an edge, B is a list
// of size n = size(L), and C is a nxn matrix of polynomials such that for each i
// between 1 and n = |L|, we have
//
//      L[i]^B[i] = C[i,1] * diff(W,L[1]) + ... + C[i,n] * diff(W,L[n]).
//
// The existence of such integers B[i] and polynomials C[i,j] follows from the assumption
// that W defines an isolated singularity, hence the partial derivatives of W generate an
// ideal primary for the ideal generated by all the variables on the edge.

/////////////////////////////////////////////////
// TERMINOLOGY
//
// We say that a variable is "adjacent" at a vertex if the variable lies on an edge
// adjacent to the vertex. A variable is "external" if it lies on an edge involving
// the boundary, and "internal" otherwise.
//
// The total potential of a web is the sum of the potentials associated with
// each vertex of the web.

/////////////////////////////////////////////////
// DATA TYPE: web
//
// A web is represented by a tuple (V, L1, L2[,L3]) where V is an integer > 0, giving
// number of vertices in the web, and two or three lists, where
//
//  1. L1 is a list of edges.
//  2. L2 is a list of matrices, of size V, with the matrix in posn i
//  being the differential of a matrix factorisation defined in the 
//  set of variables adjacent with the vertex i, factorising the potential
//  explained in the Usage Guide.
//  3. L3 is an optional list of intvecs, also of size v, making each
//  of the MFs into a graded MF.
//
// NOTE: Distinct edges in the web MUST be assigned disjoint sets of variables!

/////////////////////////////////////////////////
// DATA TYPE: compilation strategy
//
// Compilation of a web means taking the tensor product over all MFs in the
// web and pushing forward to the ring with all internal variables in the web
// deleted. A compilation strategy represents one way of effecting this pushforward
// in practice.
//
// Precisely, a compilation strategy consists of a pair (L1,L2), where
// L1 is a permutation of the set {1,...,V} and L2 is a list
// containing each internal variable in the web precisely once. The idea is that L1 tells
// us the order in which to tensor the MFs in the web together (for example, if
// L1 were 3,1,2 we should first tensor the MF at vertex 3 with the one at vertex 1,
// and then tensor the result with the MF at vertex 2) and L2 tells us the ordering
// on the variables to use in the reduction/pushforward procedure.

/////////////////////////////////////////////////
// Settor and Accessor methods for an edge.
//
// The point of these being that if we change the structure of the lists underlying
// an edge, or web, then we only need change the following routines.

proc edgeSource(list edge){ return(edge[1]); }
proc edgeTarget(list edge){ return(edge[2]); }
proc edgeVariables(list edge){ return(edge[3]); }
proc edgePotential(list edge){ return(edge[4]); }
proc augedgePowers(list augedge){ return(augedge[5]); }
proc augedgeTransform(list augedge){ return(augedge[6]); }
proc setEdgeSource(list edge, int src){ edge[1] = src; return(edge); }
proc setEdgeTarget(list edge, int tar){ edge[2] = tar; return(edge); }
proc setEdgeVariables(list edge, list var){ edge[3] = var; return(edge); }
proc setEdgePotential(list edge, poly W){ edge[4] = W; return(edge); }
proc isEdgeBetweenVertices(list edge, int v1, int v2)
{
    if( edgeSource(edge) == v1 && edgeTarget(edge) == v2 ){ return(1); }
    if( edgeSource(edge) == v2 && edgeTarget(edge) == v1 ){ return(1); }
    return(0);
}

// NOTE: augmentedEdgeForEdge breaks the setter/getter barrier.

/////////////////////////////////////////////////
// Settor and Accessor methods for a web.

proc webSize(list web){ return(web[1]); }
proc webEdges(list web){ return(web[2]); }
proc webMFs(list web){ return(web[3]); }
proc webMFatVertex(list web, int vertex){ return(web[3][vertex]); }
proc webMFgr(list web){ return(web[4]); }
proc webMFgratVertex(list web, int vertex){ return(web[4][vertex]); }
proc webIsGraded(list web){ int t = (size(web) == 4); return(t); }

/////////////////////////////////////////////////
// Basic methods for vertices

proc vertexVariables(list web, int vertex)
{
    list vars;
    list edgeList = webEdges(web);
    
    int i;
    for(i = 1; i <= size(edgeList); i++)
    {
        list edge = edgeList[i];
        if( edgeSource(edge) == vertex || edgeTarget(edge) == vertex )
        {
            vars = vars + edgeVariables(edge);
        }
        kill edge;
    }
    
    kill edgeList;
    return(vars);
}

/////////////////////////////////////////////////
// vertexIncomingEdges
//
// Return a list (possibly empty) of indices into
// the array of edges giving those edges with target
// the given vertex (possibly the boundary 0).

proc vertexIncomingEdges(list web, int vertex)
{
    list eList;
    list edgeList = webEdges(web);
    
    int i;
    for(i = 1; i <= size(edgeList); i++ )
    {
        list edge = edgeList[i];
        if( edgeTarget(edge) == vertex )
        {
            eList = eList + list(i);
        }
        kill edge;
    }
    
    return(eList);
}

proc vertexOutgoingEdges(list web, int vertex)
{
    list eList;
    list edgeList = webEdges(web);
    
    int i;
    for(i = 1; i <= size(edgeList); i++ )
    {
        list edge = edgeList[i];
        if( edgeSource(edge) == vertex )
        {
            eList = eList + list(i);
        }
        kill edge;
    }
    
    return(eList);
}

proc vertexPotential(list web, int vertex)
{
    poly W;
    list edgeList = webEdges(web);
    
    int i;
    for(i=1; i <= size(edgeList); i++ )
    {
        list edge = edgeList[i];
        int nc;
        
        if( edgeSource(edge) == vertex ){ nc = 1; }
        if( edgeTarget(edge) == vertex ){ nc = -1; }
        
        W = W + nc * edgePotential(edge);
        
        kill edge;
    }
    
    return(W);
}

/////////////////////////////////////////////////
// ringWithoutVars
//
// Given a set of variables in the ring, returns
// the ring with those variables deleted (but otherwise
// preserved, for example parameters). We do NOT change
// the current basering. Note that vars should be a list
// of polynomials, not strings.

proc ringWithOnlyVars(list vars)
{
    list exvars;
    int i;
    for(i=1; i<=nvars(basering); i++)
    {
        if( !checklist(vars,var(i)) )
        {
            exvars = exvars + list(var(i));
        }
    }
    
    def nR = ringWithoutVars(exvars);
    return(nR);
}

proc ringWithoutVars(list vars)
{
    if( size(vars) == nvars(basering) )
    {
        print("[ringWithoutVars] Asked to create a ring with no variables, exiting.");
        return(0);
    }
    
    def SSS = basering;
    list rlist = ringlist(SSS);
    list newVar;
    
    // Go through and form newVar = current variables minus vars
    int i;
    for(i = 1; i <= size(rlist[2]); i++)
    {
        int found = 0;
        int j;
        for(j = 1; j <= size(vars); j++ )
        {
            if( string(vars[j]) == rlist[2][i] )
            {
                found = 1;
                break;
            }
        }
        
        if( !found ){ newVar = newVar + list(rlist[2][i]); }
    }
    
    list newringList = rlist;
    newringList[2] = newVar;

    // Fix the variable weighting
    intvec kk = (1..size(newVar));
    for(i=1; i<=size(newVar); i++)
    {
        kk[i] = 1;
    }
    newringList[3][1][2] = kk;
    kill kk;
    
    int useParameter;
    if( defined(minpolyblow) && defined(r) )
    {
        newringList[1][4][1] = 0;     // set minpoly to zero, put it back to the right value below...
        useParameter = 1;
    }
    
    // Create our new ring
    def nR = ring(newringList);
    kill rlist, newringList;
    
    // Now complete the correct definition of nR by specifying the right minpoly: 
    if( useParameter )
    {
        setring nR;
        
        // Note that fetch uses the position of the ring variables, not the name, so 
        // that fetch(var(1)) is always var(1).
        poly P = fetch(SSS,minpolyblow); 
        poly z = subst(P,var(1),r);
        number nu = leadcoef(z);
        minpoly = nu;
        setring SSS;
    }
    
    return(nR);
}

/////////////////////////////////////////////////
// augmentedEdgeForEdge
//
// Given an edge, creates an associated augmented edge

proc augmentedEdgeForEdge(list edge)
{
    int powerCutoff = blowFlags("power_cutoff_jacobi"); 
    int useSanityChecks = blowFlags("sanity_checks");
    
    // Recall that an edge has the format (S,T,L,W) and an augmented edge has the format
    // (S,T,L,W,B,C) where B is an intvec and C a matrix.
    
    // First change ourselves into the ring with only the variables present on the given edge    
    def RRR = basering;
    def nR = ringWithOnlyVars(edgeVariables(edge));
    setring nR;

    // Note it's important that we respect the order of the variables in the edge, NOT
    // the natural ordering in the ring.
    list edge = imap(RRR,edge);
    list augEdge = edge;
    
    list L = edgeVariables(edge);
    poly W = edgePotential(edge);
    
    // Build the Jacobi ideal
    ideal J;
    int i;
    for(i=1; i <= size(L); i++)
    {
        J[i] = diff(W,L[i]);
    }
    ideal Jstd = std(J);
    
    list B;
    matrix C;
    for(i=1; i <= size(L); i++)
    {
        // Find a power of the variable va belonging to the ideal generated by the partials of W
        poly va = L[i];
        
        int p;
        int power = 0;
        
        for(p=1; p <= powerCutoff; p++)
        {
            if( reduce(va^p, Jstd) == 0 )
            {
                //print(string(va) + " to the power " + string(p) + " belongs to J"); //debug
                power = p;
                B[i] = p;
                matrix T = lift(J, va^p);
                
                if( ncols(T) != 1 || nrows(T) != size(J) )
                {
                    print("[augmentedEdgeForEdge] Something wrong with the lift, exiting.");
                    return(0);
                }
                
                if( i == 1 )
                {
                    C = T;
                }
                else
                {
                    C = concat(C,T);
                }
                
                break;
            }
        }
        
        if( power == 0 )
        {
            print("[augmentedEdgeForEdge] Failed to find power of variable in Jacobi ideal, exiting.");
            return(0);
        }
    }
    augEdge[5] = B;
    augEdge[6] = C;
    setring RRR;
    list augEdge = imap(nR, augEdge);
    ideal J = imap(nR,J);
    
    // Perform sanity check
    if( useSanityChecks )
    {
        matrix Q = matrix(J) * augEdge[6];
        list edgeVar = edgeVariables(edge);
        
        int i;
        for(i=1; i <= size(edgeVar); i++)
        {
            if( Q[1,i] != edgeVar[i]^(augEdge[5][i]) )
            {
                print("[augmentedEdgeForEdge] Failed to correct compute augmented edge correctly, exiting.");
                return(0);
            }
        }
    }
    
    return(augEdge);
}

/////////////////////////////////////////////////
// isEdgeInternal

proc isEdgeInternal(list edge)
{
    if( edgeSource(edge) != 0 && edgeTarget(edge) != 0 )
    {
        return(1); 
    }
    
    return(0);
}

/////////////////////////////////////////////////
// webVariables
//
// Returns the list consisting of all variables lying
// on all edges in the web.

proc webVariables(list web)
{
    list edgeList = webEdges(web);
    list vars;
    
    int i;
    for(i=1; i<=size(edgeList); i++)
    {
        list edge = edgeList[i];
        vars = vars + edgeVariables(edge);
        kill edge;
    }
    
    kill edgeList;
    
    return(vars);
}

/////////////////////////////////////////////////
// subwebWithVertices
//
// Returns the subweb consisting of the given vertices in the original web
// together with all edges adjacent to those vertices, EVEN THOSE ENDING ON
// VERTICES NOT IN THE LIST. If an edge begins or ends on a vertex in our
// list, but does not end (resp. begin) on a vertex in our list (or 0, which
// is implicitly in every subweb) then we consider it to have ended or begun
// on the boundary; so that in forming the subweb we "shrink" the boundary until
// it cuts across all edges going outside our set of vertices.
//
// NOTE: You should not pass 0 as a vertex to any routines.

proc subwebWithVertices(list web, list vertices)
{
    int useSanityChecks = blowFlags("sanity_checks");
    
    if( size(vertices) == 0 )
    {
        print("[subwebWithVertices] Given no vertices in list, exiting.");
        return();
    }
    
    int useGrading = webIsGraded(web);
    
    // The easy part is building the list of MFs and gradings, so let us do that first
    list MFlist = webMFs(web);
    if( useGrading ){ list MFgrlist = webMFgr(web); }
    list subMFlist;
    if( useGrading ){ list subMFgrlist; }
    
    int i;
    for(i=1; i<=size(vertices); i++)
    {
        subMFlist = subMFlist + list(MFlist[vertices[i]]);
        if( useGrading ){ subMFgrlist = subMFgrlist + list(MFgrlist[vertices[i]]); }
    }
    
    // Now we need to build up the edges. First of all we discard any edges not
    // beginning or ending at one of the vertices in our list.
    // Then in each of these edges replace the integer vertices[i] by i.
    
    list edgeList = webEdges(web);
    list subEdgeList;
    
    for(i=1; i<=size(edgeList); i++)
    {
        list edge = edgeList[i];
        if( checklist(vertices,edgeSource(edge)) || checklist(vertices,edgeTarget(edge)) )
        {
            // Add this edge to our list. The only modification we make is to set 
            // the source or target to 0 if it was previously a vertex not in our list
            if( !checklist(vertices,edgeSource(edge)) )
            {
                edge = setEdgeSource(edge, 0);
            }
            
            if( !checklist(vertices,edgeTarget(edge)) )
            {
                edge = setEdgeTarget(edge, 0);
            }
            
            subEdgeList = subEdgeList + list(edge);
        }
        kill edge;
    }
    
    list finalEdgeList;
    
    // Now go through and modify all the edges in subEdgeList.
    int j;
    for(j=1; j<=size(subEdgeList); j++)
    {
        list edge = subEdgeList[j];
        int fixedSource;
        int fixedTarget;
        for(i=1; i<=size(vertices); i++)
        {
            
            if( edgeSource(edge) == vertices[i] && !fixedSource )
            {
                edge = setEdgeSource(edge, i);
                
                // After we change the source, in a later i iteration a
                // vertex could recognise us as having them as the source,
                // so to avoid this we use a flag.
                fixedSource = 1;
            }
            
            if( edgeTarget(edge) == vertices[i] && !fixedTarget )
            {
                edge = setEdgeTarget(edge, i);
                fixedTarget = 1;
            }
            
        }
        finalEdgeList = finalEdgeList + list(edge);
        kill edge;    
    }
    kill subEdgeList;
    
    list subweb = size(vertices), finalEdgeList, subMFlist;
    kill finalEdgeList, subMFlist;    
    if( useGrading ){ subweb = subweb + list(subMFgrlist); kill subMFgrlist; }
    
    if( useSanityChecks )
    {
        if( !webVerifyGeneral(subweb) )
        {
            print("[subwebWithVertices] Produced invalid subweb, exiting.");
            return();
        }
    }
    
    return(subweb);
}

/////////////////////////////////////////////////
// webVerify
//
// Verify that the given list satisfies (some of) the conditions to be a web.

proc webVerifyGeneral(list web)
{
    int useGrading = webIsGraded(web);
    int numVertices = webSize(web);
    
    if( numVertices != size(webMFs(web)) )
    {
        print("[webVerify] There is size mismatch between vertices and MFs, failed.");
        return(0);
    }
    
    int i;
    for( i=1; i<=numVertices; i++ )
    {
        matrix A = webMFatVertex(web, i);
        poly W = vertexPotential(web, i);
        if( useGrading ){ intvec Agr = webMFgratVertex(web, i); }
        
        if( size(vertexIncomingEdges(web,i)) + size(vertexOutgoingEdges(web,i)) == 0 )
        {
            print("[webVerify] Vertex " + string(i) + " is isolated, failed.");
            return(0);
        }
        
        // Is A a MF of this potential?
        if( A * A != W * unitmat(ncols(A)) )
        {
            print("[webVerify] At vertex " + string(i) + " the MF does not factorise the local potential W=" + string(W) + ", failed.");
            return(0);
        }
        
        // Is A a graded MF?
        if( useGrading )
        {
            if( !isGradingValid(A, Agr) )
            {
                print("[webVerify] At vertex " + string(i) + " the grading is not valid, failed.");
                return(0);
            }
        }
    }
    
    return(1);
}

/////////////////////////////////////////////////
// webCompilePairGeneral
//
// The backbone of our compilation routines. We are given a web with only
// two vertices and a compilation strategy. Next we describe the output in
// the standard case, but be aware there is an important special case to be
// explained at the end.
//
// We first return a matrix factorisation in the set of external variables
// of the total potential of the given web. Let X denote the tensor product
// over all vertices of the associated MFs, defined in the ordering determined
// by our compilation strategy. Let pX denote the pushforward/restriction of
// scalars to the ring with all internal variables in the web deleted. Our
// first return value is the differential of a MF Y homotopy equivalent to pX.
//
// The second return value is the grading vector for Y, if we are using gradings.
//
// The third (or second, if there is no grading) return value is a list
// R = (F1,G1,x1,exp1),(F1,G2,x2,exp2),... whose length is equal to the number of
// internal variables in the web. These are the maps returned by mfPushforwardInductive
// applied to the set of internal variables ordered according to our compilation strategy.
//
// In more detail: let p1X denote the pushforward of X just to the ring without the
// "first" internal variable, where "first" means first in the compilation strategy.
// This is a direct summand of Xblow[1], and (F1,G1) is a pair splitting, in the
// homotopy category of finite rank MFs, the corresponding idempotent. Say the
// splitting is Y1. Then F1: Xblow[1] -> Y1 and G1: Y1 -> Xblow[1] with F1 * G1 = 1
// and G1 * Y1 the idempotent corresponding to p1X.
//
// Next, we push forward Y1 to the ring without the first and second internal variables,
// and the same yoga produces maps (F2,G2) splitting an idempotent on Y1blow[1], etc.
//
// This list R is referred to as a "splitting record".
//
// NOTE: Special case
//
// If the total potential of the web is zero, and if in the last step of the compilation
// process we end up with non-square matrices (may not happen) then it is not safe to
// return the differential on Y (it will not be square) so our return list looks like
//
// "nonsquare", [r1,r2,] R
//
// where r1,r2 are grading vectors on the even and odd parts of Y resp. (if we are
// using the grading) and R is as described above, but where the last (F,G,x,exp) pair is
// a tuple f0,f1,g0,g1,x,exp with f0,g0 splitting the even part of the very last idempotent
// and similarly for f1,g1.

proc webCompilePairGeneral(list web, list compStrat)
{
    int useSanityChecks = blowFlags("sanity_checks");
    int useGrading = webIsGraded(web);
    
    if( useSanityChecks )
    {
        if( !webVerifyGeneral(web) )
        {
            print("[webCompilePairGeneral] Given web is not valid, exiting.");
            return();
        }
        
        if( webSize(web) != 2 )
        {
            print("[webCompilePairGeneral] We only compile pairs. Duh. Exiting.");
            return();
        }
    }
    
    // Extract the content of the web
    int numVertices = webSize(web);
    list edgeList = webEdges(web);
    list mfList = webMFs(web);
    if( useGrading ){ list mfGradings = webMFgr(web); }
    
    // And the compilation strategy
    list vertexOrder = compStrat[1];
    list varOrder = compStrat[2];
    
    if( size(vertexOrder) != 2 )
    {
        print("[webCompilePairGeneral] We only compile pairs, exiting.");
        return();
    }
    
    // Order the vertices according to the compilation strategy
    int i;
    for(i=1;i<=2;i++)
    {
        matrix mf(i) = mfList[vertexOrder[i]];
        if( useGrading ){ intvec mfgr(i) = mfGradings[vertexOrder[i]]; }
    }
    
    // Our task is to build up the input to mfPushforwardInductive and
    // then interpret its output.
    matrix A = MFtensor( mf(1), mf(2) );
    if( useGrading ){ intvec Agr = MFtensorGradings( mfgr(1), mfgr(2) ); }
    
    // Build up a list of the internal variables, ordered according to the
    // compilation strategy, a list of powers and a list of homotopies. The
    // powers we collect are the powers of the variables which act null-homotopically
    // on A, with associated homotopies stored in H.
    
    // NOTE: As opposed to the original webCompile, we have to work a little harder
    // to get our homotopies, since a priori we only know that certain partial
    // derivatives of the potentials on edges annihilate, via partial derivatives of
    // suitable differentials, and we have to convert these to null-homotopies of 
    // powers of the internal variables using augmentedEdgeForEdge, which tells us 
    // which powers of the variables on an edge can be written in terms of the partial
    // derivatives of the potential on the edge.
    
    list augEdgeList;
    for(i=1; i<=size(edgeList); i++)
    {
        list edge = edgeList[i];
        list augEdge = augmentedEdgeForEdge(edge);
        augEdgeList = augEdgeList + list(augEdge);
        kill augEdge, edge;
    }
    
    list intvars;
    list varPowers;
    list Hlist;
    
    for(i=1;i<=size(varOrder);i++)
    {
        poly u = varOrder[i];
        //dbprint(printlevel, "[webCompilePairGeneral] Integrating out internal variable " + string(u)); // debug
        
        // Find out which edge this variable lies on
        int j;
        for(j=1; j<=size(edgeList); j++)
        {
            list edge = edgeList[j];
            list augEdge = augEdgeList[j];
            
            if( checklist(edgeVariables(edge), u) )
            {
                // Yes, u does lie on this edge
                if( !isEdgeInternal(edge) )
                {
                    print("[webCompilePairGeneral] Internal variable lying on external edge, exiting.");
                    print(edge);
                    return();
                }
                
                intvars = intvars + list(u);
                
                poly W = edgePotential(edge);
                int src = edgeSource(edge);
                list varList = edgeVariables(edge);
                list B = augedgePowers(augEdge);
                matrix C = augedgeTransform(augEdge);
                matrix D = mfList[src];
                
                // Find out where in varList u occurs
                int k;
                int uPos;
                for(k=1; k<=size(varList); k++)
                {
                    if( varList[k] == u )
                    {
                        uPos = k;
                        break;
                    }
                }
                
                // Note that D factorises some potential W' with W as a summand, and that
                // for any variable x in the list varList, i.e. a variable on edge, the
                // variable x only occurs in W' as part of W. Hence if we take the
                // partial derivative of D * D = W' we find that
                //
                //   diff(D,x) * D + D * diff(D,x) = diff(W,x).
                //
                // If we sum over the different variables and multiply by the appropriate
                // factors in C, then on the right hand side we have a power of u.
                
                // Recall that by construction
                //
                // u^B[uPos] = C[uPos,1] * diff(W,varList[1]) + ... + C[uPos,n] * diff(W,varList[n]).
                
                matrix H[nrows(D)][ncols(D)];
                for(k=1; k<=size(varList); k++)
                {
                    matrix h = diff(D,varList[k]);
                    
                    if( h * D + D * h != diff(W,varList[k]) * unitmat(ncols(D)) )
                    {
                        print("[webCompilePairGeneral] Inner homotopy construction failure, exiting.");
                        return();
                    }
                    
                    H = H + C[uPos,k] * h;
                    kill h;
                }
                
                // Convert this from a homotopy on D to a homotopy on A
                if( vertexOrder[1] == src )
                {
                    H = ZZtensor( H, unitmat(ncols(mf(2))) );
                }
                else
                {
                    H = ZZtensor( unitmat(ncols(mf(1))), H );
                }
                
                if( useSanityChecks )
                {
                    if( H * A + A * H != u^(B[uPos]) * unitmat(ncols(A)) )
                    {
                        print("[webCompilePairGeneral] Homotopy construction failure, exiting.");
                        return();
                    }
                }
                
                varPowers = varPowers + list(B[uPos]);
                Hlist = Hlist + list(H);
                kill W, src, B, H, varList;
            }
            
            kill edge, augEdge;
        }
    }
    
    // Now we feed all this to mfPushforwardInductive
    if( !useGrading )
    {
        list L = mfPushforwardInductive(A, intvars, varPowers, Hlist);
    }
    else
    {
        list L = mfPushforwardInductive(A, intvars, varPowers, Hlist, Agr);
    }
    kill A, intvars, varPowers, Hlist;
    
    return(L);
}

/////////////////////////////////////////////////
// webCompile
//
// Given a web and compilation strategy we crawl the web, fusing
// vertices in the order dictated by the strategy using mfCompilePairGeneral.
// Our first output is the differential on the compiled MF Y, h.e. to the pushforward
// of the tensor product of all the MFs in the web to the ring without any of the internal
// variables.
//
// If grading is in use, then the second return is the grading vector on this Y.
//
// The third (or second, if grading is not in use) return value is a list Q, which we
// refer to as the "splitting record". Suppose that we write X1, .., Xv for the MFs lying
// at the vertices in our web, ordered according to the compilation strategy. Let
// X1 # X2 denote the result of tensoring X1,X2 and replacing this by a finite rank MF
// homotopy equivalent to the pushforward which eliminates the variables lying between
// vertices 1,2. This reduction generates a splitting record R1 (as defined above) and the
// pair (X1 # X2, R1) is the first entry in the list Q (or (X1 # X2, gr, R1) if we are 
// in the graded setting, gr being the grading vector on X1 # X2).
//
// The second entry in Q is ((X1 # X2) # X3, R2) where R2 is the splitting record of the
// second fusion. All fusions being conducted according to the given compilation strategy.
// The last entry in Q is (Y,Ygr,R?), i.e. we repeat the differential, grading of Y but
// in addition there is the splitting record of the reduction which produced Y.
//
// NOTE: Special case
//
// If the total potential of the web is zero, and if in the last step of the compilation
// process we end up with non-square matrices (may not happen) then it is not safe to
// return the differential on Y (it will not be square) so our return list looks like
//
// "nonsquare", [r1,r2,]  Q
//
// where r1,r2 are grading vectors on the even and odd parts of Y resp. (if we are
// using the grading) and Q is the global splitting record. The last entry in Q is
// a tuple ("nonsquare",[r1,r2,],R) with the last entry of R a tuple (f0,f1,g0,g1,u,NN)
// with f0,g0 splitting the even part of the very last idempotent and similarly for f1,g1.

proc webCompileGeneral(list web, list compStrat)
{
    int useSanityChecks = blowFlags("sanity_checks");
    int useGrading = webIsGraded(web);
    
    system("--ticks-per-sec",1000);
    int timeElapsed = timer;
    
    if( useSanityChecks )
    {
        if( !webVerifyGeneral(web) )
        {
            print("[webCompileGeneral] Given web is not valid, exiting.");
            return();
        }
    }
    
    def RRR = basering;
    int count = 1;
    def nR(1) = basering;
    list splittingRecord;
    int numInternalVar = size(compStrat[2]);
    
    // Continue fusing until there are no internal variables left. Each time through the
    // loop we will have deleted some internal variables from our current ring and have
    // changed the web and strategy to reflect the fusion of two vertices in the old web.
    // Recall that compStrat[2] is an ordered list of the internal variables.
    int numVertices;
    
    while( numInternalVar > 0 )
    {
        // Our current ring is nR(count)
        dbprint(printlevel, "[webCompileGeneral] Entering round " + string(count) + " of compilation.");
        
        // web is being modified each time through the loop, so update our "pointers"
        numVertices = webSize(web);
        list edges = webEdges(web);
        list mfs = webMFs(web);
        if( useGrading ){ list webGr = webMFgr(web); }
                
        // compStrat is also modified at each step
        list vertexOrder = compStrat[1];
        list varOrder = compStrat[2];
        
        if( size(vertexOrder) < 2 )
        {
            print("[webCompileGeneral] vertexOrder has impossible size, exiting.");
            return();
        }
        
        // Construct a subweb and substrategy consisting of the first two vertices to be fused
        list subweb = subwebWithVertices(web, list(vertexOrder[1],vertexOrder[2]));
        list subwebVar = webVariables(subweb);
        list substrat_var;
        
        // Intersect the variables in varOrder with the list of internal vars in the subweb
        int i;
        for(i=1; i<=size(varOrder); i++) 
        {
            poly u = varOrder[i];
            
            int j;
            for(j=1; j<=size(edges); j++)
            {
                list e = edges[j];
                if( checklist(edgeVariables(e),u) && isEdgeBetweenVertices(e,vertexOrder[1],vertexOrder[2]) )
                {
                    substrat_var = substrat_var + list(varOrder[i]);
                    break;
                }
                kill e;
            }
            kill u;
        }
        
        list substrat = list(list(1,2), substrat_var);
        
        // Change to the ring containing only those variables involved in this fusion
        def tempring = ringWithOnlyVars(subwebVar);
        kill subwebVar;
        
        ///////// BEGIN tempring //////////
        setring tempring;
        list subweb = imap(nR(count),subweb);
        list substrat = imap(nR(count),substrat);
            ////// IMPORTANT
            list l = webCompilePairGeneral(subweb, substrat);
            ////////////////
        kill subweb, substrat;
        setring nR(count);
        kill subweb, substrat;
        ///////// END tempring ///////////
        
        list l = imap(tempring, l);
        kill tempring;
        
        if( typeof(l[1]) == "string" )
        {
            // This is the case where webCompilePairGeneral produced non-square matrices. This
            // must be our last step, and l looks like
            //
            // "nonsquare", [r1,r2,] R
            //
            // where r1,r2 are grading vectors on the even and odd parts of Y resp. (if we are
            // using the grading) and R is the splitting record, but where the last (F,G) pair in R is
            // a tuple (f0,f1,g0,g1) with f0,g0 splitting the even part of the very last idempotent
            // and similarly for f1,g1.
        
            //dbprint(printlevel, "[webCompile] Hit nonsquare matrices, wrapping it up.");
        
            kill numVertices, edges, mfs, vertexOrder, varOrder;
            if( useGrading ){ kill webGr; }
        
            setring RRR;
            
            // The first time through nR(1) = RRR so there is no need for imap
            if( count > 1 )
            {
                list l = imap(nR(count),l);
            }
            
            kill nR(count);
            list retlist;
            retlist[1] = "nonsquare";
            if( useGrading ){ retlist = retlist + list(l[2],l[3]); }
            splittingRecord = splittingRecord + list(l);
            retlist = retlist + list(splittingRecord);

            dbprint(printlevel, "[webCompile] total elapsed time " + string(timer-timeElapsed) + "ms.");

            if( useGrading )
            {
                dbprint(printlevel, "[webCompile] even grading: " + string(l[2]));
                dbprint(printlevel, "[webCompile]  odd grading: " + string(l[3]));
            }
            kill l, splittingRecord;

            return(retlist);
        }
        
        // The return from webCompilePair is (newvertex [,g], R) where newvertex is the
        // differential on a MF and g is a possible grading vector, R is the splitting record.
        // First we return to RRR and adjoin R to the global splitting record
        setring RRR;
        
            // The first time through nR(1) = RRR so there is no need for imap
            if( count > 1 )
            {
                list l = imap(nR(count),l);
            }
        
            splittingRecord = splittingRecord + list(l);
            
        setring nR(count);
        
        // Now do some engineering on our web. We need to replace the first two vertices
        // by their fusion, and rearrange variables and the compilation strategy accordingly
        // Making the new list of MFs and gradings is easy, so we do that first
        
        // 1. List of matrices
        list fusedWebMfs = mfs;
        fusedWebMfs[vertexOrder[1]] = l[1];
        fusedWebMfs = delete(fusedWebMfs,vertexOrder[2]);
        
        // 2. Gradings
        if( useGrading )
        {
            list fusedWebGr = webGr;
            fusedWebGr[vertexOrder[1]] = l[2];
            fusedWebGr = delete(fusedWebGr,vertexOrder[2]);
        }
        
        // 3. Edges. Remove all squeezed out internal edges, and redirect
        // other edges which end or begin at vertexOrder[2] so that they
        // now end or begin resp. at vertexOrder[1].

        int i;
        list fusedEdges;
        for(i=1; i<=size(edges); i++)
        {
            list e = edges[i];
            
            // Exclude edges which where squeezed out
            if( !isEdgeBetweenVertices(e,vertexOrder[1],vertexOrder[2]) )
            {
                list newEdge = e;
                
                if( edgeSource(newEdge) == vertexOrder[2] )
                {
                    newEdge = setEdgeSource(newEdge, vertexOrder[1]);
                }
                
                if( edgeTarget(newEdge) == vertexOrder[2] )
                {
                    newEdge = setEdgeTarget(newEdge, vertexOrder[1]);
                }
            
                // Finally, if the edge begins or ends on a vertex appearing after
                // vertexOrder[2] we need to decrement the index, as the fused web
                // has one less vertex and all indices shifted
                if( edgeSource(newEdge) > vertexOrder[2] )
                {
                    newEdge = setEdgeSource(newEdge, edgeSource(newEdge) - 1);
                }
                
                if( edgeTarget(newEdge) > vertexOrder[2] )
                {
                    newEdge = setEdgeTarget(newEdge, edgeTarget(newEdge) - 1);
                }
                
                fusedEdges = fusedEdges + list(newEdge);
                kill newEdge;
            }
        }
        
        list fusedWeb = numVertices - 1, fusedEdges, fusedWebMfs;
        kill fusedEdges, fusedWebMfs;
        if( useGrading ){ fusedWeb = fusedWeb + list(fusedWebGr); kill fusedWebGr; }
        
        if( useSanityChecks )
        {
            if( !webVerifyGeneral( fusedWeb ) )
            {
                print("[webCompileGeneral] Fused web is not valid, exiting.");
                return();
            }
        }
        
        // Next we rearrange the compilation strategy. The vertices is simple: we have
        // replaced the first vertex in the strategy by the fusion, so we just drop the
        // second entry of vertexOrder
        list fusedVertexOrder = delete(vertexOrder,2);
        
        for(i=1;i<=size(fusedVertexOrder);i++)
        {
            if( fusedVertexOrder[i] > vertexOrder[2] )
            {
                fusedVertexOrder[i] = fusedVertexOrder[i] - 1;
            }
        }
        
        list fusedVarOrder;
        
        // Our new set of internal variables is the old one with all the variables we
        // squeezed out removed. Note that here is where we update numInternalVar
        int i;
        for(i=1;i<=size(varOrder);i++)
        {
            poly u = varOrder[i];

            if( !checklist(substrat_var,u) )
            {
                fusedVarOrder = fusedVarOrder + list(u);
            }
            else
            {
                // u is an internal variable which was squeezed out, so
                // reduce our internal variable count appropriately
                numInternalVar--;
            }
            
            kill u;
        }
        
        list fusedStrat = list(fusedVertexOrder, fusedVarOrder);
        kill fusedVertexOrder, fusedVarOrder;
        
        // Now we go to the ring nR(count+1), which is nR(count) with the internal
        // variables that we just squeezed out removed. Recall that substrat_var
        // contains a list of these variables.
        def nR(count+1) = ringWithoutVars(substrat_var);

        // Do some kills before switching rings. All we need to keep are fusedWeb
        // and fusedStrat
        kill substrat_var;        
        kill edges, mfs, vertexOrder, varOrder;
        if( useGrading ){ kill webGr; }
        
        setring nR(count+1);
        
        list web = imap(nR(count),fusedWeb);
        
        // If the number of internal variables is zero, then fusedStrat is not defined
        // in nR(count) but rather is just a global, since it contains no ring variables
        if( numInternalVar > 0 )
        {
            list compStrat = imap(nR(count),fusedStrat);
        }
        else
        {
            list compStrat = fusedStrat;
        }
        kill nR(count);
        
        // Increment the counter, get ready to go again!
        count++;
    }
    
    // We exited after exhausting our internal variables, with valid web and compStrat.
    // So the first entry in the mfs list of web is our final answer
    setring RRR;
    list web = imap(nR(count),web);
    kill nR(count);
    
    matrix A = webMFatVertex(web,1);
    list retlist = A;
    kill A;
    
    if( useGrading )
    {
        intvec Agr = webMFgratVertex(web,1);
        retlist = retlist + list(Agr);
        kill Agr;
    }
    
    retlist = retlist + list(splittingRecord);
    kill splittingRecord;
    dbprint(printlevel, "[webCompileGeneral] total elapsed time " + string(timer-timeElapsed) + "ms.");
    
    return(retlist);
}

/////////////////////////////////////////////////
// webFromLink
//
// Given a link in the format described in linkhom.lib, and an intvec
// giving a "state', i.e. assigning 0 or 1 to every vertex, we return
// the corresponding web (in the general format of this file).

proc webFromLink(list linkData, intvec state, int N)
{
    intvec vertexParity = linkData[1];
    list edgeList = linkData[2];
    
    int numVertices = size(edgeList);
    
    // Each edge in the link is a list of four integers. The first two are incoming,
    // and the second two are outgoing. Every edge in a web coming from a link has
    // a single variable with exponent N+1, so we can already populate some of the
    // information on each edge
    int i,j;
    list edges;
    
    // Loop through vertices
    for(j=1; j<=numVertices; j++)
    {
        // Loop through entries of vertex
        intvec v = edgeList[j];
        for(i=1; i<=4; i++)
        {
            list edge;
            if( typeof(edges[v[i]]) == "none" )
            {
                // This edge hasn't been created yet
                edge = 0,0,list(var(v[i])),var(v[i])^(N+1);
            }
            else
            {
                edge = edges[v[i]];
            }
            
            if( i <= 2 )
            {
                // This edge begins at this vertex, set the source
                edge = setEdgeSource(edge, j);
            }
            else
            {
                // This edge ends at this vertex, set the target
                edge = setEdgeTarget(edge, j);
            }
            
            edges[v[i]] = edge;
            kill edge;
        }
        kill v;
    }
    
    // Now build the list of MFs and gradings
    list webMfs;
    list webMfsGrading;

    for(j=1; j<=numVertices; j++)
    {
        intvec e = edgeList[j];
    
        matrix X = mfVertex(state[j], list(var(e[1]),var(e[2]),var(e[3]),var(e[4])), N);
        intvec Xgr = mfVertexGrading(state[j], N);
    
        webMfs = webMfs + list(X);
        webMfsGrading = webMfsGrading + list(Xgr);
        kill X,e,Xgr;
    }

    // Define the web
    list web = numVertices, edges, webMfs, webMfsGrading;
    
    if( !webVerifyGeneral(web) )
    {
        print("[webFromLink] Failed to construct valid web, exiting.");
        return();
    }
    
    return(web);
}