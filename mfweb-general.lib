version="0.1";
category="Miscellaneous";
// summary description of the library
info="
LIBRARY:   mfweb-general.lib  Compilation of defect webs
AUTHOR:    Nils Carqueville, Daniel Murfet
KEYWORDS:  matrix factorization

PROCEDURES:
";

LIB "linalg.lib";
LIB "matrix.lib";
LIB "ring.lib";
LIB "blow.lib";
LIB "linkhom.lib";
LIB "mfweb.lib";

////////////////////////////////////////////////////////////////////
// USAGE GUIDE
//
// A web is an oriented graph where edges are allowed to begin or end, but not
// both, on some unspecified "boundary". All edges are labelled with a set of variables
// and a potential, and every vertex is assigned a matrix factorisation
// of the sum of all the "outgoing" potential minus the sum of all the incoming
// potentials. There must be at least one variable on each edge, disjoint variables
// on distinct edges, and potentials must have isolated singularities. Throughout
// comments in this file, V denotes the total number of vertices in the web (always >0)
// We implicitly order the vertices and consider them as elements in the set {1,...,V}.
//
// WARNING: We do not allow isolated vertices, with no incoming or outgoing vertices.
// The ordering of the variables in L1 and L2 may matter.

////////////////////////////////////////////////////////////////////
// USAGE GUIDE: parameters
//
// We allow rings of the form (0,r),(variables),dp where r is a parameter.
// If this is an algebraic extension with minimum polynomial "minpoly" then 
// there should also be defined a polynomial minpolyblow, in the first ring variable
// var(1), equal to substituting var(1) for r in minpoly.

/////////////////////////////////////////////////
// DATA TYPE: edge
//
// An edge is a list (S,T,L,W) where S,T are integers in the range 0,...,V, L is a
// nonempty list of variables in the ring, and W is a polynomial in the variables
// present in L. Here S, T are the indices, respectively of the "S"ource and "T"arget
// of the edge, where "0" stands for the boundary.

/////////////////////////////////////////////////
// DATA TYPE: augmented edge
//
// An augmented edge is a list (S,T,L,W,B,C) where (S,T,L,W) is an edge, B is an intvec
// of size n = size(L), and C is a nxn matrix of polynomials such that for each i
// between 1 and n = |L|, we have
//
//      L[i]^B[i] = C[i,1] * diff(W,L[1]) + ... + C[i,n] * diff(W,L[n]).
//
// The existence of such integers B[i] and polynomials C[i,j] follows from the assumption
// that W defines an isolated singularity, hence the partial derivatives of W generate an
// ideal primary for the ideal generated by all the variables on the edge.

/////////////////////////////////////////////////
// TERMINOLOGY
//
// We say that a variable is "adjacent" at a vertex if the variable lies on an edge
// adjacent to the vertex. A variable is "external" if it lies on an edge involving
// the boundary, and "internal" otherwise.
//
// The total potential of a web is the sum of the potentials associated with
// each vertex of the web.

/////////////////////////////////////////////////
// DATA TYPE: web
//
// A web is represented by a tuple (V, L1, L2[,L3]) where V is an integer > 0, giving
// number of vertices in the web, and two or three lists, where
//
//  1. L1 is a list of edges.
//  2. L2 is a list of matrices, of size V, with the matrix in posn i
//  being the differential of a matrix factorisation defined in the 
//  set of variables adjacent with the vertex i, factorising the potential
//  explained in the Usage Guide.
//  3. L3 is an optional list of intvecs, also of size v, making each
//  of the MFs into a graded MF.
//
// NOTE: Distinct edges in the web MUST be assigned disjoint sets of variables!

/////////////////////////////////////////////////
// DATA TYPE: compilation strategy
//
// Compilation of a web means taking the tensor product over all MFs in the
// web and pushing forward to the ring with all internal variables in the web
// deleted. A compilation strategy represents one way of effecting this pushforward
// in practice.
//
// Precisely, a compilation strategy consists of a pair (L1,L2), where
// L1 is a permutation of the set {1,...,V} and L2 is a list
// containing each internal variable in the web precisely once. The idea is that L1 tells
// us the order in which to tensor the MFs in the web together (for example, if
// L1 were 3,1,2 we should first tensor the MF at vertex 3 with the one at vertex 1,
// and then tensor the result with the MF at vertex 2) and L2 tells us the ordering
// on the variables to use in the reduction/pushforward procedure.

/////////////////////////////////////////////////
// Settor and Accessor methods for an edge.
//
// The point of these being that if we change the structure of the lists underlying
// an edge, or web, then we only need change the following routines.

proc edgeSource(list edge){ return(edge[1]); }
proc edgeTarget(list edge){ return(edge[2]); }
proc edgeVariables(list edge){ return(edge[3]); }
proc edgePotential(list edge){ return(edge[4]); }
proc setEdgeSource(list edge, int src){ edge[1] = src; return(edge); }
proc setEdgeTarget(list edge, int tar){ edge[2] = tar; return(edge); }
proc setEdgeVariables(list edge, list var){ edge[3] = var; return(edge); }
proc setEdgePotential(list edge, poly W){ edge[4] = W; return(edge); }
// NOTE: augmentedEdgeForEdge breaks the setter/getter barrier.

/////////////////////////////////////////////////
// Settor and Accessor methods for a web.

proc webSize(list web){ return(web[1]); }
proc webEdges(list web){ return(web[2]); }
proc webMFs(list web){ return(web[3]); }
proc webMFatVertex(list web, int vertex){ return(web[3][vertex]); }
proc webMFgr(list web){ return(web[4]); }
proc webMFgratVertex(list web, int vertex){ return(web[4][vertex]); }
proc webIsGraded(list web){ int t = (size(web) == 4); return(t); }

/////////////////////////////////////////////////
// Basic methods for vertices

proc variablesAtVertex(list web, int vertex)
{
    list vars;
    list edgeList = webEdges(web);
    
    int i;
    for(i = 1; i <= size(edgeList); i++)
    {
        list edge = edgeList[i];
        if( edgeSource(edge) == vertex || edgeTarget(edge) == vertex )
        {
            vars = vars + edgeVariables(edge);
        }
        kill edge;
    }
    
    kill edgeList;
    return(vars);
}

/////////////////////////////////////////////////
// vertexIncomingEdges
//
// Return a list (possibly empty) of indices into
// the array of edges giving those edges with target
// the given vertex (possibly the boundary 0).

proc vertexIncomingEdges(list web, int vertex)
{
    list eList;
    list edgeList = webEdges(web);
    
    int i;
    for(i = 1; i <= size(edgeList); i++ )
    {
        list edge = edgeList[i];
        if( edgeTarget(edge) == vertex )
        {
            eList = eList + list(i);
        }
        kill edge;
    }
    
    return(eList);
}

proc vertexOutgoingEdges(list web, int vertex)
{
    list eList;
    list edgeList = webEdges(web);
    
    int i;
    for(i = 1; i <= size(edgeList); i++ )
    {
        list edge = edgeList[i];
        if( edgeSource(edge) == vertex )
        {
            eList = eList + list(i);
        }
        kill edge;
    }
    
    return(eList);
}

proc vertexPotential(list web, int vertex)
{
    poly W;
    list edgeList = webEdges(web);
    
    int i;
    for(i=1; i <= size(edgeList); i++ )
    {
        list edge = edgeList[i];
        int nc;
        
        if( edgeSource(edge) == vertex ){ nc = 1; }
        if( edgeTarget(edge) == vertex ){ nc = -1; }
        
        W = W + nc * edgePotential(edge);
        
        kill edge;
    }
    
    return(W);
}

/////////////////////////////////////////////////
// ringWithoutVars
//
// Given a set of variables in the ring, returns
// the ring with those variables deleted (but otherwise
// preserved, for example parameters). We do NOT change
// the current basering. Note that vars should be a list
// of polynomials, not strings.

proc ringWithOnlyVars(list vars)
{
    list exvars;
    int i;
    for(i=1; i<=nvars(basering); i++)
    {
        if( !checklist(vars,var(i)) )
        {
            exvars = exvars + list(var(i));
        }
    }
    
    def nR = ringWithoutVars(exvars);
    return(nR);
}

proc ringWithoutVars(list vars)
{
    if( size(vars) == 0 )
    {
        print("[ringWithoutVars] Asked to create a ring with no variables, exiting.");
        return(0);
    }
    
    def SSS = basering;
    list rlist = ringlist(SSS);
    list newVar;
    
    // Go through and form newVar = current variables minus vars
    int i;
    for(i = 1; i <= size(rlist[2]); i++)
    {
        int found = 0;
        int j;
        for(j = 1; j <= size(vars); j++ )
        {
            if( string(vars[j]) == rlist[2][i] )
            {
                found = 1;
                break;
            }
        }
        
        if( !found ){ newVar = newVar + list(rlist[2][i]); }
    }
    
    list newringList = rlist;
    newringList[2] = newVar;

    // Fix the variable weighting
    intvec kk = (1..size(newVar));
    for(i=1; i<=size(newVar); i++)
    {
        kk[i] = 1;
    }
    newringList[3][1][2] = kk;
    kill kk;
    
    newringList[1][4][1] = 0;     // set minpoly to zero, put it back to the right value below...
    
    // Create our new ring
    def nR = ring(newringList);
    kill rlist, newringList;
    
    // Now complete the correct definition of nR by specifying the right minpoly: 
    if( defined(minpolyblow) && defined(r) )
    {
        setring nR;
        
        // Note that fetch uses the position of the ring variables, not the name, so 
        // that fetch(var(1)) is always var(1).
        poly P = fetch(SSS,minpolyblow); 
        poly z = subst(P,var(1),r);
        number nu = leadcoef(z);
        minpoly = nu;
        setring SSS;
    }
    
    return(nR);
}

/////////////////////////////////////////////////
// augmentedEdgeForEdge
//
// Given an edge, creates an associated augmented edge

proc augmentedEdgeForEdge(list edge)
{
    int powerCutoff = blowFlags("power_cutoff_jacobi"); 
    int useSanityCheck = blowFlags("sanity_checks");
    
    // Recall that an edge has the format (S,T,L,W) and an augmented edge has the format
    // (S,T,L,W,B,C) where B is an intvec and C a matrix.
    
    // First change ourselves into the ring with only the variables present on the given edge    
    def RRR = basering;
    def nR = ringWithOnlyVars(edgeVariables(edge));
    setring nR;

    // Note it's important that we respect the order of the variables in the edge, NOT
    // the natural ordering in the ring.
    list edge = imap(RRR,edge);
    list augEdge = edge;
    
    list L = edgeVariables(edge);
    poly W = edgePotential(edge);
    
    // Build the Jacobi ideal
    ideal J;
    int i;
    for(i=1; i <= size(L); i++)
    {
        J[i] = diff(W,L[i]);
    }
    ideal Jstd = std(J);
    
    intvec B;
    matrix C;
    for(i=1; i <= size(L); i++)
    {
        // Find a power of the variable va belonging to the ideal generated by the partials of W
        poly va = L[i];
        
        int p;
        int power = 0;
        
        for(p=1; p <= powerCutoff; p++)
        {
            if( reduce(va^p, Jstd) == 0 )
            {
                //print(string(va) + " to the power " + string(p) + " belongs to J"); //debug
                power = p;
                B[i] = p;
                matrix T = lift(J, va^p);
                
                if( ncols(T) != 1 || nrows(T) != size(J) )
                {
                    print("[augmentedEdgeForEdge] Something wrong with the lift, exiting.");
                    return(0);
                }
                
                if( i == 1 )
                {
                    C = T;
                }
                else
                {
                    C = concat(C,T);
                }
                
                break;
            }
        }
        
        if( power == 0 )
        {
            print("[augmentedEdgeForEdge] Failed to find power of variable in Jacobi ideal, exiting.");
            return(0);
        }
    }
    augEdge[5] = B;
    augEdge[6] = C;
    setring RRR;
    list augEdge = imap(nR, augEdge);
    ideal J = imap(nR,J);
    
    // Perform sanity check
    if( useSanityCheck )
    {
        matrix Q = matrix(J) * augEdge[6];
        list edgeVar = edgeVariables(edge);
        
        int i;
        for(i=1; i <= size(edgeVar); i++)
        {
            if( Q[1,i] != edgeVar[i]^(augEdge[5][i]) )
            {
                print("[augmentedEdgeForEdge] Failed to correct compute augmented edge, exiting.");
                return(0);
            }
        }
    }
    
    return(augEdge);
}

/////////////////////////////////////////////////
// webVerify
//
// Verify that the given list satisfies (some of) the conditions to be a web.

proc webVerifyGeneral(list web)
{
    int useGrading = webIsGraded(web);
    int numVertices = webSize(web);
    
    if( numVertices != size(webMFs(web)) )
    {
        print("[webVerify] There is size mismatch between vertices and MFs, failed.");
        return(0);
    }
    
    int i;
    for(i=1;i<=size(numVertices);i++)
    {
        matrix A = webMFatVertex(web, i);
        poly W = vertexPotential(web, i);
        if( useGrading ){ intvec Agr = webMFgratVertex(web, i); }
        
        if( size(vertexIncomingEdges(web,i)) + size(vertexOutgoingEdges(web,i)) == 0 )
        {
            print("[webVerify] There is an isolated vertex, failed.");
            return(0);
        }
        
        // Is A a MF of this potential?
        if( A * A != W * unitmat(ncols(A)) )
        {
            print("[webVerify] At vertex " + string(i) + " the MF does not factorise the local potential W=" + string(W) + ", failed.");
            return(0);
        }
        
        // Is A a graded MF?
        if( useGrading )
        {
            if( !isGradingValid(A, Agr) )
            {
                print("[webVerify] At vertex " + string(i) + " the grading is not valid, failed.");
                return(0);
            }
        }
    }
    
    return(1);
}

