//////////////////////////////////////////////////////////////////////////////////////
// EXAMPLE DQ1 (defect action on fundamental branes in A-type minimal model)
//
//         We want to check against eq. (6.36) of [Brunner/Roggenkamp 0707.0922] which
//         says that P_{m,m+1} x T_a = T_{a-1} + T_{a+1}. (See their (6.2) and (6.29)
//         for the notation.)
//////////////////////////////////////////////////////////////////////////////////////

option(noredefine);option(noloadLib);option(redSB);
LIB "blow.lib";
LIB "matrix.lib";
int nx=1;
int ny=1;
ring rr=(0,r),(x(1..nx),y(1..ny)),dp;
minpoly = rootofUnity(5);
poly minpolyblow = x(1)^4+x(1)^3+x(1)^2+x(1)+1;

int d = 5;
poly W = x(1)^d;

int m = 1;
int a = 1;

// Define T and P
matrix T[2][2] = 0, x(1)^a, x(1)^(d-a), 0;
matrix P[2][2] = 0, (y(1) - r^m * x(1)) * (y(1) - r^(m+1) * x(1)), (y(1)^d - x(1)^d)/((y(1) - r^m * x(1)) * (y(1) - r^(m+1) * x(1))), 0;

// Do the fusion
list l = fuseDefects(P, T, W);
matrix RD = l[1]; // Reduced inflation of Y x X
matrix ep = l[2]; // Idempotent endomorphism of RD
print(ep * ep - ep); // is ep is an idempotent "on the nose"?
matrix final = mfSuspend( mfSplitIdempotent(RD, ep), nx );
print(final);

// According to (6.36) of [Brunner/Roggenkamp 0707.0922], P x T should be isomorphic to
// T2 := (0, y(1)^2 // y(1)^3, 0). And indeed, if we define
number c = (-1/5*r^2-1/5*r-1/5); 
matrix f[4][2] = 1, 0, c*y(1), 0, 0, 1, 0, c * y(1)^2;  // morphism from T2[1] to RD
matrix g[2][4] = 1,0,0,0,0,0,1,0;                       // morphism from RD to T2[1]
// (f,g) is a splitting of ep: 
print( g*f - unitmat(2) );
print( f*g - ep );


//////////////////////////////////////////////////////////////////////////////////////
// EXAMPLE DQ2
//////////////////////////////////////////////////////////////////////////////////////

option(noredefine);option(noloadLib);option(redSB);
LIB "blow.lib";
LIB "matrix.lib";
int nx=1;
int ny=1;
ring rr=(0,r),(x(1..nx),y(1..ny)),dp;
minpoly = rootofUnity(5);
poly minpolyblow = x(1)^4+x(1)^3+x(1)^2+x(1)+1;

int d = 5;
poly W = x(1)^d;

int m = 3;                   // THIS IS THE ONLY DIFFERENCE TO EXAMPLE DQ1
int a = 1;

// Define T and P
matrix T[2][2] = 0, x(1)^a, x(1)^(d-a), 0;
matrix P[2][2] = 0, (y(1) - r^m * x(1)) * (y(1) - r^(m+1) * x(1)), (y(1)^d - x(1)^d)/((y(1) - r^m * x(1)) * (y(1) - r^(m+1) * x(1))), 0;

// Do the fusion
list l = fuseDefects(P, T, W);
matrix RD = l[1]; // Reduced inflation of Y x X
matrix ep = l[2]; // Idempotent endomorphism of RD
print(ep * ep - ep); // is ep is an idempotent "on the nose"?
matrix final = mfSuspend( mfSplitIdempotent(RD, ep), nx );
print(final);

// According to (6.36) of [Brunner/Roggenkamp 0707.0922], P x T should be isomorphic to
// (0, y(1)^2 // y(1)^3, 0). As in example DQ1 above, this is confirmed by splitting ep.

//////////////////////////////////////////////////////////////////////////////////////
// EXAMPLE DQ3 
//////////////////////////////////////////////////////////////////////////////////////

option(noredefine);option(noloadLib);option(redSB);
LIB "blow.lib";
LIB "matrix.lib";
int nx=1;
int ny=1;
ring rr=(0,r),(x(1..nx),y(1..ny)),dp;
minpoly = rootofUnity(5);
poly minpolyblow = x(1)^4+x(1)^3+x(1)^2+x(1)+1;

int d = 5;
poly W = x(1)^d;

int m = 1;
int a = 2;

// Define T and P
matrix T[2][2] = 0, x(1)^a, x(1)^(d-a), 0;
matrix P[2][2] = 0, (y(1) - r^m * x(1)) * (y(1) - r^(m+1) * x(1)), (y(1)^d - x(1)^d)/((y(1) - r^m * x(1)) * (y(1) - r^(m+1) * x(1))), 0;

// Do the fusion
list l = fuseDefects(P, T, W);
matrix RD = l[1]; // Reduced inflation of Y x X
matrix ep = l[2]; // Idempotent endomorphism of RD
print(ep * ep - ep); // is ep is an idempotent "on the nose"?
matrix final = mfSuspend( mfSplitIdempotent(RD, ep)[1], nx );
print(final);

// According to (6.36) of [Brunner/Roggenkamp 0707.0922], P x T should be isomorphic to
// (0, y(1)^1 // y(1)^4, 0) + (0, y(1)^3 // y(1)^2, 0). 

// Compute the endomorphisms of the MFs final and 
// BR := (0, y(1)^1 // y(1)^4, 0) + (0, y(1)^3 // y(1)^2, 0): 

def RRR = basering;
def nR = ringWithoutXVars();
setring nR;

matrix final = imap(RRR, final);

matrix BR[4][4] = 0, 0, y(1), 0,
                  0, 0, 0, y(1)^3, 
                  y(1)^4, 0,0,0,
                  0, y(1)^2,0,0;

list Fco  = MFcofull(final,final);
list BRco = MFcofull(BR,BR);

// final and BR have the same numbers of endobosons and endofermions:

size(Fco[1]) - size(BRco[1]);
size(Fco[2]) - size(BRco[2]);

// Look at even morphisms between BR and final:

int i;
for(i=1; i<=5; i++)
{
    print(" ");
    print(MFcofull(BR,final)[1][i]);
}

// The morphism M: BR -> final is an isomorphism (since its determinant is a nonzero constant):

matrix M = MFcofull(BR,final)[1][1] + MFcofull(BR,final)[1][4];
det(M);
