//////////////////////////////////////////////////////////////////////////////////////
// EXAMPLE DQ1 (defect action on fundamental branes in A-type minimal model)
//
//         We want to check against eq. (6.36) of [Brunner/Roggenkamp 0707.0922] which
//         says that P_{m,m+1} x T_a = T_{a-1} + T_{a+1}. (See their (6.2) and (6.29)
//         for the notation.)
//////////////////////////////////////////////////////////////////////////////////////

option(noredefine);option(noloadLib);option(redSB);
LIB "blow.lib";
LIB "matrix.lib";
int nx=1;
int ny=1;
ring rr=(0,r),(x(1..nx),y(1..ny)),dp;
minpoly = rootofUnity(5);
poly minpolyblow = x(1)^4+x(1)^3+x(1)^2+x(1)+1;

int d = 5;
poly W = x(1)^d;

int m = 1;
int a = 1;

// Define T, P and D = P x T:

matrix T[2][2] = 0, x(1)^a, x(1)^(d-a), 0;
matrix P[2][2] = 0, (y(1) - r^m * x(1)) * (y(1) - r^(m+1) * x(1)), (y(1)^d - x(1)^d)/((y(1) - r^m * x(1)) * (y(1) - r^(m+1) * x(1))), 0;
matrix D = MFtensor(P, T);

matrix Dblow = mablow(D,W);
list l = MFreduce(Dblow,1);
matrix RD = l[1]; // Compute the reduced form of Dblow over k[y]
matrix F = l[2]; // A homotopy equivalence F: Dblow -> RD
matrix G = l[3]; // A homotopy equivalence G: RD -> Dblow

matrix dq = dQ(T, W, nx);
matrix iddQ = ZZtensor( unitmat(2), dq ); // Extend it to Dblow by tensoring with id_P
matrix delQ = deltaQ(D, W, nx);

number frac = d;
matrix e = 1/frac * iddQ * delQ;
print(e);
print(e * Dblow - Dblow * e);

matrix ep = F * e * G;
print(ep * RD - RD * ep);
print(ep * ep - ep);

// Split the idempotent and suspend nx times
matrix final = mfSuspend( mfSplitIdempotent(RD, ep), nx );

// According to (6.36) of [Brunner/Roggenkamp 0707.0922], P x T should be isomorphic to
// T2 := (0, y(1)^2 // y(1)^3, 0). And indeed, if we define
number c = (-1/5*r^2-1/5*r-1/5); 
matrix f[4][2] = 1, 0, c*y(1), 0, 0, 1, 0, c * y(1)^2;  // morphism from T2[1] to RD
matrix g[2][4] = 1,0,0,0,0,0,1,0;                       // morphism from RD to T2[1]
// (f,g) is a splitting of ep: 
print( g*f - unitmat(2) );
print( f*g - ep );


//////////////////////////////////////////////////////////////////////////////////////
// EXAMPLE DQ2
//////////////////////////////////////////////////////////////////////////////////////

option(noredefine);option(noloadLib);option(redSB);
LIB "blow.lib";
LIB "matrix.lib";
int nx=1;
int ny=1;
ring rr=(0,r),(x(1..nx),y(1..ny)),dp;
minpoly = rootofUnity(5);
poly minpolyblow = x(1)^4+x(1)^3+x(1)^2+x(1)+1;

int d = 5;
poly W = x(1)^d;

int m = 3;                   // THIS IS THE ONLY DIFFERENCE TO EXAMPLE DQ1
int a = 1;

// Define T, P and D = P x T:

matrix T[2][2] = 0, x(1)^a, x(1)^(d-a), 0;
matrix P[2][2] = 0, (y(1) - r^m * x(1)) * (y(1) - r^(m+1) * x(1)), (y(1)^d - x(1)^d)/((y(1) - r^m * x(1)) * (y(1) - r^(m+1) * x(1))), 0;
matrix D = MFtensor(P, T);

matrix Dblow = mablow(D,W);
list l = MFreduce(Dblow,1);
matrix RD = l[1]; // Compute the reduced form of Dblow over k[y]
matrix F = l[2]; // A homotopy equivalence F: Dblow -> RD
matrix G = l[3]; // A homotopy equivalence G: RD -> Dblow

matrix dq = dQ(T, W, nx);
matrix iddQ = ZZtensor( unitmat(2), dq ); // Extend it to Dblow by tensoring with id_P
matrix delQ = deltaQ(D, W, nx);

number frac = d;
matrix e = 1/frac * iddQ * delQ;
print(e);
print(e * Dblow - Dblow * e);

matrix ep = F * e * G;
print(ep * RD - RD * ep);
print(ep * ep - ep);

// According to (6.36) of [Brunner/Roggenkamp 0707.0922], P x T should be isomorphic to
// (0, y(1)^2 // y(1)^3, 0). As in example DQ1 above, this is confirmed by splitting ep.

// Split the idempotent and suspend nx times
matrix final = mfSuspend( mfSplitIdempotent(RD, ep), nx );

//////////////////////////////////////////////////////////////////////////////////////
// EXAMPLE DQ3 
//////////////////////////////////////////////////////////////////////////////////////

option(noredefine);option(noloadLib);option(redSB);
LIB "blow.lib";
LIB "matrix.lib";
int nx=1;
int ny=1;
ring rr=(0,r),(x(1..nx),y(1..ny)),dp;
minpoly = rootofUnity(5);
poly minpolyblow = x(1)^4+x(1)^3+x(1)^2+x(1)+1;

int d = 5;
poly W = x(1)^d;

int m = 1;
int a = 2;

// Define T, P and D = P x T:

matrix T[2][2] = 0, x(1)^a, x(1)^(d-a), 0;
matrix P[2][2] = 0, (y(1) - r^m * x(1)) * (y(1) - r^(m+1) * x(1)), (y(1)^d - x(1)^d)/((y(1) - r^m * x(1)) * (y(1) - r^(m+1) * x(1))), 0;
matrix D = MFtensor(P, T);

matrix Dblow = mablow(D,W);
list l = MFreduce(Dblow,1);
matrix RD = l[1]; // Compute the reduced form of Dblow over k[y]
matrix F = l[2]; // A homotopy equivalence F: Dblow -> RD
matrix G = l[3]; // A homotopy equivalence G: RD -> Dblow

matrix dq = dQ(T, W, nx);
matrix iddQ = ZZtensor( unitmat(2), dq ); // Extend it to Dblow by tensoring with id_P
matrix delQ = deltaQ(D, W, nx);

number frac = d;
matrix e = 1/frac * iddQ * delQ;
print(e);
print(e * Dblow - Dblow * e);

matrix ep = F * e * G;
print(ep * RD - RD * ep);
print(ep * ep - ep);

// According to (6.36) of [Brunner/Roggenkamp 0707.0922], P x T should be isomorphic to
// (0, y(1)^1 // y(1)^4, 0) + (0, y(1)^3 // y(1)^2, 0). 

// Split the idempotent and suspend nx times
matrix final = mfSuspend( mfSplitIdempotent(RD, ep), nx );