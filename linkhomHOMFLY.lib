version="0.1";
category="Miscellaneous";
// summary description of the library
info="
LIBRARY:   linkhomHOMFLY.lib  Computation of link homology using web compilation
AUTHOR:    Nils Carqueville, Daniel Murfet
KEYWORDS:  matrix factorization, link homology

PROCEDURES:
";

LIB "linalg.lib";
LIB "matrix.lib";
LIB "ring.lib";
LIB "blow.lib";
LIB "linkhom.lib";

////////////////////////////////////////////////////////////////////
// USAGE GUIDE
//
// We expect the ambient ring to have one more variable than the number of edges
// in the link under consideration. The first variable is taken to the variable
// "a" of [KR2]. In principle parameters should be OK, but
// this has not been checked.
//
// The references to [KR2] are to Khovanov and Rozansky "Matrix factorizations and
// link homology II" arXiv:math/0505056v2.

////////////////////////////////////////////////////////////////////
// NOTES ON GRADING
//
// In [KR2] all variables are assigned degree two. The conventions for graded
// matrix factorisations are explained in [KR, p.2]. Note that the rings are
// bigraded, so the first variable a has degree (2,0) and the rest have degree
// (0,2).
//
// In the sl(N) link homology computations gradings were discussed as intvecs,
// so the grading on a free module of rank one was described by a single integer.
// Now it is described by an intvec of size 2. So the grading on a MF is now 
// a list, of total size given by the free-rank of the total Z/2-graded module,
// with each entry of the list an intevec (a,b) describing a free module R{a,b}.

////////////////////////////////////////////////////////////////////
// mfWideEdgeHOMFLY
//
// We are given four variables x1,x2,x3,x4 and we return the MF of
// ax1 + ax2 - ax3 - ax4 associated by Khovanov and Rozansky to a
// wide edge in the planar diagram of a link (see p.2 of [KR2]). 
// Let us include the following picture of a wide edge
//
//       x1      x2
//         \   /
//          \/
//          |
//          |
//         /\
//       /   \
//     x4       x3
//
// With this convention if you call
//
// matrix D = mfWideEdgeHOMFLY(x1,x2,x3,x4);
//
// Then the matrix D you get will be the (Q1,Q2) pair written on p.5 of [KR2],
// modulo some sign differences.
////////////////////////////////////////////////////////////////////

proc mfWideEdgeHOMFLY(poly f(1), poly f(2), poly f(3), poly f(4))
{
    poly W = var(1) * ( f(1) + f(2) - f(3) - f(4) );
    
    // Following KR we write W = a( f1 + f2 - f3 - f4 ) + 0( f1f2 - f3f4 )    
    matrix koszul1[2][2] = 0, f(1) + f(2) - f(3) - f(4), a, 0;
    matrix koszul2[2][2] = 0, f(1) * f(2) - f(3) * f(4), 0, 0;
    
    // Note the order that we tensor these two Koszul complexes is opposite
    // to the order suggested on p.2 of [KR2]. This is done so as to agree
    // with the matrices written on p.5.
    matrix D = MFtensor(koszul2, koszul1);
    
    return(D);
}

proc mfWideEdgeGradingHOMFLY()
{
    // As described on p.2 of [KR2]
    list g = intvec(0,0), intvec(-1,1);
    list h = intvec(0,0), intvec(-1,3);
    
    // Grading vector on the tensor product
    list r = MFtensorBigradings(h, g);
    
    return(r);
}