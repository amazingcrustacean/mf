//////////////////////////////////////////////////////////////////////////////////////
// EXAMPLE MFP1 - Tensoring (x,x2) with a factorisation of y^5 - x^3, using mfPushforward
//////////////////////////////////////////////////////////////////////////////////////

// This is the old blow-example-An.txt redone with mfPushforward instead of fuseDefects

option(noredefine);option(noloadLib);option(redSB);
LIB "blow.lib";
LIB "matrix.lib";
ring rr=0,(x(1),y(1)),dp;

poly W = x(1)^3; // X is a MF of W
poly V = y(1)^5 - x(1)^3; // Y is a MF of V

// Define X, Y and D = Y x X:
matrix X[2][2] = 0, x(1)^2, x(1), 0;

// Y is a factorisation of V, which we consider as a functor between MF(W) and MF(y(1)^5).
matrix Y0[2][2] = -x(1), y(1), -y(1)^4, x(1)^2;
matrix Y1[2][2] = x(1)^2, -y(1), y(1)^4, -x(1);
matrix z[2][2];
matrix Y = blockmat(z,Y1,Y0,z);

matrix D = MFtensor(Y,X);
matrix H = 1/3 * ZZtensor(unitmat(ncols(Y)),diff(X,x(1)));

// H is a homotopy between x(1)^2 and zero on D
H * D + D * H == x(1)^2 * unitmat(ncols(D));

// The tuple D, x(1), 2, H satisfies all the conditions for mfPushforward:
list l = mfPushforward(D, x(1), 2, H);
print(l[1]);

// We get two copies of (y(1),y(1)^4), which agrees with the earlier calculation in blow-example-An.txt

//////////////////////////////////////////////////////////////////////////////////////
// EXAMPLE MFP2
//////////////////////////////////////////////////////////////////////////////////////

//[mfReduceAlt] Reducing matrix of size 512
//[zoomreduce]    reduced to size 502
//[zoomreduce]    reduced to size 492
//[zoomreduce]    reduced to size 482
//[zoomreduce]    reduced to size 472
//[zoomreduce]    reduced to size 462
//[zoomreduce]    reduced to size 452
//[zoomreduce]    reduced to size 442
//[zoomreduce]    reduced to size 432
//[zoomreduce]    reduced to size 422
//[zoomreduce]    reduced to size 412
//[zoomreduce]    reduced to size 402
//[zoomreduce]    reduced to size 392
//[zoomreduce]    reduced to size 382
//[zoomreduce]    reduced to size 372
//[zoomreduce]    reduced to size 362
//[zoomreduce]    reduced to size 352
//[zoomreduce]    reduced to size 342
//[zoomreduce]    reduced to size 332
//[zoomreduce]    reduced to size 322
//[zoomreduce]    reduced to size 312
//[zoomreduce]    reduced to size 302
//[zoomreduce]    reduced to size 292
//[mfReduceAlt]          result is size 64.
//[mfReduceAlt]          elapsed time 36100ms.
//11
//24
//12
//23

option(noredefine);option(noloadLib);option(redSB);
LIB "blow.lib";
LIB "linkhom.lib";
LIB "matrix.lib";
LIB "control.lib";
LIB "inout.lib";

link l = "MPfile:r ./data/pokemon.mp";
def final1 = read(l);
def V1 = read(l);
def T1 = read(l);

// T1 is defined as the following tensor product
T1 == MFtensor(final1,V1);

// Our basering is now 0,(x(1),x(2),x(3),x(4)),dp
matrix H(1) = 1/3 * ZZtensor( diff(final1,x(1)), unitmat(ncols(V1)) );
matrix H(2) = 1/3 * ZZtensor( diff(final1,x(2)), unitmat(ncols(V1)) );
matrix H(3) = 1/3 * ZZtensor( unitmat(ncols(final1)), diff(V1,x(3)) );
matrix H(4) = 1/3 * ZZtensor( unitmat(ncols(final1)), diff(V1,x(4)) );

// Check these are homotopies contracting the action of each x(i)^2
int i;
for(i=1;i<=4;i++)
{
    H(i) * T1 + T1 * H(i) == x(i)^2 * unitmat(32);
}

list varlist = x(1),x(2),x(3),x(4);
list exps = 2,2,2,2;
list homotopies = H(1),H(2),H(3),H(4);

list L = mfPushforwardInductive(T1, varlist, exps, homotopies);

// Takes about 7 seconds, as compared to 36 the old way.

//////////////////////////////////////////////////////////////////////////////////////
// EXAMPLE MFP3 - Tensoring (x,x2) with a factorisation of y^5 - x^3, using webCompilePair
//////////////////////////////////////////////////////////////////////////////////////

// This is the old blow-example-An.txt redone with webCompilePair instead of fuseDefects

option(noredefine);option(noloadLib);option(redSB);
LIB "blow.lib";
LIB "matrix.lib";
LIB "mfweb.lib";
LIB "linkhom.lib";
ring rr=0,(x(1),y(1)),dp;

// Vertex 1 has one outgoing edge labelled with x(1)^3
list vertex1 = list(list(),list(),list(x(1)),list(3));

// Vertex 2 has one incoming edge labelled with x(1)^3 and one outgoing edge labelled with y(1)^5.
list vertex2 = list(list(x(1)),list(3),list(y(1)),list(5));

list vertices = list(vertex1,vertex2);

// Now define the mfs to be placed at each vertex 
matrix X[2][2] = 0, x(1)^2, x(1), 0;

// Y is a factorisation of V, which we consider as a functor between MF(W) and MF(y(1)^5).
matrix Y0[2][2] = -x(1), y(1), -y(1)^4, x(1)^2;
matrix Y1[2][2] = x(1)^2, -y(1), y(1)^4, -x(1);
matrix z[2][2];
matrix Y = blockmat(z,Y1,Y0,z);

list mfs = X, Y;

list web = list(vertices,mfs);

webVerify(web);

// The compilation strategy is to write Y x X
list compStrat = list(list(2,1),list(x(1)));

list L = webCompilePair(web, compStrat);
print(L[1]); // Answer is the same as before.