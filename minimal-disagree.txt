// Minimal disagreement

option(noredefine);option(noloadLib);option(redSB);//option(prot);
LIB "blow.lib";
LIB "linkhom.lib";
LIB "matrix.lib";
LIB "control.lib";
LIB "mfweb.lib";
ring rr=0,(x(1..6)),dp;
int N = 3; // The N in sl(N) link homology
printlevel = 1;

list trefoilLink = linkLibrary("trefoil");
intvec vertexParity = trefoilLink[1];
list edgeList = trefoilLink[2];

intvec v = 1,1,0;

// Build a web suitable for calling webCompile
int j;
list webMfs;
list webMfsGrading;

for(j=1; j<=size(edgeList); j++)
{
    intvec e = edgeList[j];

    matrix X = mfVertex(v[j], list(var(e[1]),var(e[2]),var(e[3]),var(e[4])), N);
    intvec Xgr = mfVertexGrading(v[j], N);

    webMfs = webMfs + list(X);
    webMfsGrading = webMfsGrading + list(Xgr);
    kill X,e;
}

// A web is defined by two lists: a list of vertices and a list of mfs (plus gradings).
// In what follows all our webs will have the same underlying graph, which we now construct
int j;
list webVertices;
for(j=1; j<=size(edgeList); j++)
{
    intvec e = edgeList[j];
    
    // The first two variables in e are the outgoing variables, and the second two
    // are the incoming variables
    list vertex = list(list(var(e[3]),var(e[4])),list(N+1,N+1),list(var(e[1]),var(e[2])),list(N+1,N+1));
    webVertices = webVertices + list(vertex);
    kill e, vertex;
}

// Define the web
list web = webVertices, webMfs, webMfsGrading;
kill webMfs, webMfsGrading;

list compStratVert;
list compStratVar;
for(j=1;j<=size(edgeList); j++)
{
    compStratVert[j] = j;
}
for(j=1;j<=nvars(basering);j++)
{
    compStratVar[j] = var(j);
}
list compStrat = compStratVert,compStratVar;

list h = webCompile(web, compStrat);