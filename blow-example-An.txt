//////////////////////////////////////////////////////////////////////////////////////
// EXAMPLE - Tensoring (x,x2) with a factorisation of y^5 - x^3
//////////////////////////////////////////////////////////////////////////////////////

option(noredefine);option(noloadLib);option(redSB);
LIB "blow.lib";
LIB "matrix.lib";
int nx=1;
int ny=1;
ring rr=0,(x(1..nx),y(1..ny)),dp;
int baa = 3;
poly W = x(1)^3;
poly V = y(1)^5 - x(1)^3;

// Define X, Y and D = Y x X:
matrix X[2][2] = 0, x(1)^2, x(1), 0;

// Y is a factorisation of V, which we consider as a functor between MF(W) and MF(y(1)^5).
matrix Y0[2][2] = -x(1), y(1), -y(1)^4, x(1)^2;
matrix Y1[2][2] = x(1)^2, -y(1), y(1)^4, -x(1);
matrix z[2][2];

matrix Y = blockmat(z,Y1,Y0,z);

matrix D = MFtensor(Y,X);

matrix Dblow = mablow(D,W); // Blow up D using Jac(W)
list l = mfReduce(Dblow,1);
matrix RD = l[1]; // Compute the reduced form of Dblow over k[y]
matrix F = l[2]; // A homotopy equivalence F: Dblow -> RD
matrix G = l[3]; // A homotopy equivalence G: RD -> Dblow

matrix dq = dQ(X, W, nx, 3); // This is dQ_X: 
matrix iddQ = ZZtensor( unitmat(ncols(Y)), dq ); // "iddQ" is "id x dQ_X"
matrix delQ = deltaQ(D, W, nx, 3); // This is deltaQ_D

// And finally the idempotent e on Dblow
number frac = baa;
matrix e = 1/frac * iddQ * delQ;
print(e * Dblow - Dblow * e);

// The corresponding idempotent on RD is
matrix ep = F * e * G;
print(RD); // The final reduced MF homotopy equivalent to Dblow
print(ep);
print(ep * RD - RD * ep); // ep is an endomorphism of RD
print(ep * ep - ep); // is ep is an idempotent "on the nose"?

matrix final = mfSuspend( mfSplitIdempotent(RD,ep) );
print(final);

///////// OLD COMPUTATION OF SPLITTING BY HAND ///////////

// Now ep is an idempotent morphism in the abelian category of factorisations of W, hence so is 1 - ep, 
// and the splitting of ep is Ker(1 - ep). If we can find a matrix factorisation Z and a morphism Z -> RD
// which is the kernel of 1 - ep then Z will be the finite rank MF isomorphic to D in MF(k[y], y^5).

matrix Z0[2][2] = y(1)^4, 0, 0, y(1);
matrix Z1[2][2] = y(1), 0, 0, y(1)^4;
matrix Z = blockmat(z,Z1,Z0,z);

matrix A0[4][2] = 2,0,1,0,0,1,0,0;
matrix A1 = A0;
matrix zA[4][2];
matrix A = blockmat_nsq(A0, zA, zA, A1);

// Notice that in each degree the kernel of
print(unitmat(ncols(ep)) - ep);
// is precisely those 4-tuples (2b,b,c,0) for b,c in k[y], that is, the image of A0. Since
// A is a morphism Z -> RD
print(RD * A - A * Z);
// with the right image, it must be the desired splitting. So we conclude that Z is homotopy
// equivalent to Y x X. That is, Y x X = (y^4, y) + (y, y^4).