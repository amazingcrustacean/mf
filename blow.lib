version="0.1";
category="Miscellaneous";
// summary description of the library
info="
LIBRARY:   blow.lib  Compilation of defect foams
AUTHOR:    Nils Carqueville, Daniel Murfet
KEYWORDS:  matrix factorization

PROCEDURES:
";

LIB "linalg.lib";
LIB "matrix.lib";
LIB "ring.lib";

////////////////////////////////////////////////////////////////////
// USAGE GUIDE
//
// At the moment we expect our ambient ring to be of one of the types
//
//     0,(x(1..nx),y(1..ny)),dp    OR    (0,r),(x(1..nx),y(1..ny)),dp
// 
// where nx, ny are integer variables that we expect to be defined before calling
// any of the routines in this library. The x variables are the "internal" variables.
// We always expect "r" to be the parameter defining an extension ring.
//
// In the second case where we define a ring extension, in addition to defining
// the minpoly we expect that before using this library an additional variable
// "minblowpoly" is defined, which is the minimum polynomial of r over Q expressed
// in terms of the variable x(1). For example
//
//    ring rr=(0,r),(x(1..nx),y(1..ny)),dp;
//    minpoly = r^2 + 1;
//    poly minpolyblow = x(1)^2 + 1;
//
// If minpolyblow or r is undefined we proceed by ignoring the ring extension.
//
// We assume currently in dQ, deltaQ and related routines that the polynomial
// we are passed is a sum of all the x-variables to some specific power.

// NOTE: We should NOT have W be some ambient fixed polynomial, since we may want
// to vary it in the foam case as we move among different edges.

//////////////////////////////////////////////////////////////////////////////////
// "ringwithoutyvars" returns the ambient ring with y variables removed
// NOTE: We just return the ring, we do not change the current basering
//////////////////////////////////////////////////////////////////////////////////

proc ringWithoutYVars()
{
	def RRR = basering;

	// Define new ring -- exactly the same as RRR, but without the y-variables:
	// ringlist(RRR)[1] will be the characteristic followed by (possibly) the names of parameters
	if(size(ringlist(RRR)[1]) > 1)
	{
		int i,j,k;
		list L = ringlist(RRR);
		for(i=1; i<=ny; i++)
		{
			L[2] = delete(L[2],nx + 1);
		}
		intvec kk = (1..nx);

		for(i=1; i<=nx; i++)
		{
			kk[i] = 1;
		}
		L[3][1][2] = kk;
		L[1][4][1] = 0;     // set minpoly to zero, put it back to the right value below...
		def nR = ring(L);

		// Now complete the correct definition of nR by specifying the right minpoly: 
		if( defined(minpolyblow) && defined(r) )
		{
			setring nR;
			poly P = imap(RRR,minpolyblow);
			poly z = subst(P,x(1),r);
			number nu = leadcoef(z);
			minpoly = nu;
		}
		else
		{
			print("[poly2matrix] Ring parameter other than r, or unspecified minpolyblow. Please see the Usage Guide.");
		}
	}
	else
	{
		ring nR = char(RRR), x(1..nx), dp;
	}	
	
	def newRing = basering;
	
	// Before returning the new ring, set the ambient ring as current
	setring RRR;
	
	return(newRing);
}

//////////////////////////////////////////////////////////////////////////////////
// "dimInternalAlgebra" Returns the dimension of the internal algebra, that is, the
// algebra I in the terminology of my note.
//
// At present, it just computes the Milnor number of the given W over the x-vars.
//////////////////////////////////////////////////////////////////////////////////

proc dimInternalAlgebra(poly W)
{
	def RRR = basering;
	def nR = ringWithoutYVars();
	setring nR;

	poly W = imap(RRR,W);
	ideal jaci = std(jacob(W));
	ideal ba = kbase(jaci);
	int n = size(ba);

	setring RRR;
	
	return(n);
}

//////////////////////////////////////////////////////////////////////////////////
// "poly2matrix" blows up a polynomial into a matrix: x-monomials are replaced by
// the matrices that represent the former's action on Jac(W).
//////////////////////////////////////////////////////////////////////////////////

proc poly2matrix(poly tepo, W)
{
    int prl = printlevel;
    dbprint(prl, "[poly2matrix] Computing inflated action of " + string(tepo) + " on the Jacobi algebra of " + string(W));
    
    def RRR = basering;
    def nR = ringWithoutYVars();
    setring nR;

    // Compute the Jacobi algebra
    poly W = imap(RRR,W);
    ideal jaci = std(jacob(W));
    ideal basis = kbase(jaci);
    int milnor = size(basis);
    module BB = reduce(basis,jaci);
    
    // Output the chosen basis of the Jacobi algebra
    dbprint(prl, "[poly2matrix] Chosen basis of the Jacobi algebra is");
    int i;
    for(i=1;i<=milnor;i++){ dbprint(prl, basis[i]); }
    
    setring RRR;

    // Compute the matrix MAtepo corresponding to the polynomial tepo:
    poly xprod = 1; 
    for(i=1; i<=nx; i++)
    {
        xprod = xprod * x(i);
    }
    matrix koffer = coef(tepo, xprod);
    matrix inflation[milnor][milnor];
    
    dbprint(prl, "[poly2matrix] Coefficient matrix of x-monomials"); dbprint(prl, koffer);
    
    int u, k;
    for(u=1; u<=ncols(koffer); u++)
    {
        poly xmonomial = koffer[1,u];
        
        // Switch to the ring without y vars
        setring nR;

        poly xmonomial = imap(RRR,xmonomial);
        poly W = imap(RRR,W);

        list L;
        for(k=1; k<=milnor; k++)
        {
            module ff = reduce(xmonomial*basis[k],jaci);
            matrix MM = matrix(reduce(lift(BB,ff),std(syz(BB))));
            L = L + list(MM);
        }

        matrix U = L[1];
        for(k=2; k<=milnor; k++)
        {
            U=concat(U,L[k]);
        }

        // Switch back to original ring
        setring RRR;

        matrix inflationOfMonomial = imap(nR,U);
        inflation = inflation + koffer[2,u] * inflationOfMonomial; 
        
        dbprint(prl, "[poly2matrix] Inflation of monomial " + string(xmonomial) + " is");
        dbprint(prl, inflationOfMonomial);
    }

    return(inflation);
}


//////////////////////////////////////////////////////////////////////////////////
// "mablow" blows up a matrix by blowing up all its entries using poly2matrix.
//////////////////////////////////////////////////////////////////////////////////

proc mablow(matrix M, poly W)
{
	// Compute dimension of Jac(W)
	int n = dimInternalAlgebra(W);
	
	// Define L to be an appropriately indexed list of blown-up matrices:
	int i1,j1,i2,j2,i;
	int s = ncols(M);

	list e,L;
	for(i=1; i<=s; i++)
	{
		L[i] = e;
	}
	for(i1=1; i1<=s; i1++)
	{
		for(j1=1; j1<=s; j1++)
		{
			L[i1] = insert(L[i1], poly2matrix(M[i1,j1], W),j1-1);
		}
	}

	matrix A[s*n][s*n];

	for(i1=1; i1<=s; i1++)
	{
		for(j1=1; j1<=n; j1++)
		{
			for(i2=1; i2<=s; i2++)
			{
				for(j2=1; j2<=n; j2++)
				{
					A[(i1-1)*n + j1, (i2-1)*n + j2] = L[i1][i2][j1,j2];
				}
			}
		}
	}

	return(A);
}

///////////////////////////////////////////////////////////////////////////////////////////////////////
// "DRN" computes the matrix representing [g_i, XA], where XA is a monomial in the x-variables.
///////////////////////////////////////////////////////////////////////////////////////////////////////

proc DRN(poly W, poly XA, int i)
{
	// Compute n := dimension of Jac(W):
	def RRR = basering;
	def nR = ringWithoutYVars();
	setring nR;

	poly W = imap(RRR,W);
	poly XA = imap(RRR,XA);
	ideal jaci = std(jacob(W));
	ideal ba = kbase(jaci);
	module BB = reduce(ba,jaci);

	int n = size(ba);
	int k;
	int exponent = deg(W) - 1;
	
	list L;
	for(k=1; k<=n; k++)
	{
		module ff = reduce(( XA * ba[k] - reduce(XA * ba[k],std(x(i)^exponent)) )/(x(i)^exponent) - XA * ( ba[k] - reduce(ba[k],std(x(i)^exponent)) )/(x(i)^exponent),jaci);
		matrix MM = matrix(reduce(lift(BB,ff),std(syz(BB))));
		L = L + list(MM);
	}

	matrix U = L[1];
	for(k=2; k<=n; k++)
	{
		U=concat(U,L[k]);
	}

	setring RRR;
	matrix NN = imap(nR,U);
	
	dbprint(printlevel, "[DRN] Matrix of [g_" + string(i) + ", " + string(XA) + "] is");
	dbprint(printlevel, NN);
	
	return(NN);
}


//////////////////////////////////////////////////////////////////////////////////
// "deltaImablow" blows up a matrix by blowing up all its entries using DRN. (This
// is equal to \delta_{x_i}(Q) of sec 3.1 in Dan's note from 2010-06-26.)
//
// II is the index of the variable which lives on the subscript of \delta.
//////////////////////////////////////////////////////////////////////////////////

proc deltaImablow(matrix M, poly W, int II)
{
	int prl = printlevel;
	
	dbprint(prl,"[deltaImablow] Input matrix M is"); dbprint(prl,M);
	dbprint(prl,"[deltaImablow] Input variable is x(" + string(II) + ")");
	
	// Compute n := dimension of Jac(W):
	def RRR = basering;
	def nR = ringWithoutYVars();
	setring nR;
	
	poly W = imap(RRR,W);
	ideal jaci = std(jacob(W));
	ideal ba = kbase(jaci);
	int n = size(ba);
	setring RRR;

	// Define L to be an appropriately indexed list of blown-up matrices:
	int colsm = ncols(M);
	int i1,j1,i2,j2,i;
	list e,L;
	
	poly yprod = 1; 
	for(i=1; i<=ny; i++)
	{
		yprod = yprod * y(i);
	}
	
	poly xprod = 1;
	for(i=1; i<=nx; i++)
	{
		xprod = xprod * x(i);
	}
	
	for(i=1; i<=colsm; i++)
	{
		L[i] = e;
	}
	for(i1=1; i1<=colsm; i1++)
	{
		for(j1=1; j1<=colsm; j1++)
		{
			///////////////////////////////////////////////////
			// INTERESTING PART: 
			//
			// koffer is a matrix with two rows. The first row contains
			// all the x-monomials with nonzero coefficient in M[i1,j1].
			// The second row contains the corresponding coefficient, which is a polynomial
			// in only the y-variables.
			
			matrix koffer = coef(M[i1,j1], xprod);
			matrix N[n][n];

			for(i=1; i<=ncols(koffer); i++)
			{
				if( koffer[2,i] != 0 && koffer[1,i] != 0 )
				{
					dbprint(prl, "[deltaImablow] In position (" + string(i1) + "," + string(j1) + "), koffer[1," + string(i) + "] = " + string(koffer[1,i]) + " and koffer[2," + string(i) + "] = " + string(koffer[2,i]));
					N = N + koffer[2,i] * DRN(W, koffer[1,i], II);
				}
			}

			L[i1] = insert(L[i1], N, j1-1);
			///////////////////////////////////////////////////
		}
	}

	matrix A[colsm*n][colsm*n];

	for(i1=1; i1<=colsm; i1++)
	{
		for(j1=1; j1<=n; j1++)
		{
			for(i2=1; i2<=colsm; i2++)
			{
				for(j2=1; j2<=n; j2++)
				{
					A[(i1-1)*n + j1, (i2-1)*n + j2] = L[i1][i2][j1,j2];
				}
			}
		}
	}

	dbprint(prl, "[deltaImablow] Final output is "); dbprint(prl, A);
	dbprint(prl, "------------");
	
	return(A);
}

/////////////////////////////////////////////////////////////////////////////////////
// "SGroupintvecs" produces the n! permutations of (1,...,n) as a list of intvecs.
/////////////////////////////////////////////////////////////////////////////////////

proc SGroupintvecs(int n)
{
	LIB "qmatrix.lib";
	list L;
	int i;
	
	intmat M = SymGroup(n);
	
	for(i=1; i<=nrows(M); i++)
	{
		intvec c = M[i,1..n];
		L[i] = c;
	}

	return(L);
}


/////////////////////////////////////////////////////////////////////////////////////
// "deltaQ" is \delta Q^{\wedge n} (where below we have F=Q, nx=(# of x-variables)
/////////////////////////////////////////////////////////////////////////////////////

proc deltaQ(matrix F, poly W, int nx)
{
	LIB "matrix.lib";
	
	int n = dimInternalAlgebra(W);
	int prl = printlevel;
	
	// The blown up matrix will be of dimension n x ncols(f)
	int gg = ncols(F) * n;
	
	list S = SGroupintvecs(nx);
	
	int i,j;	
	matrix Mi[gg][gg];

	for(i=1; i<=size(S); i++)
	{
		intvec perm = S[i];
		matrix Ma = (-1)^(LengthSymElement(perm)) * unitmat(gg);
		
		for(j=1; j<=nx; j++)
		{
			Ma = Ma * deltaImablow(F, W, perm[j]);
		}
		
		dbprint(prl, "[deltaQ] Current summand is "); dbprint(prl, Ma);
		Mi = Mi + Ma; 
	}
	
	// Multiply by the scaling factor:
	number ffac = 1;
	for(i=1; i<=nx; i++)
	{
		ffac = ffac / i;
	}
	Mi = ffac * Mi;
	
	return(Mi);
}


/////////////////////////////////////////////////////////////////////////////////////
// "dQ" is d Q_X^{\wedge n} (where below we have f=Q_X, nx=(# of x-variables),
/////////////////////////////////////////////////////////////////////////////////////

proc dQ(matrix f, poly W, int nx)
{
	LIB "matrix.lib";	
	
	int n = dimInternalAlgebra(W);
	
	// The blown up matrix will be of dimension n x ncols(f)
	int gg = ncols(f) * n;
	
	list S = SGroupintvecs(nx);
	int i,j;

	matrix Mi[gg][gg];

	for(i=1; i<=size(S); i++)
	{
		intvec perm = S[i];
		matrix Ma = (-1)^(LengthSymElement(perm)) * unitmat(gg);	
		
		//print("[dQ] Permutation is " + string(perm) + " with sign " + string(LengthSymElement(perm)));
		
		for(j=1; j<=nx; j++)
		{
			Ma = Ma * mablow(diff(f, x(perm[j])), W);
		}
		
		//print("[dQ] Adding summand"); print(Ma);
		Mi = Mi + Ma; 
	}
	
	// Multiply by the scaling factor
	number ffac = 1;
	for(i=1; i<=nx; i++)
	{
		ffac = ffac / i;
	}
	Mi = ffac * Mi;
	
	return(Mi);
}


/////////////////////////////////////////////////////////////////////////////////////
// "constantpart(P)" computes the constant part of a polynomial P.
/////////////////////////////////////////////////////////////////////////////////////

proc constantpart(poly P)
{
int i;
int n = nvars(basering);
matrix C;
C[1,1] = P;
for(i=1; i<=n; i++)
{
C = coeffs( C[1,1], var(i) );
}
return(C[1,1]);
}


/////////////////////////////////////////////////////////////////////////////////////
// "permuterows(M, a, b)" permutes the rows a and b of a matrix M.
/////////////////////////////////////////////////////////////////////////////////////

proc permuterows(matrix M, int a,b)
{
int i;
int s = ncols(M);
for(i=1; i<=s; i++)
{
poly pa = M[a,i];
poly pb = M[b,i];
M[a,i] = pb;
M[b,i] = pa;
}
return(M);
}


/////////////////////////////////////////////////////////////////////////////////////
// "permutecols(M, a, b)" permutes the columns a and b of a matrix M.
/////////////////////////////////////////////////////////////////////////////////////

proc permutecols(matrix M, int a,b)
{
int i;
int s = nrows(M);
for(i=1; i<=s; i++)
{
poly pa = M[i,a];
poly pb = M[i,b];
M[i,a] = pb;
M[i,b] = pa;
}
return(M);
}


/////////////////////////////////////////////////////////////////////////////////////
// "addrow(M, P, a, b)" adds P * (b-th row) to the a-th row.
/////////////////////////////////////////////////////////////////////////////////////

proc addrow(matrix M, poly P, int a,b)
{
int i;
int s = ncols(M);
for(i=1; i<=s; i++)
{
M[a,i] = M[a,i] + P * M[b,i];
}
return(M);
}


/////////////////////////////////////////////////////////////////////////////////////
// "addcol(M, P, a, b)" adds P * (b-th column) to the a-th column.
/////////////////////////////////////////////////////////////////////////////////////

proc addcol(matrix M, poly P, int a,b)
{
int i;
int s = nrows(M);
for(i=1; i<=s; i++)
{
M[i,a] = M[i,a] + P * M[i,b];
}
return(M);
}


/////////////////////////////////////////////////////////////////////////////////////
// "rocoreduce(M)" gives a list L with
// -- L[1] = row & column reduced version M' of M such that M'=diag(A,B), where A is
//    a diagonal matrix with only constant entries, and B is a block matrix without
//    nonzero constant entries,
// -- L[2] = UL (invertible over the polynomial ring),
// -- L[3] = UR (invertible over the polynomial ring) such that M' = UL * M * UR.
//
// NOTE: There must be some typos or other mistakes somewhere, as the similarity
//       transformations constructed do not reproduce the reduced matrix. Don't try
//       to fix this for the moment but use Dan's mfReduce instead (but leave don't
//       delete this code, it might be useful at some later point.)
/////////////////////////////////////////////////////////////////////////////////////

proc rocoreduce(matrix M)
{
int i,j,k,r;
int s = ncols(M);

// These will become the similarity matrices that describe the isomorphism 
// between M and its reduced form:
matrix UL = unitmat(s);
matrix UR = unitmat(s);

// z is a counter (in the end, z will be the number of trivial MFs that we can split off):

int z;
for(i=1; i<=s; i++)
{

for(j=1; j<=s; j++)
{
if(constantpart(M[i,j]) == M[i,j] and M[i,j] != 0)
{
// Bring the constant to the diagonal entry (z+1,z+1), and implement effect on UL,UR:
M = permutecols(M, j, z+1);
matrix U = unitmat(s); U[j,j]=0; U[z+1,z+1]; U[j,z+1]=1; U[z+1,j]=1;
UR = UR * U;
M = permuterows(M, i, z+1);
matrix U = unitmat(s); U[i,i]=0; U[z+1,z+1]; U[i,z+1]=1; U[z+1,i]=1;
UL = U * UL;

z = z+1;

// Use column manipulations to kill all (k,z)-entries of M for k>z:
for(k=z+1; k<=s; k++)
{
int s = nrows(M);
poly P = M[z,k]/M[z,z];

// effect on similarity matrix UR:
matrix U = unitmat(s);
U[z,k] = - P;
UR = UR * U;

for(r=1; r<=s; r++)
{
M[r,k] = M[r,k] - P * M[r,z];
}
}// end k-loop

// Use row manipulations to kill all (z,k)-entries of M for k>z:
for(k=z+1; k<=s; k++)
{
int s = ncols(M);
poly P = M[k,z]/M[z,z];

// effect on similarity matrix UL:
matrix U = unitmat(s);
U[k,z] = - P;
UL = U * UL;

for(r=1; r<=s; r++)
{
M[k,r] = M[k,r] - P * M[z,r];
}
}// end k-loop

break;
}
}// end j-loop

}// end i-loop

list L = M,UL,UR;
return(L);
}


//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// old stuff to compute cohomologies:
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
proc rdsum(matrix A, int r)
{
list B;
B[1]=A;
for (int i=2; i<=r; i++)
{
B[i]=dsum(B[i-1],A);
}
return(B[r]);
}
//-----------------------------------------------------------------------------
proc dminus(matrix f,g,f',g')
{
int r=nrows(f);
int r'=nrows(f');
matrix P1=concat(tensor(f',unitmat(r)), rdsum(-transpose(f),r'));
matrix P2=concat(rdsum(transpose(-g),r'),tensor(g',unitmat(r)));
matrix P[2*r*r'][2*r*r']=P2,P1;
return(P);
}
//-----------------------------------------------------------------------------
proc dplus(matrix f,g,f',g')
{ 
int r=nrows(f);
int r'=nrows(f');
matrix P1=concat(rdsum(transpose(f),r'),tensor(g',unitmat(r)));
matrix P2=concat(tensor(f',unitmat(r)),rdsum(transpose(g),r'));
matrix P[2*r*r'][2*r*r']=P1,P2;
return(P);
}
//-----------------------------------------------------------------------------
proc vector2matrix(list V, int r, int r')
{
int i,j,k;
list M;
matrix ma[2*r'][2*r];
for(i=1; i<=size(V); i++){M = M + list(ma);}
for(i=1; i<=size(V); i++)
 {for(j=1; j<=r; j++)
  {for(k=1; k<=r'; k++)
   {M[i][k,j] = V[i][(k-1)*r + j, 1];
    M[i][k+r',j+r] = V[i][(r'-1+k)*r + j, 1];
   }
  }
 }
return(M);
}
//-----------------------------------------------------------------------------
proc vector2matrixFerm(list V, int r, int r')
{
int i,j,k;
list M;
matrix ma[2*r'][2*r];
for(i=1; i<=size(V); i++){M = M + list(ma);}
for(i=1; i<=size(V); i++)
 {for(j=1; j<=r; j++)
  {for(k=1; k<=r'; k++)
   {M[i][k,j+r] = V[i][(k-1)*r + j, 1];
    M[i][k+r',j] = V[i][(r'-1+k)*r + j, 1];
   }
  }
 }
return(M);
}
//-----------------------------------------------------------------------------
proc matrix2vector(matrix M)
{
int r1 = ncols(M)/2;
int r2 = nrows(M)/2;
int i,ii,j,k;
vector v;
// bosonic part:
for(ii=1; ii<= r2; ii++)
{
for(j=1; j<= r1; j++)
{
v = v + gen((ii-1)*r1 + j)*M[ii,j];
}}
for(ii=1; ii<= r2; ii++)
{
for(j=1; j<= r1; j++)
{
v = v + gen(r1*r2 + (ii-1)*r1 + j)*M[ii+r2,j+r1];
}}
// fermionic part:
for(i=1; i<= r2; i++)
{
for(j=1; j<= r1; j++)
{
v = v + gen(2*r1*r2 + (i-1)*r1 + j)*M[i,j+r1];
}}
for(i=1; i<= r2; i++)
{
for(j=1; j<= r1; j++)
{
v = v + gen(2*r1*r2 + r1*r2 + (i-1)*r1 + j)*M[i+r2,j];
}}

return(v);
}
//-----------------------------------------------------------------------------
proc MFco(matrix f,g,f',g')
{
module M=syz(dminus(f,g,f',g'));
matrix Mker=M;
module Q=modulo(M,module(dplus(f,g,f',g')));
matrix base=kbase(std(Q));
matrix m = Mker*base;

module Mf=syz(dplus(f,g,f',g'));
matrix Mkerf=Mf;
module Qf=modulo(Mf,module(dminus(f,g,f',g')));
matrix basef=kbase(std(Qf));
matrix mf = Mkerf*basef;

int i;
int r = ncols(f);
int r' = ncols(f');
matrix ma[2*r'][2*r];
list L;
for(i=1; i<=ncols(m); i++){L = L + list(ma);}
intvec v1 = 1..nrows(m);
intvec v2;

list Lf;
for(i=1; i<=ncols(mf); i++){Lf = Lf + list(ma);}
intvec vf1 = 1..nrows(mf);
intvec vf2;

for(i=1; i<=ncols(m); i++)
{
intvec v2 = i;
L[i] = submat(m,v1,v2);
}

for(i=1; i<=ncols(mf); i++)
{
intvec vf2 = i;
Lf[i] = submat(mf,vf1,vf2);
}


list MMb = vector2matrix(L, r, r');
list MMf = vector2matrixFerm(Lf, r, r');

matrix null[2*r'][2*r];
list leer;
if(MMb[1] == null)
{MMb = leer;}
if(MMf[1] == null)
{MMf = leer;}


list MM;
MM[1] = MMb;
MM[2] = MMf;

return(MM);
}


// MFtensorF(f,g,fs,gs) gives the f-part of the tensor product matrix factorisations of (f,s) and (fs,gs).

proc MFtensorF(matrix f, matrix g, matrix fs, matrix gs)
{
LIB "matrix.lib";
int i,j;
 int r=ncols(f);
 int rs=ncols(fs);
 matrix m[2*r*rs][2*r*rs];
 for(i=1; i<=r*rs; i++)
  {for(j=1; j<=r*rs; j++)
   {m[i,j] = tensor(f,unitmat(rs))[i,j];
   }
  }
 for(i=1; i<=r*rs; i++)
  {for(j=1; j<=r*rs; j++)
   {m[i,j + r*rs] = - tensor(unitmat(r),gs)[i,j];
   }
  }
 for(i=1; i<=r*rs; i++)
  {for(j=1; j<=r*rs; j++)
   {m[i + r*rs,j] = tensor(unitmat(r),fs)[i,j];
   }
  }
 for(i=1; i<=r*rs; i++)
  {for(j=1; j<=r*rs; j++)
   {m[i + r*rs,j + r*rs] = tensor(g,unitmat(rs))[i,j];
   }
  }
return(m);
}


// MFtensorG(f,g,fs,gs) gives the g-part of the tensor product matrix factorisations of (f,s) and (fs,gs).

proc MFtensorG(matrix f, matrix g, matrix fs, matrix gs)
{
LIB "matrix.lib";
int i,j;
 int r=ncols(f);
 int rs=ncols(fs);
 matrix m[2*r*rs][2*r*rs];
 for(i=1; i<=r*rs; i++)
  {for(j=1; j<=r*rs; j++)
   {m[i,j] = tensor(g,unitmat(rs))[i,j];
   }
  }
 for(i=1; i<=r*rs; i++)
  {for(j=1; j<=r*rs; j++)
   {m[i,j + r*rs] = tensor(unitmat(r),gs)[i,j];
   }
  }
 for(i=1; i<=r*rs; i++)
  {for(j=1; j<=r*rs; j++)
   {m[i + r*rs,j] = - tensor(unitmat(r),fs)[i,j];
   }
  }
 for(i=1; i<=r*rs; i++)
  {for(j=1; j<=r*rs; j++)
   {m[i + r*rs,j + r*rs] = tensor(f,unitmat(rs))[i,j];
   }
  }
return(m);
}

// blockmat(A,B,C,D) gives the block-matrix {{A,B},{C,D}} if the square matrices A,B,C,D all have the same size.

proc blockmat(matrix block1,matrix block2,matrix block3,matrix block4)
{
int i,j;
int r=ncols(block1);
matrix m[2*r][2*r];
for(i=1;i<=r;i++){for(j=1;j<=r;j++){m[i,j]=block1[i,j];}}
for(i=1;i<=r;i++){for(j=r+1;j<=2*r;j++){m[i,j]=block2[i,j-r];}}
for(i=r+1;i<=2*r;i++){for(j=1;j<=r;j++){m[i,j]=block3[i-r,j];}}
for(i=r+1;i<=2*r;i++){for(j=r+1;j<=2*r;j++){m[i,j]=block4[i-r,j-r];}}
return(m);
}

// Modification of blockmat to accommodate nonsquare entries (consider replacing blockmat with this)
// We assume only that a block matrix makes sense, i.e. that in the order given the matrices fit
// together into a matrix. Here is the ASCII diagram
//
//       a        b
//   ----------|-------|
//   |         |       |
//   |    1    |   2   |
// c |         |       |
//   |---------|-------|
// d |     3   |   4   |
//   |---------|-------|
//
// where we allow a, b, c, d to be arbitrary

proc blockmat_nsq(matrix block1,matrix block2,matrix block3,matrix block4)
{
    int i,j;
    int a = ncols(block1);
    int b = ncols(block2);
    int c = nrows(block1);
    int d = nrows(block3);
    
    // Sanity check
    if( a != ncols(block3) || b != ncols(block4) || c != nrows(block2) || d != nrows(block4) )
    {
        print("[blockmat] Incorrect block sizes, exiting.");
        return();
    }
    
    int nc=ncols(block1);
    int nr=nrows(block1);
    matrix m[c + d][a + b];

    for(i=1;i<=c;i++){for(j=1;j<=a;j++){m[i,j]=block1[i,j];}}
    for(i=1;i<=c;i++){for(j=a+1;j<=a+b;j++){m[i,j]=block2[i,j-a];}}
    for(i=c+1;i<=c+d;i++){for(j=1;j<=a;j++){m[i,j]=block3[i-c,j];}}
    for(i=c+1;i<=c+d;i++){for(j=a+1;j<=a+b;j++){m[i,j]=block4[i-c,j-a];}}
    return(m);
}


// To get blocks from block square matrix returns list (1-4 of blocks)

proc blocksq(matrix m)
{
int n=nrows(m);
int intnon2=n/2;
number non2=number(n)/2;
if(n!=ncols(m))
{
	printf("Matrix should be square");
	return();
}
if(non2!=intnon2)
{
	printf("Matrix should have an even number of rows/columns");
	return();
}
matrix block1[intnon2][intnon2]=submat(m,1..intnon2,1..intnon2);
matrix block2[intnon2][intnon2]=submat(m,1..intnon2,intnon2+1..n);;
matrix block3[intnon2][intnon2]=submat(m,intnon2+1..n,1..intnon2);;
matrix block4[intnon2][intnon2]=submat(m,intnon2+1..n,intnon2+1..n);;
list L=block1,block2,block3,block4;
kill n,intnon2,non2,block1,block2,block3,block4;
return(L);
}



/// NEW 1/7/10 Dan.

////////////////////////////////////////////////////////////////////
// zeromat - Returns a square zero matrix of the specified size if
// called with one parameter, and a zero matrix of size n x m if called
// with two parameters n, m
////////////////////////////////////////////////////////////////////

proc zeromat(int n, list #)
{
    if( size(#) == 0 )
    {
        matrix M[n][n];
        return(M);
    }
    else
    {
        int m = #[1];
        matrix M[n][m];
        return(M);
    }
}

////////////////////////////////////////////////////////////////////
// mfSuspend
// 
// Returns the suspension of the given matrix factorisation. If called
// with no additional parameters we suspend once, otherwise we suspend
// the number of times indicated by the second parameter.

proc mfSuspend(matrix A, list #)
{
    int power = 1;
    
    if( size(#) != 0 ){ power = #[1]; }
    
    list blocks = extractblockmat(A);
	matrix a0 = blocks[3]; matrix a1 = blocks[2];
	
    matrix z[ncols(A)/2][ncols(A)/2];
    
    if( power mod 2 == 0 )
    {
        // The power is even, so return the original MF
        return(A);
    }
    else
    {
        // The power is odd, so suspend
        matrix Asusp = blockmat(z, -1 * a0, -1 * a1, z);
        return(Asusp);
    }
}

////////////////////////////////////////////////////////////////////
// mfSplitIdempotent
//
// Takes as input an odd block matrix A interpreted as the differential on a Z/2-graded free module X,
// and an even block matrix E interpreted as an endomorphism of X, satisfying E * E = E. We return
// the differential B on a MF Y splitting E (details in a moment) if no third parameter is given, and
// if a third parameter is given then we return:
//
// a list B, F, G consisting of the differential B on a MF Y and morphisms F: Y -> X, G: X -> Y such
// that E = F * G and 1_Y = G * F. That is, we split the idempotent.
//
// WARNING: If X is a matrix factorisation of a nonzero potential, we return a block matrix with
// square blocks, but if the potential is zero the blocks may be non-square.
//
// TODO: At the moment we do not treat the case of potential zero (we quit with an error).

proc mfSplitIdempotent(matrix A, matrix E, list #)
{
    // Sanity checks
    if( ncols(A) != nrows(A) )
    {
        print("[mfSplitIdempotent] Passed a nonsquare matrix, exiting.");
        return();
    }
    
    int m = ncols(A);

    if( A * E - E * A != zeromat(m) )
    {
        print("[mfSplitIdempotent] Passed a non-morphism, exiting.");
        return();
    }
    
    if( E * E - E != zeromat(m) )
    {
        print("[mfSplitIdempotent] Passed a non-idempotent endomorphism, exiting.");
        return();
    }
    
    // Extract the odd and even part of the differential and morphism
    list blocks = extractblockmat(A);
    list e_blocks = extractblockmat(E);
    
    matrix a0 = blocks[3]; matrix a1 = blocks[2];
    matrix e0 = e_blocks[1]; matrix e1 = e_blocks[4];
    
    // We produce morphisms f0, g0, f1, g1 where fi, gi is a splitting of ei, in the
    // sense that fi * gi = ei and gi * fi = 1. We do this by taking fi to be the kernel
    // of 1 - ei and then computing gi as the left inverse of fi.
    
    // TODO: We know that Ker(1-ei) is a free module (Quillen-Suslin!) and we assume that
    // rightKernel(unitmat(m/2) - e0) gives a minimal presentation of the kernel, in the sense
    // that interpreted as a morphism of free modules it is actually a monomorphism.
    // TODO: Fix this using minbase?
    //
    // NOTE: It's possible that since we split e0 and e1 separately, the splittings may
    // be free of different ranks (i.e. the return matrices may be non-square). Of course
    // we know that the splitting will still be a factorisation of the same potential, so
    // if X factorises a nonzero potential, it will follow that the return matrices are square.
    
    LIB "control.lib";

    // Take the kernel ker0 of 1 - e0, write it as a map f0 between free modules. Then
    // we obtain the map g0 by multiplying the left inverse of f0 by e0.
    // NOTE: If e0 = 0 then ker0 is zero, and we should set f0 = g0 = 0.
    module ker0 = rightKernel(unitmat(m/2) - e0);
    matrix f0 = ker0;
    matrix g0[ncols(f0)][nrows(f0)]; // Defaults to zero
        
    if( ker0[1] != [0] )
    {
        matrix g0 = leftInverse(f0) * e0; // Solves f0 * g0 = e0.
    }
    
    // Same in the odd degrees
    module ker1 = rightKernel(unitmat(m/2) - e1);
    matrix f1 = ker1;
    matrix g1[ncols(f1)][nrows(f1)];
    
    if( ker1[1] != [0] )
    {
        matrix g1 = leftInverse(f1) * e1;    
    }
    
    int n0 = nrows(g0);
    int n1 = nrows(g1);
    
    // Debug warn if nonsquare 
    if( ker0[1] == [0] || ker1[1] == [0] || n0 != n1 )
    {
        print("[mfSplitIdempotent] Splitting produced nonsquare matrices, exiting.");
        return(zeromat(2));
    }
    
    // Sanity check
    if( f0 * g0 != e0 || f1 * g1 != e1 || g0 * f0 != unitmat(n0) || g1 * f1 != unitmat(n1) )
    {
        print("[mfSplitIdempotent] Splitting was not successful, exiting.");
        
        //dbprint(printlevel, "f0 is "); dbprint(printlevel, f0);
        //dbprint(printlevel, "g0 is "); dbprint(printlevel, g0);
        //print( f0 * g0 - e0 );
        return();
    }
    
    // Put the f and g matrices back together
    matrix zf1[nrows(f0)][ncols(f1)];
    matrix zf2[nrows(f1)][ncols(f0)];
    
    matrix zg1[nrows(g0)][ncols(g1)];
    matrix zg2[nrows(g1)][ncols(g0)];
    
    matrix F = blockmat_nsq(f0, zf1, zf2, f1);
    matrix G = blockmat_nsq(g0, zg1, zg2, g1);
    
    // The differential on the splitting is given by B = G * A * F
    matrix B = G * A * F;
    
    if( size(#) == 0 ){ return(B); }
    
    list l = B, F, G;
    return(l);
}

////////////////////////////////////////////////////////////////////
// mfReduce
//
// Takes as input an odd block matrix A interpreted as the differential on a Z/2-graded free module X.
// The output is the differential B of a matrix factorisation Y homotopy equivalent to X which has no
// constant entries (the "reduced" form of the original matrix factorisation). Note the size of the input
// and output matrices may differ.
//
// If a nonzero second parameter is specified then instead of returning just a matrix we return a list.
// The second and third outputs are matrices F,G representing morphisms F: X -> Y and G: Y -> X resp.
// which are mutually inverse in the homotopy category.
//
// The final output is a "record" of each of the reduction steps: that is, a list L = (R1,R2,...) which
// is a series of triples Ri = (b0i,b1i,f0i,f1i, g0i,g1i) beginning with R1 = (A,1,1) and ending with R? = (B, F, G)
// with each intermediate step a differential Bi of a MF together with even maps Fi, Gi representing
// homotopy equivalences between A and Bi.

proc mfReduce(matrix A, list #)
{
	LIB "linalg.lib";
	
	int prl = printlevel;

	dbprint(prl, "[mfReduce]");
	
	// Extract the odd and even part of the differential
	list blocks = extractblockmat(A);
	matrix b0 = blocks[3]; matrix b1 = blocks[2];
	
	// F and G begin as identity maps
	matrix f0 = unitmat(ncols(A)/2); matrix f1 = unitmat(ncols(A)/2);
	matrix g0 = unitmat(ncols(A)/2); matrix g1 = unitmat(ncols(A)/2);
	
	list transform_record;
	list current_stage = b0,b1,f0,f1,g0,g1;
	transform_record = transform_record + list(current_stage);
		
	// A remains fixed, we work steadily on B and F, G until B has the desired form
	// Begin by looking inside b0 for nonzero constants. If at some point b0 becomes
	// a 1x1 matrix we bail (it must be contractible).
	while( ismfReduced(b0) != 1 && ncols(b0) > 1 )
	{	
		dbprint(prl, " [mfReduce] while loop for b0");
		
		// There is a constant somewhere, begin looking in b0
		list l = matrixreduce(b0);
		matrix p = l[2]; matrix q = l[3];
			
		// The matrix factorisation (b0,b1) is isomorphic to (p * b0 * q, q^{-1} * b1 * p^{-1})
		// via the morphism (from the former to the latter) given by the pair
		// (q^{-1},p). We now transform b1 to b1 = q^{-1} * b1 * p^{-1}.
		// We remember the transformation by adjusting F and G, so
		// that at each stage F is an isomorphism between X and Y with inverse G

		b0 = l[1];
		b1 = inverse(q) * b1 * inverse(p);
		f0 = inverse(q) * f0; f1 = p * f1;
		g0 = g0 * q; g1 = g1 * inverse(p);
					
		// Now that we guarantee b0 has an identity in the top left and zeros in the rest
		// of the first column, call a worker routine to "split" off this contractible
		// piece and return the modified B, F, G
		list out = mfReduce_work(b0,b1,f0,f1,g0,g1);
		b0 = out[1]; b1 = out[2];
		f0 = out[3]; f1 = out[4];
		g0 = out[5]; g1 = out[6];
		
		current_stage = b0,b1,f0,f1,g0,g1;
		transform_record = transform_record + list(current_stage);
		
		dbprint(prl, "  Result of reduction, b0:"); dbprint(prl,b0);
		dbprint(prl, "  Result of reduction, b1:"); dbprint(prl,b1);
		dbprint(prl, "  Result of reduction, p:"); dbprint(prl,p);
		dbprint(prl, "  Result of reduction, q:"); dbprint(prl,q);
		dbprint(prl, "--------------------------");
	}
	
	// No do the same process to b1 (TODO: unify these two steps)
	while( ismfReduced(b1) != 1 && ncols(b1) > 1 )
	{
		dbprint(prl, " [mfReduce] while loop for b1");
		
		// There is a constant somewhere, begin looking in b1
		list l = matrixreduce(b1);
		matrix p = l[2]; matrix q = l[3];
			
		// The matrix factorisation (b0,b1) is isomorphic to (q^{-1} * b0 * p^{-1}, p * b1 * q)
		// via the morphism (from the former to the latter) given by the pair
		// (p,q^{-1}). We now transform b0 to b0 = q^{-1} * b0 * p^{-1}.
		// We remember the transformation by adjusting F and G, so
		// that at each stage F is an isomorphism between X and Y with inverse G

		b1 = l[1];
		b0 = inverse(q) * b0 * inverse(p);
		f0 = p * f0; f1 = inverse(q) * f1;
		g0 = g0 * inverse(p); g1 = g1 * q;

		// Now that we guarantee b1 has an identity in the top left and zeros in the rest
		// of the first column, call a worker routine to "split" off this contractible
		// piece and return the modified B, F, G
		list out = mfReduce_work(b1,b0,f1,f0,g1,g0);
		
		// Note the orders are interchanged relative to the b0 case!
		b0 = out[2]; b1 = out[1];
		f0 = out[4]; f1 = out[3];
		g0 = out[6]; g1 = out[5];
		
		current_stage = b0,b1,f0,f1,g0,g1;
		transform_record = transform_record + list(current_stage);
		
		dbprint(prl, "  Result of reduction, b0:"); dbprint(prl,b0);
		dbprint(prl, "  Result of reduction, b1:"); dbprint(prl,b1);
		dbprint(prl, "  Result of reduction, p:"); dbprint(prl,p);
		dbprint(prl, "  Result of reduction, q:"); dbprint(prl,q);
		dbprint(prl, "--------------------------");
	}
	
	// Our MF (b0,b1) is now guaranteed to be free of constants. At this point
	// we just apply usual Guassian elimination: TODO it only looks for lower triangular
	// reduced forms...
	
	// NOTE: Only apply Gaussian elimination if we know the matrices b0, b1 are nonzero
	matrix zero_b[nrows(b0)][ncols(b0)];
	if( b0 != zero_b && b1 != zero_b )
	{
		////// BEGIN GAUSS //////
		list gau = gauss_row(b0,1);

		matrix tr = transpose(gau[2]); // The transformation matrix, so tr * b0 = reduced form
		matrix b0r = transpose(gau[1]); // The reduced form
		if( tr * b0 != b0r ){ print("[mfReduce] Error in Gaussian elimination"); return(1); }
	
		b0 = b0r;
		b1 = b1 * inverse(tr);
		f1 = tr * f1;
		g1 = g1 * inverse(tr);
	
		// Try a second time on the transpose
 		gau = gauss_row(transpose(b0),1);
		matrix tr2 = gau[2];
		b0r = gau[1];
		if( b0 * tr2 != b0r ){ print("[mfReduce] Error in Gaussian column elimination"); return(1); }

		b0 = b0r;
		b1 = inverse(tr2) * b1;
		f0 = inverse(tr2) * f0;
		g0 = g0 * tr2;
		/////// END GAUSS ////////
	}
	
	// Pack everything into block matrices
	matrix zb[nrows(b0)][ncols(b0)];
	matrix zf[nrows(f0)][ncols(f0)];
	matrix zg[nrows(g0)][ncols(g0)];

	matrix B = blockmat(zb, b1, b0, zb);
	matrix F = blockmat_nsq(f0, zf, zf, f1);
	matrix G = blockmat_nsq(g0, zg, zg, g1);
	
	if( size(#) != 0 )
	{
		list ret = B, F, G, transform_record;
		return(ret);
	}
	else
	{
		return(B);
	}
}

proc mfReduce_work(matrix b0, matrix b1, matrix f0, matrix f1, matrix g0, matrix g1)
{
	// By assumption b0 has the form (1 t \\ 0 s) and hence b1 is of the form (W d \\ 0 e)
	// where W is the potential. There is a homotopy equivalence between this matrix factorisation
	// and the factorisation (s, e)

	if( ncols(b0) == 1 ){ print("[mfReduce_work] Called with 1x1 matrices, exiting"); return(b0,b1,f0,f1,g0,g1); }
	
	//dbprint(printlevel, "   [mfReduce_work] ====");
	//dbprint(printlevel, "      Current b0"); dbprint(printlevel, b0);
	//dbprint(printlevel, "      Current b1"); dbprint(printlevel, b1);
	//dbprint(printlevel, "   =====================");
		
	// Read off s,e and t from b0 and b1
	int i,j;
	matrix S[nrows(b0)-1][ncols(b0)-1];
	for(i=2;i<=ncols(b0);i++){ for(j=2;j<=nrows(b0);j++){ S[j-1,i-1] = b0[j,i]; } }
	
	matrix E[nrows(b0)-1][ncols(b0)-1];
	for(i=2;i<=ncols(b0);i++){ for(j=2;j<=nrows(b0);j++){ E[j-1,i-1] = b1[j,i]; } }
	
	matrix T[1][ncols(b0)-1];
	for(i=2;i<=ncols(b0);i++){ T[1,i-1] = b0[1,i]; }
			
	// The homotopy equivalence between (b0, b1) and (s,e) is given by the morphism
	// ((0 1), (0 1)): (b0,b1) -> (s,e) and ((-t 1)^t, (0 1)^t): (s,e) -> (b0,b1)
	// so we need to stick these on the appropriate side of F, G
	
	// Matrix of (0 1)
	matrix zeroone[nrows(S)][ncols(S)+1];
	for(i=1;i<=nrows(S);i++){ zeroone[i,i+1] = 1; }
	
	matrix negtone[nrows(S)+1][ncols(S)];
	for(i=1;i<=nrows(S);i++){ negtone[i+1,i] = 1; }
	for(i=1;i<=ncols(S);i++){ negtone[1,i] = -T[1,i]; }
	
	// Modify f and g by the appropriate things
	matrix f0r = zeroone * f0;
	matrix f1r = zeroone * f1;
	matrix g0r = g0 * negtone;
	matrix g1r = g1 * transpose(zeroone);
	
	// Our return list is b0,b1,f0,f1,g0,g1
	list l = S, E, f0r, f1r, g0r, g1r;
	return (l);
}

// Returns 1 if there are no constant terms in A (other than zero), and zero otherwise
proc ismfReduced(matrix A)
{
	int i,j;
	for(i=1;i<=ncols(A);i++)
	{
		for(j=1;j<=ncols(A);j++)
		{
			if( deg(A[i,j]) == 0 && A[i,j] != 0 )
			{
				return(0);
			}
		}
	}
	
	return(1);
}

////////////////////////////////////////////////////////////////////
// matrixreduce
//
// After some bad experiences with examples I don't trust Singular's gaussian elimination
// routines, so here is a primitive version which is good enough for our purposes.
//
// The input is a square matrix M. The output is a matrix N and two invertible matrices P, Q
// formatted as a triple (N, P, Q) such that P M Q = N. If no entry of M is a unit then N = M
// and P = Q = id. Otherwise the top left entry of N is a 1 and the first column of N contains
// no other nonzero entries.

proc matrixreduce(matrix M)
{
	int mrank = ncols(M);
	matrix P = unitmat(mrank);
	matrix Q = unitmat(mrank);
	matrix N = M;
	
	// Let us find a constant entry in M
	int i,j;
	
	for(i=1;i<=mrank;i++)
	{
		for(j=1;j<=mrank;j++)
		{
			if( deg(M[i,j]) == 0 )
			{
				// We found our constant term, permute it to (1,1)
				P = 1/(M[i,j]) * permrow(P, 1,i);
				Q = permcol(Q, 1,j);
				N = P * M * Q;
				
				// Go through the first column and transform away everything
				int k;
				for(k=2;k<=mrank;k++)
				{
					if(N[k,1] != 0)
					{
						matrix Pn = unitmat(mrank);
						Pn[k,1] = - N[k,1];
						
						P = Pn * P;
						N = Pn * N;
					}
				}
				
				list l = N,P,Q;
				return(l);
			}
		}
	}

	// We failed to find a constant term, so return M, 1, 1
	list l = N, P, Q;
	return(l);
}

////////////////////////////////////////////////////////////////////
// MFtensor
//
// Takes as input a pair (A,B) of odd block 2x2 matrices which we interpret as a pair of differentials
// on Z/2-graded free modules X,Y resp. The return is the differential on the tensor product X x Y.

proc MFtensor(matrix A, matrix B)
{
	// There are two differentials A x 1 and B x 1 on the tensor product and we return their sum
	int arank = ncols(A);
	int brank = ncols(B);
	
	return( ZZtensor( unitmat(arank), B ) + ZZtensor( A, unitmat(brank) ) );
}

////////////////////////////////////////////////////////////////////
// MFdual
//
// Takes as input an odd block 2x2 matrix A which we interpret as a differential
// on a Z/2-graded free modules X. Returns the differential of the "dual" MF, namely
// if A = (0 a1 \\ a0 0) then we return (0 transpose(a0) \\ -transpose(a1) 0)

proc MFdual(matrix A)
{
	list blocks = extractblockmat(A);
	matrix z[nrows(A)/2][ncols(A)/2];
	matrix dual = blockmat_nsq( z, transpose(blocks[3]), -transpose(blocks[2]), z );
	return(dual);
}

////////////////////////////////////////////////////////////////////
// ZZtensor 
//
// Takes as input a pair (A,B) of block 2x2 matrices (square blocks of arbitrary size) which we interpret
// as a pair of endomaps of Z/2-graded free modules A: X -> X, B: Y -> Y according to the decompositions
// X = X0 + X1 and Y = Y0 + Y1. We assume that A, B are both homogeneous (i.e. either even or odd).
//
// Consider the tensor product Z = X x Y of Z/2-graded modules and the map A x B: Z -> Z which sends
// a homogeneous tensor f x g to (-1)^{|f||B|} A(f) x B(g). We return the matrix of this map with respect
// to the decomposition Z0 = (X0 x Y0) + (X1 + Y1) and Z1 = (X0 + Y1) x (X1 + Y0) of Z. The basis of
// X0 x Y0 is ordered in the usual way for a Kronecker product of matrices.

proc ZZtensor(matrix A, matrix B)
{
	//int arank = ncols(A)/2; // Size of blocks in A
	//int brank = ncols(B)/2; // Size of blocks in B
	
	// The blocks in Z are therefore of size 2 * arank * brank
	//int zrank = 2 * arank * brank;
	
	list la = extractblockmat(A);
	list lb = extractblockmat(B);
	
	matrix a11, a12, a21, a22, b11, b12, b21, b22;
	
	a11 = la[1]; a12 = la[2]; a21 = la[3]; a22 = la[4];
	b11 = lb[1]; b12 = lb[2]; b21 = lb[3]; b22 = lb[4];
	
	int degb = 0; // Default B to degree 0, i.e. even
	
	int brank = ncols(B)/2;
	matrix zero[brank][brank];
	matrix bigzero[ncols(B)][ncols(B)];
	
	if( B != bigzero && b11 == zero && b22 == zero ){ degb = 1; }
	
	// Define the four corners of Z, then use blockmat
	matrix z11 = blockmat( tensor(a11,b11), (-1)^(degb) * tensor(a12,b12), tensor(a21,b21), (-1)^(degb) * tensor(a22,b22) );
	matrix z12 = blockmat( tensor(a11,b12), (-1)^(degb) * tensor(a12,b11), tensor(a21,b22), (-1)^(degb) * tensor(a22,b21) );
	matrix z21 = blockmat( tensor(a11,b21), (-1)^(degb) * tensor(a12,b22), tensor(a21,b11), (-1)^(degb) * tensor(a22,b12) );
	matrix z22 = blockmat( tensor(a11,b22), (-1)^(degb) * tensor(a12,b21), tensor(a21,b12), (-1)^(degb) * tensor(a22,b11) );
	
	matrix Z = blockmat(z11,z12,z21,z22);
	
	return(Z);
}

////////////////////////////////////////////////////////////////////
// extractblockmat takes a block matrix (A B // C D) and returns a list {A, B, C, D}.
// We assume that the blocks each have half the width of the matrix, and half the height
// of the matrix (so we assume both are even, but we allow nonsquare blocks)

proc extractblockmat(matrix block)
{
	int nr = nrows(block)/2;
	int nc = ncols(block)/2;
	
	matrix a[nr][nc];
	matrix b[nr][nc];
	matrix c[nr][nc];
	matrix d[nr][nc];
	
	int i,j; // i is the row and j the column
	for(i=1;i <= nr; i++)
	{
		for(j=1;j <= nc; j++)
		{
			a[i,j] = block[i,j];
			b[i,j] = block[i,j+nc];
			c[i,j] = block[i+nr,j];
			d[i,j] = block[i+nr,j+nc];
		}
	}
	
	list l = a,b,c,d;
	return(l);
}

///////////// TESTS ///////////////

proc test_matrixreduce()
{
	int passed = 1;
	
	ring RR = 0,(x,y),dp;
	
	// Test 1
	matrix M[2][2] = x,5,x,1;
	list l = matrixreduce(M);
	matrix N[2][2] = 1,1/5*x,0,4/25*x;	
	if( l[1] != N || l[2] * M * l[3] != l[1] ){ passed = 0; }
	
	// Test 2
	matrix A[4][4] = 0,0,y,0,0,0,-1,y,y2,0,0,0,y,y2,-1,0;
	list b = matrixreduce(A);
	matrix B[4][4] = 1,0,0,-y,0,0,0,-y2,0,0,-y2,0,0,-y2,-y,y;
	
	if( b[1] != B || b[2] * A * b[3] != b[1] ){ passed = 0; }
	
	if( passed == 1 ){ print("All tests passed."); } else { print("Some tests failed."); }
}

proc test_ZZtensor()
{
	int passed = 1;
	
	// Test 1
	matrix A[2][2] = 1,0,0,1;
	matrix B[2][2] = 0,1,1,0;
	
	// The tensor product A x B should be the following matrix
	matrix AB[4][4] = 0, 0, 1, 0, 0, 0, 0, -1, 1, 0, 0, 0, 0, -1, 0, 0;
	
	if( AB != ZZtensor(A,B) ){ passed = 0; }
		
	if( passed == 1 ){ print("All tests passed."); } else { print("Some tests failed."); }
}

proc test_mfReduce()
{
	int passed = 1;
	
	// Test 1
	ring RR = 0,(x,y),dp;
	
	matrix d0[4][4] = 0,0,y,0,0,0,-1,y,y2,0,0,0,y,y2,-1,0;
	matrix d1[4][4] = 0,0,y,0,1,0,-1,y,y2,0,0,0,y,y2,0,0;
	matrix z[4][4];

	matrix d = blockmat(z,d1,d0,z);
	list l = mfReduce(d,1);
	
	matrix b = l[1];
	matrix f = l[2];
	matrix g = l[3];
	
	// B should be reduced and f: d -> b and g: b -> d should be morphisms
	if( f * d != b * f ){ passed = 0; }
	if( g * b != d * g ){ passed = 0; }
	
	if( passed == 1 ){ print("All tests passed."); } else { print("Some tests failed."); }
}