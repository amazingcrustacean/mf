version="0.1";
category="Miscellaneous";
// summary description of the library
info="
LIBRARY:   blow.lib  Compilation of defect webs
AUTHOR:    Nils Carqueville, Daniel Murfet
KEYWORDS:  matrix factorization

PROCEDURES:
";

LIB "linalg.lib";
LIB "matrix.lib";
LIB "ring.lib";

////////////////////////////////////////////////////////////////////
// USAGE GUIDE
//
// At the moment we expect our ambient ring to be of one of the types
//
//     0,(x(1..t),y(1..s)),dp    OR    (0,r),(x(1..t),y(1..s)),dp
// 
// for some integers t and s. The x variables are the "internal" variables.
// We always expect "r" to be the parameter defining an extension ring.
//
// In the second case where we define a ring extension, in addition to defining
// the minpoly we expect that before using this library an additional variable
// "minblowpoly" is defined, which is the minimum polynomial of r over Q expressed
// in terms of the variable x(1). For example
//
//    ring rr=(0,r),(x(1..t),y(1..s)),dp;
//    minpoly = r^2 + 1;
//    poly minpolyblow = x(1)^2 + 1;
//
// If minpolyblow or r is undefined we proceed by ignoring the ring extension.
//
// We assume currently in dQ, deltaQ and related routines that the polynomial
// we are passed is a sum of all the x-variables to some specific power.

////////////////////////////////////////////////////////////////////
// GRADED MATRIX FACTORISATIONS
//
// IMPORTANT: Following KR we make use of the grading on our polynomial rings where each
// variable has degree 2. This is NOT imposed on the level of Singular code, it just affects
// our convention for grading vectors (which terminology will be explained presently). Given
// a polynomial p we write deg(p) for the usual degree, as understood by Singular, and |p| for
// the doubled grading, so |p| = 2 * deg(p). Given a graded module M, M{1} denotes the module
// with grading M{1}_i = M_{i-1}.
//
// The doubled grading is adopted for the following reason: let R be a polynomial ring
// with this grading, and W an element of R of degree 2(n+1). If W = fg for homogeneous f,g
// then we can write W: R -> R as a composite of two maps g: R -> R{n+1-|g|} and f: R{n+1-|g|} -> R
// of graded R-modules of degree n+1.
//
// A matrix factorisation is represented by an odd supermatrix A giving the differential
// on some Z/2-graded free module X (over a polynomial ring). A _graded_ matrix factorisation
// is this differential together with an intvec g, whose length is equal to the number of
// columns in A, giving the "grading shift" on each free module in X. We require that the
// components a0 and a1 of A are then morphisms of graded modules of degree n+1 where the
// potential is of degree 2(n+1).
//
// For example, if X = X0 + X1 is a free module of rank 4, then g = (3 3 2 1) would express
// that as a graded module X0 = R{3} + R{3} and X1 = R{2} + R{1} where R is the polynomial
// ring with the doubled grading. Suppose that the potential W has |W| = 4, so n = 1. Then
// the differential A = (0, a1 \\ a0, 0) would have to consist of a morphism
// a0: R{3}+R{3} -> R{2}+R{1} of degree n+1 = 2, so 
// |a0[1,1]| = 3,
// |a0[1,2]| = 3,
// |a0[2,1]| = 4,
// |a0[2,2]| = 4
//
// NOTE: All operations on graded MFs assume that A is square (i.e. both degrees have
// the same rank).

//////////////////////////////////////////////////
// blowFLags
//
// Functions as a list of #define's.
// Change the return value, say of sanity_checks, to turn off sanity checks in all routines.
//
// NOTE: Singular's evaluation of a && b does not use shortcuts, it evaluates both a and
// b before doing the logical AND, so if you are using flags to avoid computation, you have
// to nest your if's. Bummer.

proc blowFlags(string s)
{
    if( s == "sanity_checks" )
    {
        return(1); 
    }
    
    return(0);
}

//////////////////////////////////////////////////////////////////////////////////
// numXVars - Returns the number of x variables (i.e. "nx")
//
// We assume that the ring is structured as described at the beginning of this document,
// so that the variables are x(1),..,x(t),y(1),...,y(s) for some integers t and s. This
// routine returns the integer t (possibly zero).
//////////////////////////////////////////////////////////////////////////////////

proc numXVars()
{
    list varNames = ringlist(basering)[2];
    
    int num = 0;
    int i;
    for(i=1;i<=size(varNames);i++)
    {
        if( varNames[i][1] == "x" )
        {
            num++;
        }
    }
    
    return(num);
}

//////////////////////////////////////////////////////////////////////////////////
// numYVars - Returns the number of y variables (i.e. "ny")
//
// We assume that the ring is structured as described at the beginning of this document,
// so that the variables are x(1),..,x(t),y(1),...,y(s) for some integers t and s. This
// routine returns the integer s (possibly zero).
//////////////////////////////////////////////////////////////////////////////////

proc numYVars()
{
    list varNames = ringlist(basering)[2];
    
    int num = 0;
    int i;
    for(i=1;i<=size(varNames);i++)
    {
        if( varNames[i][1] == "y" )
        {
            num++;
        }
    }
    
    return(num);
}

//////////////////////////////////////////////////////////////////////////////////
// "ringwithoutyvars" returns the ambient ring with y variables removed
// NOTE: We just return the ring, we do not change the current basering
//////////////////////////////////////////////////////////////////////////////////

proc ringWithoutYVars()
{
    def RRR = basering;
    int numX = numXVars();
    int numY = numYVars();

    // Define new ring -- exactly the same as RRR, but without the y-variables:
    // ringlist(RRR)[1] will be the characteristic followed by (possibly) the names of parameters
    if(size(ringlist(RRR)[1]) > 1)
    {
        int i,j,k;
        list L = ringlist(RRR);
        for(i=1;i<=numY;i++)
        {
            L[2] = delete(L[2],numX+1);
        }
        intvec kk = (1..numX);

        for(i=1; i<=numX; i++)
        {
            kk[i] = 1;
        }
        L[3][1][2] = kk;
        L[1][4][1] = 0;     // set minpoly to zero, put it back to the right value below...
        def nR = ring(L);

        // Now complete the correct definition of nR by specifying the right minpoly: 
        if( defined(minpolyblow) && defined(r) )
        {
            setring nR;
            poly P = imap(RRR,minpolyblow);
            poly z = subst(P,x(1),r);
            number nu = leadcoef(z);
            minpoly = nu;
        }
        else
        {
            print("[ringWithoutYVars] Ring parameter other than r, or unspecified minpolyblow. Please see the Usage Guide.");
        }
    }
    else
    {
        ring nR = char(RRR), x(1..numX), dp;
    }

    def newRing = basering;
    
    // Before returning the new ring, set the ambient ring as current
    setring RRR;
    
    return(newRing);
}


//////////////////////////////////////////////////////////////////////////////////
// "ringWithoutXVars" returns the ambient ring with x variables removed
// NOTE: We just return the ring, we do not change the current basering
//////////////////////////////////////////////////////////////////////////////////

proc ringWithoutXVars()
{
    def RRR = basering;
    int numX = numXVars();
    int numY = numYVars();
    
    // Define new ring -- exactly the same as RRR, but without the x-variables:
    // ringlist(RRR)[1] will be the characteristic followed by (possibly) the names of parameters
    if(size(ringlist(RRR)[1]) > 1)
    {
        int i,j,k;
        list L = ringlist(RRR);
        for(i=1;i<=numX;i++)
        {
            L[2] = delete(L[2],1);
        }
        intvec kk = (1..numY);

        for(i=1; i<=numY; i++)
        {
            kk[i] = 1;
        }
        L[3][1][2] = kk;
        L[1][4][1] = 0;     // set minpoly to zero, put it back to the right value below...
        def nR = ring(L);

        // Now complete the correct definition of nR by specifying the right minpoly: 
        if( defined(minpolyblow) && defined(r) )
        {
            poly K = subst(minpolyblow,x(1),y(1));
            setring nR;
            poly P = imap(RRR,K);
            poly z = subst(P,y(1),r);
            number nu = leadcoef(z);
            minpoly = nu;
        }
        else
        {
            print("[ringWithoutXVars] Ring parameter other than r, or unspecified minpolyblow. Please see the Usage Guide.");
        }
    }
    else
    {
        ring nR = char(RRR), y(1..numY), dp;
    }    
    
    def newRing = basering;
    
    // Before returning the new ring, set the ambient ring as current
    setring RRR;
    
    return(newRing);
}


//////////////////////////////////////////////////////////////////////////////////
// "dimAlgebraOverInternalVariables" Returns the dimension of the quotient of the
// polynomial ring in the internal variables (as returned by ringWithoutYVars) by the
// specified ideal (given as an ideal in the basering).
//////////////////////////////////////////////////////////////////////////////////

proc dimAlgebraOverInternalVariables(ideal J)
{
    def RRR = basering;
    def nR = ringWithoutYVars();
    setring nR;

    ideal J = imap(RRR,J);
    ideal Jstd = std(J);
    ideal ba = kbase(Jstd);
    int n = size(ba);

    setring RRR;

    return(n);
}

//////////////////////////////////////////////////////////////////////////////////
// "deltaInflationList" Returns a list containing, in order, the matrix representing
// the operator [g_i,x(i)^b] for b = 1,...,2*exponent - 1.
//////////////////////////////////////////////////////////////////////////////////

proc deltaInflationList(int i, int exponent, ideal J)
{
    int prl = printlevel;
    
    // Compute a k-basis of I
    def RRR = basering;
    def nR = ringWithoutYVars();
    setring nR;
    
    ideal J = imap(RRR,J);
    ideal Jstd = std(J);
    ideal basis = kbase(Jstd);
    module BB = reduce(basis,Jstd);

    int jdim = size(basis);
    int b, k;
    list deltaActions;
    
    for(b=1; b<= 2*exponent - 1; b++)
    {
        // Compute the matrix representing the operator [g_i, x(i)^b] on I = nR/J
        list L;
        for(k=1; k<=jdim; k++)
        {
            // First compute g_i( x(i)^b * - ) on our basis element
            poly f1 = ( x(i)^b * basis[k] - reduce(x(i)^b * basis[k],std(x(i)^exponent)) )/(x(i)^exponent);

            // Next compute x(i)^b * g_i(-)
            poly f2 = x(i)^b * ( basis[k] - reduce(basis[k],std(x(i)^exponent)) )/(x(i)^exponent);

            // To our output matrix we add the expression of the commutator f1 - f2 in the
            // chosen basis of the algebra I
            module ff = reduce(f1 - f2,Jstd);
            matrix MM = matrix(reduce(lift(BB,ff),std(syz(BB))));
            L = L + list(MM);
            kill f1,f2,ff,MM;
        }

        matrix U = L[1];
        for(k=2; k<=jdim; k++)
        {
            U=concat(U,L[k]);
        }
                
        deltaActions = deltaActions + list(U);
        kill U, L;
    }
    
    setring RRR;
    list deltaActions = imap(nR,deltaActions);
    
    return(deltaActions);
}

//////////////////////////////////////////////////////////////////////////////////
// "variableInflationList" Returns a list containing, in order, the matrix representing
// the action of each of the internal variables on k[x]/J (the internal algebra).
//////////////////////////////////////////////////////////////////////////////////

proc variableInflationList(ideal J)
{
    int prl = printlevel;

    def RRR = basering;
    def nR = ringWithoutYVars();
    setring nR;
    
    ideal Jx = std(imap(RRR,J));
    ideal basis = kbase(Jx);
    int jdim = size(basis);
    module BB = reduce(basis,Jx);
    module syzBB = std(syz(BB)); 
    
    int i, k;
    list variableActions;
    int numX = nvars(nR);
    
    for(i=1; i<=numX; i++)
    {
        list L;
        for(k=1; k<=jdim; k++)
        {
            module ff = reduce(x(i)*basis[k],Jx);
            matrix MM = matrix(reduce(lift(BB,ff), syzBB));
            L = L + list(MM);
        }

        matrix U = L[1];
        for(k=2; k<=jdim; k++)
        {
            U=concat(U,L[k]);
        }
        
        variableActions = variableActions + list(U);
        kill U, L;
    }
    
    setring RRR;
    list variableActions = imap(nR,variableActions);
    
    return(variableActions);
}

//////////////////////////////////////////////////////////////////////////////////
// "poly2matrix" blows up a polynomial into a matrix: x-monomials are replaced by
// the matrices that represent the former's action on the algebra k[x-variables]/J
//
// NOTE: We assume that the algebra k[x-variables]/J is finite-dimensional.
//
// We must be passed a list "variableActions" which gives, in order, the matrices
// representing the action of multiplication by each internal variable on the
// internal algebra (as given by variableInflationList).
//
// To avoid computing it repeatedly, we also require that the dimension jdim of
// the internal algebra be given to us.
//////////////////////////////////////////////////////////////////////////////////

proc poly2matrix(poly tepo, ideal J, list variableActions, int jdim)
{
    // First compute the x-monomials and their coefficients in tepo
    int i;
    poly xprod = 1;
    int numX = numXVars();
    
    for(i=1; i<=numX; i++)
    {
        xprod = xprod * x(i);
    }
    matrix koffer = coef(tepo, xprod);

    int u,k;
    matrix inflation[jdim][jdim];
    
    for(u=1;u<=ncols(koffer);u++)
    {
        // Each column of koffer represents an x-monomial, let us now factorize this.
        // The list powers contains, in order, the power of each internal variable
        // in monom + 1 (since we multiply by xprod to make sure all vars appear)
        poly monom = koffer[1,u];
        intvec powers = factorize(monom*xprod,2)[2];
        matrix monomAction = unitmat(jdim);
        
        for(k=1;k<=numX;k++)
        {
            monomAction = monomAction * power(variableActions[k],powers[k]-1);
        }
        
        inflation = inflation + koffer[2,u] * monomAction;
        
        kill monom, powers, monomAction;
    }
    
    return(inflation);
}


//////////////////////////////////////////////////////////////////////////////////
// "mablow" blows up a matrix by blowing up all its entries using poly2matrix.
// The matrix M may be non-square.
//////////////////////////////////////////////////////////////////////////////////

proc mablow(matrix M, ideal J)
{
    int benchmark = 1; // Set to 1 to output benchmarking data
    
    // Compute dimension of the algebra k[x-vars]/J
    int n = dimAlgebraOverInternalVariables(J);
    
    // Roughly speaking mablow takes "difficulty" ms to complete. We only give
    // debugging output if this is likely to take > 10 seconds
    int difficulty = nrows(M) * ncols(M) * n / 3;
    if( difficulty > 10000 )
    {
        if( benchmark )
        {
            system("--ticks-per-sec",1000);
            int timeElapsed = timer;
        }
        
        dbprint(printlevel, "[mablow] Inflating " + string(nrows(M)) + "x" + string(ncols(M)) + " matrix by " + string(n) + "-dim algebra");
    }
    
    // Compute the inflation of individual variables
    list variableActions = variableInflationList(J);
    
    // Define L to be an appropriately indexed list of blown-up matrices:
    int i1,j1,i2,j2,i;
    
    int ncolsM = ncols(M);
    int nrowsM = nrows(M);
    
    list e,L;
    for(i=1; i<=nrowsM; i++)
    {
        L[i] = e;
    }
    for(i1=1; i1<=nrowsM; i1++) // row
    {
        //dbprint(printlevel,"[mablow] Iteration count " + string(i1) + "/" + string(nrowsM));
        for(j1=1; j1<=ncolsM; j1++) // column
        {
            matrix PM = poly2matrix(M[i1,j1], J, variableActions, n);
            L[i1][j1] = PM;
            kill PM;
        }
    }

    matrix A[nrowsM*n][ncolsM*n];

    for(i1=1; i1<=nrowsM; i1++)
    {
        //dbprint(printlevel,"[mablow] Assembly count " + string(i1) + "/" + string(nrowsM));
        for(j1=1; j1<=n; j1++)
        {
            for(i2=1; i2<=ncolsM; i2++)
            {
                for(j2=1; j2<=n; j2++)
                {
                    A[(i1-1)*n + j1, (i2-1)*n + j2] = L[i1][i2][j1,j2];
                }
            }
        }
    }
    
    if( benchmark && difficulty > 10000 )
    {
        timeElapsed = timer - timeElapsed;
        dbprint(printlevel, "[mablow]            elapsed time " + string(timeElapsed) + "ms.");
    }

    return(A);
}

//////////////////////////////////////////////////////////////////////////////////
// "mablowGrading" returns the grading vector for an inflated MF, given the grading
// vector of the original MF and the ideal to inflate with. We use the basis for 
// R/J given by reduce(kbase(std(J)),std(J)).
//
// The underlying graded free module of the MF is R{g[1]} + R{g[2]} + ... and
// the underlying graded free module of the inflation is a direct sum of modules
// of the form R{g[i]} x R/J which has the usual grading. Obviously this only makes
// sense if J is a graded ideal.
//////////////////////////////////////////////////////////////////////////////////

proc mablowGrading(intvec g, ideal J, int N)
{
    def RRR = basering;
    
    def nR = ringWithoutYVars();
    setring nR;
        
    ideal J = imap(RRR,J);
    ideal Jstd = std(J);
    ideal basis = kbase(Jstd);
    int jdim = size(basis);
    module BB = reduce(basis,Jstd);
        
    intvec r;   
    
    // There is an overall grading shift given by the sum of the degrees of
    // the generators of J, plus an additional N + 1 for each generator
    int k;
    int E;
    for(k=1;k <= size(J);k++)
    {
        E = E - 2 * deg(J[k]) + N + 1;
    }
    
    int i,j;
    for(i=1;i <= size(g); i++)
    {
        for(j=1;j<=jdim;j++)
        {
            //r[(i-1)*jdim + j] = g[i] + 2 * deg(BB[j]); //DEBUG this is the original
            r[(i-1)*jdim + j] = g[i] + 2 * deg(BB[j]) + E; 
        }
    }
    
    setring RRR;
    
    return(r);
}

//////////////////////////////////////////////////////////////////////////////////
// "poly2matrix_delta"
//
// Let us write nR for the basering without its y-variables.
//
// Given a polynomial in the x and y-variables and an integer i, we return a matrix
// in only the y-variables, where the x monomials are "inflated" by their action on
// the algebra I = nR/J.
//////////////////////////////////////////////////////////////////////////////////

proc poly2matrix_delta(poly tepo, ideal J, int i, int exponent, list variableActions, list deltaActions, int jdim)
{
    // First compute the x-monomials and their coefficients in tepo
    int t;
    poly xprod = 1; 
    int numX = numXVars();
    for(t=1; t<=numX; t++)
    {
        xprod = xprod * x(t);
    }
    matrix koffer = coef(tepo, xprod);

    int u,k;
    matrix inflation[jdim][jdim];
    
    for(u=1;u<=ncols(koffer);u++)
    {
        // Each column of koffer represents an x-monomial, let us now factorize this.
        // The list powers contains, in order, the power of each internal variable
        // in monom + 1 (since we multiply by xprod to make sure all vars appear)
        poly monom = koffer[1,u];
        intvec powers = factorize(monom*xprod,2)[2];
        matrix monomAction = unitmat(jdim);
        
        for(k=1;k<=numX;k++)
        {
            // If k is not equal to i, then we just take the usual inflation,
            // but for k = i we do the "delta" inflation
            if( k != i )
            {
                monomAction = monomAction * power(variableActions[k],powers[k]-1);
            }
            else
            {
                // We have to multiply by a factor corresponding to x(i)^(powers[k]-1),
                // which is the action on the internal algebra of the operator
                // [g_i,x(i)^(powers[k]-1)], as recorded in deltaActions. If the exponent
                // is between one and 2 * exponent - 1 we use the array. Otherwise the
                // operator is zero, so multiply by zero.

                if( powers[k] - 1 >= 1 && powers[k] - 1 <= 2*exponent - 1)
                {
                    monomAction = monomAction * deltaActions[powers[k]-1];
                }
                else
                {
                    monomAction = 0 * monomAction;
                }
            }
        }
        
        inflation = inflation + koffer[2,u] * monomAction;
        
        kill monom, powers, monomAction;
    }
    
    return(inflation);
}

/////////////////////////////////////////////////////////////////////////////////////////
// "mablow_delta" blows up a matrix by blowing up all its entries using poly2matrix_delta
//
// exponent is the integer such that g_i is division without remainder by x(i)^exponent.
/////////////////////////////////////////////////////////////////////////////////////////

proc mablow_delta(matrix M, int i, int exponent, ideal J)
{
    // Compute dimension of the algebra k[x-vars]/J
    int n = dimAlgebraOverInternalVariables(J);
 
    // Compute the ordinary inflation of individual variables
    list variableActions = variableInflationList(J);
    
    // Compute the delta inflation [g_i,x(i)^b] for all integers b
    list deltaActions = deltaInflationList(i,exponent,J);
 
    // Define L to be an appropriately indexed list of blown-up matrices:
    int i1,j1,i2,j2,t;
    int s = ncols(M);
 
    list e,L;
    for(t=1; t<=s; t++)
    {
        L[t] = e;
    }
    for(i1=1; i1<=s; i1++)
    {
        for(j1=1; j1<=s; j1++)
        {
            L[i1] = insert(L[i1], poly2matrix_delta(M[i1,j1], J, i, exponent, variableActions, deltaActions, n),j1-1);
        }
    }   
    
    matrix A[s*n][s*n];

    for(i1=1; i1<=s; i1++)
    {
        for(j1=1; j1<=n; j1++)
        {
            for(i2=1; i2<=s; i2++)
            {
                for(j2=1; j2<=n; j2++)
                {
                    A[(i1-1)*n + j1, (i2-1)*n + j2] = L[i1][i2][j1,j2];
                }
            }
        }
    }

    return(A);
}

/////////////////////////////////////////////////////////////////////////////////////
// "SGroupintvecs" produces the n! permutations of (1,...,n) as a list of intvecs.
/////////////////////////////////////////////////////////////////////////////////////

proc SGroupintvecs(int n)
{
    LIB "qmatrix.lib";
    list L;
    int i;
    
    intmat M = SymGroup(n);
    
    for(i=1; i<=nrows(M); i++)
    {
        intvec c = M[i,1..n];
        L[i] = c;
    }

    return(L);
}


/////////////////////////////////////////////////////////////////////////////////////
// "deltaQ" is \delta Q^{\wedge n} (where below we have F=Q)
//
// q is an intvec containing the exponents responsible for defining the operators g_i,
// so that g_i is division by x(i)^q[i] without remainder.
/////////////////////////////////////////////////////////////////////////////////////

proc deltaQ(matrix F, intvec q)
{
    LIB "matrix.lib";
    
    // The ideal whose quotient gives the algebra I is generated by the internal
    // variables to the powers given by q
    int i;
    ideal J;
    int numX = numXVars();
    
    for( i = 1; i <= numX; i++ )
    {
        J[i] = x(i)^(q[i]);
    }

    int n = dimAlgebraOverInternalVariables(J);
    int prl = printlevel;

    // The blown up matrix will be of dimension n x ncols(f)
    int gg = ncols(F) * n;

    list S = SGroupintvecs(numX);

    int j;    
    matrix Mi[gg][gg];

    // Precompute all the deltas
    list deltas; 
    for(j = 1; j <= numX; j++)
    {
        deltas[j] = mablow_delta(F, j, q[j], J);
    }
    
    for(i=1; i<=size(S); i++)
    {
        intvec perm = S[i];
        matrix Ma = (-1)^(LengthSymElement(perm)) * unitmat(gg);
        
        for(j=1; j<=numX; j++)
        {
            Ma = Ma * deltas[perm[j]];
        }
        
        Mi = Mi + Ma; 
    }

    // Multiply by the scaling factor:
    number ffac = 1;
    for(i=1; i<=numX; i++)
    {
        ffac = ffac / i;
    }
    Mi = ffac * Mi;

    return(Mi);
}


/////////////////////////////////////////////////////////////////////////////////////
// "dQ" is d Q_X^{\wedge n} (where below we have f=Q_X)
/////////////////////////////////////////////////////////////////////////////////////
// TODO: May be faster to compute dQ_X first, then mablow the result, rather than
// mablowing every factor

proc dQ(matrix f, intvec q, matrix C)
{
    LIB "matrix.lib";
    poly detC = det(C);
    
    // The ideal whose quotient gives the algebra I is generated by the internal
    // variables to the powers given by q
    int i;
    ideal J;
    int numX = numXVars();
    
    for( i = 1; i <= numX; i++ )
    {
        J[i] = x(i)^(q[i]);
    }

    int n = dimAlgebraOverInternalVariables(J);
    
    // The blown up matrix will be of dimension n x ncols(f)
    int gg = ncols(f) * n;

    list S = SGroupintvecs(numX);
    int j;

    matrix Mi[gg][gg];

    // Precompute all the mablows
    list dels; 
    for(j = 1; j <= numX; j++)
    {
        dels[j] = mablow(diff(f,x(j)), J);
    }

    // TODO: Probably these summands are all equal and there is no point summing over
    // n! of them.
    for(i=1; i<=size(S); i++)
    {
        intvec perm = S[i];
        matrix Ma = (-1)^(LengthSymElement(perm)) * unitmat(gg);    
        
        //print("[dQ] Permutation is " + string(perm) + " with sign " + string(LengthSymElement(perm)));
        for(j=1; j<=numX; j++)
        {
            Ma = Ma * dels[perm[j]];
        }
        
        //print("[dQ] Adding summand"); print(Ma);
        Mi = Mi + Ma; 
    }

    // Multiply with detC
    Mi = mablow( detC * unitmat(ncols(f)), J) * Mi;

    // Multiply by the scaling factor
    number ffac = 1;
    for(i=1; i<=numX; i++)
    {
        ffac = ffac / i;
    }
    Mi = ffac * Mi;
    
    return(Mi);
}


/////////////////////////////////////////////////////////////////////////////////////
// "varTrans" gives a list L of with two entries:
// -- L[1]: an intvec q used to define g_i as division by x(i)^q[i] without remainder
// -- L[2]: a matrix C such that x(i)^q[i] = \sum_j C_{i,j} \partial_j W
// This is possible if and only if the Jacobi algebra of W is finite
// dimensional, and we assume this is the case (otherwise this proc
// may not terminate).
/////////////////////////////////////////////////////////////////////////////////////

proc varTrans(poly W)
{
    def RRR = basering;
    def nR = ringWithoutYVars();
    setring nR;

    poly W = imap(RRR, W);
    ideal jaci = jacob(W);
    ideal J = std(jaci);
    int numVars = nvars(nR);

    int i,j,expo;
    intvec qvec;
    poly K;

    // Find the smallest possible integers qvec[i] such that x(i)^qvec[i] is in jacob(W):
    for(i=1; i<=numVars; i++)
    {
        int expo = 1;
        while( reduce( x(i)^expo, J ) != 0 )
        {
            expo++;
        }
        
        qvec[i] = expo;
    }

    // Define transformation matrix C:
    matrix C[numVars][numVars];
    for(i=1; i<=numVars; i++)
    {
        for(j=1; j<=numVars; j++)
        {
            C[j,i] = lift( jaci, x(j)^(qvec[j]) )[i,1];
        }
    }
    
    // Check that C does transform the partials to powers of the variables
    for(i=1;i<=numVars;i++)
    {
        poly f;
        int j;
        for(j=1;j<=numVars;j++)
        {
            f = f + C[i,j] * diff(W,x(j));
        }

        if( f != x(i)^(qvec[i]) )
        {
            print("[varTrans] Failed to compute transformation matrix correctly, exiting.");
            return();
        }
    }

    setring RRR;
    matrix C = imap(nR, C);
    list L = qvec, C;
    
    return(L);
}


/////////////////////////////////////////////////////////////////////////////////////
// "constantpart(P)" computes the constant part of a polynomial P.
/////////////////////////////////////////////////////////////////////////////////////

proc constantpart(poly P)
{
int i;
int n = nvars(basering);
matrix C;
C[1,1] = P;
for(i=1; i<=n; i++)
{
C = coeffs( C[1,1], var(i) );
}
return(C[1,1]);
}


/////////////////////////////////////////////////////////////////////////////////////
// "permuterows(M, a, b)" permutes the rows a and b of a matrix M.
/////////////////////////////////////////////////////////////////////////////////////

proc permuterows(matrix M, int a,b)
{
int i;
int s = ncols(M);
for(i=1; i<=s; i++)
{
poly pa = M[a,i];
poly pb = M[b,i];
M[a,i] = pb;
M[b,i] = pa;
}
return(M);
}


/////////////////////////////////////////////////////////////////////////////////////
// "permutecols(M, a, b)" permutes the columns a and b of a matrix M.
/////////////////////////////////////////////////////////////////////////////////////

proc permutecols(matrix M, int a,b)
{
int i;
int s = nrows(M);
for(i=1; i<=s; i++)
{
poly pa = M[i,a];
poly pb = M[i,b];
M[i,a] = pb;
M[i,b] = pa;
}
return(M);
}

/////////////////////////////////////////////////////////////////////////////////////
// "rocoreduce(M)" gives a list L with
// -- L[1] = row & column reduced version M' of M such that M'=diag(A,B), where A is
//    a diagonal matrix with only constant entries, and B is a block matrix without
//    nonzero constant entries,
// -- L[2] = UL (invertible over the polynomial ring),
// -- L[3] = UR (invertible over the polynomial ring) such that M' = UL * M * UR.
//
// NOTE: There must be some typos or other mistakes somewhere, as the similarity
//       transformations constructed do not reproduce the reduced matrix. Don't try
//       to fix this for the moment but use Dan's mfReduce instead (but leave don't
//       delete this code, it might be useful at some later point.)
/////////////////////////////////////////////////////////////////////////////////////

proc rocoreduce(matrix M)
{
int i,j,k,r;
int s = ncols(M);

// These will become the similarity matrices that describe the isomorphism 
// between M and its reduced form:
matrix UL = unitmat(s);
matrix UR = unitmat(s);

// z is a counter (in the end, z will be the number of trivial MFs that we can split off):

int z;
for(i=1; i<=s; i++)
{

for(j=1; j<=s; j++)
{
if(constantpart(M[i,j]) == M[i,j] and M[i,j] != 0)
{
// Bring the constant to the diagonal entry (z+1,z+1), and implement effect on UL,UR:
M = permutecols(M, j, z+1);
matrix U = unitmat(s); U[j,j]=0; U[z+1,z+1]; U[j,z+1]=1; U[z+1,j]=1;
UR = UR * U;
M = permuterows(M, i, z+1);
matrix U = unitmat(s); U[i,i]=0; U[z+1,z+1]; U[i,z+1]=1; U[z+1,i]=1;
UL = U * UL;

z = z+1;

// Use column manipulations to kill all (k,z)-entries of M for k>z:
for(k=z+1; k<=s; k++)
{
int s = nrows(M);
poly P = M[z,k]/M[z,z];

// effect on similarity matrix UR:
matrix U = unitmat(s);
U[z,k] = - P;
UR = UR * U;

for(r=1; r<=s; r++)
{
M[r,k] = M[r,k] - P * M[r,z];
}
}// end k-loop

// Use row manipulations to kill all (z,k)-entries of M for k>z:
for(k=z+1; k<=s; k++)
{
int s = ncols(M);
poly P = M[k,z]/M[z,z];

// effect on similarity matrix UL:
matrix U = unitmat(s);
U[k,z] = - P;
UL = U * UL;

for(r=1; r<=s; r++)
{
M[k,r] = M[k,r] - P * M[z,r];
}
}// end k-loop

break;
}
}// end j-loop

}// end i-loop

list L = M,UL,UR;
return(L);
}


//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// old stuff to compute cohomologies:
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
proc rdsum(matrix A, int r)
{
list B;
B[1]=A;
for (int i=2; i<=r; i++)
{
B[i]=dsum(B[i-1],A);
}
return(B[r]);
}
//-----------------------------------------------------------------------------
proc dminus(matrix f,g,f',g')
{
int r=nrows(f);
int r'=nrows(f');
matrix P1=concat(tensor(f',unitmat(r)), rdsum(-transpose(f),r'));
matrix P2=concat(rdsum(transpose(-g),r'),tensor(g',unitmat(r)));
matrix P[2*r*r'][2*r*r']=P2,P1;
return(P);
}
//-----------------------------------------------------------------------------
proc dplus(matrix f,g,f',g')
{ 
int r=nrows(f);
int r'=nrows(f');
matrix P1=concat(rdsum(transpose(f),r'),tensor(g',unitmat(r)));
matrix P2=concat(tensor(f',unitmat(r)),rdsum(transpose(g),r'));
matrix P[2*r*r'][2*r*r']=P1,P2;
return(P);
}
//-----------------------------------------------------------------------------
proc vector2matrix(list V, int r, int r')
{
int i,j,k;
list M;
matrix ma[2*r'][2*r];
for(i=1; i<=size(V); i++){M = M + list(ma);}
for(i=1; i<=size(V); i++)
 {for(j=1; j<=r; j++)
  {for(k=1; k<=r'; k++)
   {M[i][k,j] = V[i][(k-1)*r + j, 1];
    M[i][k+r',j+r] = V[i][(r'-1+k)*r + j, 1];
   }
  }
 }
return(M);
}
//-----------------------------------------------------------------------------
proc vector2matrixFerm(list V, int r, int r')
{
int i,j,k;
list M;
matrix ma[2*r'][2*r];
for(i=1; i<=size(V); i++){M = M + list(ma);}
for(i=1; i<=size(V); i++)
 {for(j=1; j<=r; j++)
  {for(k=1; k<=r'; k++)
   {M[i][k,j+r] = V[i][(k-1)*r + j, 1];
    M[i][k+r',j] = V[i][(r'-1+k)*r + j, 1];
   }
  }
 }
return(M);
}
//-----------------------------------------------------------------------------
proc matrix2vector(matrix M)
{
int r1 = ncols(M)/2;
int r2 = nrows(M)/2;
int i,ii,j,k;
vector v;
// bosonic part:
for(ii=1; ii<= r2; ii++)
{
for(j=1; j<= r1; j++)
{
v = v + gen((ii-1)*r1 + j)*M[ii,j];
}}
for(ii=1; ii<= r2; ii++)
{
for(j=1; j<= r1; j++)
{
v = v + gen(r1*r2 + (ii-1)*r1 + j)*M[ii+r2,j+r1];
}}
// fermionic part:
for(i=1; i<= r2; i++)
{
for(j=1; j<= r1; j++)
{
v = v + gen(2*r1*r2 + (i-1)*r1 + j)*M[i,j+r1];
}}
for(i=1; i<= r2; i++)
{
for(j=1; j<= r1; j++)
{
v = v + gen(2*r1*r2 + r1*r2 + (i-1)*r1 + j)*M[i+r2,j];
}}

return(v);
}
//-----------------------------------------------------------------------------
proc MFco(matrix f,g,f',g')
{
module M=syz(dminus(f,g,f',g'));
matrix Mker=M;
module Q=modulo(M,module(dplus(f,g,f',g')));
matrix base=kbase(std(Q));
matrix m = Mker*base;

module Mf=syz(dplus(f,g,f',g'));
matrix Mkerf=Mf;
module Qf=modulo(Mf,module(dminus(f,g,f',g')));
matrix basef=kbase(std(Qf));
matrix mf = Mkerf*basef;

int i;
int r = ncols(f);
int r' = ncols(f');
matrix ma[2*r'][2*r];
list L;
for(i=1; i<=ncols(m); i++){L = L + list(ma);}
intvec v1 = 1..nrows(m);
intvec v2;

list Lf;
for(i=1; i<=ncols(mf); i++){Lf = Lf + list(ma);}
intvec vf1 = 1..nrows(mf);
intvec vf2;

for(i=1; i<=ncols(m); i++)
{
intvec v2 = i;
L[i] = submat(m,v1,v2);
}

for(i=1; i<=ncols(mf); i++)
{
intvec vf2 = i;
Lf[i] = submat(mf,vf1,vf2);
}


list MMb = vector2matrix(L, r, r');
list MMf = vector2matrixFerm(Lf, r, r');

matrix null[2*r'][2*r];
list leer;
if(MMb[1] == null)
{MMb = leer;}
if(MMf[1] == null)
{MMf = leer;}


list MM;
MM[1] = MMb;
MM[2] = MMf;

return(MM);
}


//-----------------------------------------------------------------------------
proc MFcofull(matrix QQQ,PPP)
{
    matrix f = blocksq(QQQ)[3];
    matrix g = blocksq(QQQ)[2];
    matrix f' = blocksq(PPP)[3];
    matrix g' = blocksq(PPP)[2];

    module M=syz(dminus(f,g,f',g'));
    matrix Mker=M;
    module Q=modulo(M,module(dplus(f,g,f',g')));
    matrix base=kbase(std(Q));
    matrix m = Mker*base;

    module Mf=syz(dplus(f,g,f',g'));
    matrix Mkerf=Mf;
    module Qf=modulo(Mf,module(dminus(f,g,f',g')));
    matrix basef=kbase(std(Qf));
    matrix mf = Mkerf*basef;

    int i;
    int r = ncols(f);
    int r' = ncols(f');
    matrix ma[2*r'][2*r];
    list L;
    for(i=1; i<=ncols(m); i++){L = L + list(ma);}
    intvec v1 = 1..nrows(m);
    intvec v2;

    list Lf;
    for(i=1; i<=ncols(mf); i++){Lf = Lf + list(ma);}
    intvec vf1 = 1..nrows(mf);
    intvec vf2;

    for(i=1; i<=ncols(m); i++)
    {
        intvec v2 = i;
        L[i] = submat(m,v1,v2);
    }

    for(i=1; i<=ncols(mf); i++)
    {
        intvec vf2 = i;
        Lf[i] = submat(mf,vf1,vf2);
    }

    list MMb = vector2matrix(L, r, r');
    list MMf = vector2matrixFerm(Lf, r, r');

    matrix null[2*r'][2*r];
    list leer;
    if(MMb[1] == null)
        {MMb = leer;}
    if(MMf[1] == null)
        {MMf = leer;}

    list MM;
    MM[1] = MMb;
    MM[2] = MMf;

    return(MM);
}

// blockmat(A,B,C,D) gives the block-matrix {{A,B},{C,D}} if the square matrices A,B,C,D all have the same size.

proc blockmat(matrix block1,matrix block2,matrix block3,matrix block4)
{
int i,j;
int r=ncols(block1);
matrix m[2*r][2*r];
for(i=1;i<=r;i++){for(j=1;j<=r;j++){m[i,j]=block1[i,j];}}
for(i=1;i<=r;i++){for(j=r+1;j<=2*r;j++){m[i,j]=block2[i,j-r];}}
for(i=r+1;i<=2*r;i++){for(j=1;j<=r;j++){m[i,j]=block3[i-r,j];}}
for(i=r+1;i<=2*r;i++){for(j=r+1;j<=2*r;j++){m[i,j]=block4[i-r,j-r];}}
return(m);
}

// Modification of blockmat to accommodate nonsquare entries (consider replacing blockmat with this)
// We assume only that a block matrix makes sense, i.e. that in the order given the matrices fit
// together into a matrix. Here is the ASCII diagram
//
//       a        b
//   ----------|-------|
//   |         |       |
//   |    1    |   2   |
// c |         |       |
//   |---------|-------|
// d |     3   |   4   |
//   |---------|-------|
//
// where we allow a, b, c, d to be arbitrary

proc blockmat_nsq(matrix block1,matrix block2,matrix block3,matrix block4)
{
    int i,j;
    int a = ncols(block1);
    int b = ncols(block2);
    int c = nrows(block1);
    int d = nrows(block3);
    
    // Sanity check
    if( a != ncols(block3) || b != ncols(block4) || c != nrows(block2) || d != nrows(block4) )
    {
        print("[blockmat] Incorrect block sizes, exiting.");
        return();
    }
    
    int nc=ncols(block1);
    int nr=nrows(block1);
    matrix m[c + d][a + b];

    for(i=1;i<=c;i++){for(j=1;j<=a;j++){m[i,j]=block1[i,j];}}
    for(i=1;i<=c;i++){for(j=a+1;j<=a+b;j++){m[i,j]=block2[i,j-a];}}
    for(i=c+1;i<=c+d;i++){for(j=1;j<=a;j++){m[i,j]=block3[i-c,j];}}
    for(i=c+1;i<=c+d;i++){for(j=a+1;j<=a+b;j++){m[i,j]=block4[i-c,j-a];}}
    return(m);
}


// To get blocks from block square matrix returns list (1-4 of blocks)

proc blocksq(matrix m)
{
int n=nrows(m);
int intnon2=n/2;
number non2=number(n)/2;
if(n!=ncols(m))
{
    printf("Matrix should be square");
    return();
}
if(non2!=intnon2)
{
    printf("Matrix should have an even number of rows/columns");
    return();
}
matrix block1[intnon2][intnon2]=submat(m,1..intnon2,1..intnon2);
matrix block2[intnon2][intnon2]=submat(m,1..intnon2,intnon2+1..n);;
matrix block3[intnon2][intnon2]=submat(m,intnon2+1..n,1..intnon2);;
matrix block4[intnon2][intnon2]=submat(m,intnon2+1..n,intnon2+1..n);;
list L=block1,block2,block3,block4;
kill n,intnon2,non2,block1,block2,block3,block4;
return(L);
}

////////////////////////////////////////////////////////////////////
// zeromat - Returns a square zero matrix of the specified size if
// called with one parameter, and a zero matrix of size n x m if called
// with two parameters n, m
////////////////////////////////////////////////////////////////////

proc zeromat(int n, list #)
{
    if( size(#) == 0 )
    {
        matrix M[n][n];
        return(M);
    }
    else
    {
        int m = #[1];
        matrix M[n][m];
        return(M);
    }
}

////////////////////////////////////////////////////////////////////
// mfSuspend
// 
// Returns the suspension of the given matrix factorisation. If called
// with no additional parameters we suspend once, otherwise we suspend
// the number of times indicated by the second parameter.

proc mfSuspend(matrix A, list #)
{
    int power = 1;
    
    if( size(#) != 0 ){ power = #[1]; }
    
    list blocks = extractblockmat(A);
    matrix a0 = blocks[3]; matrix a1 = blocks[2];
    
    matrix z[ncols(A)/2][ncols(A)/2];
    
    if( power mod 2 == 0 )
    {
        // The power is even, so return the original MF
        return(A);
    }
    else
    {
        // The power is odd, so suspend
        matrix Asusp = blockmat(z, -1 * a0, -1 * a1, z);
        return(Asusp);
    }
}

proc mfSuspendGrading(intvec g, list #)
{
    int power = 1;
    
    if( size(#) != 0 ){ power = #[1]; }
    
    if( power mod 2 == 0 )
    {
        return(g);
    }
    else
    {
        int n = size(g)/2;
        intvec r = g[(n+1)..2*n], g[1..n];
    
        return(r);
    }
}

////////////////////////////////////////////////////////////////////
// mfSuspendMorph
// 
// Returns the suspension of the given even morphism of matrix factorisations. If called
// with no additional parameters we suspend once, otherwise we suspend
// the number of times indicated by the second parameter.

proc mfSuspendMorph(matrix A, list #)
{
    int power = 1;
    
    if( size(#) != 0 ){ power = #[1]; }
    
    list blocks = extractblockmat(A);
    matrix a0 = blocks[1]; matrix a1 = blocks[4];
    
    matrix z[nrows(A)/2][ncols(A)/2];
    
    if( power mod 2 == 0 )
    {
        // The power is even, so return the original MF
        return(A);
    }
    else
    {
        // The power is odd, so suspend
        matrix Asusp = blockmat_nsq(a1, z, z, a0);
        return(Asusp);
    }
}

////////////////////////////////////////////////////////////////////
// mfStrictifyIdempotent
//
// Takes as input an odd block matrix A interpreted as the differential on a Z/2-graded free module X,
// and an even block matrix U interpreted as an endomorphism of X, satisfying U * U = U up to homotopy.
// We return, where possible, an even block matrix E representing an endomorphism of X homotopy
// equivalent to U which is strictly idempotent, meaning that E * E = E as chain maps.
//
// Here "where possible" means when (U * U - U) is a nilpotent matrix. Currently we test vanishing
// for powers under 1000 and fail with an error if none of these powers are zero.
//
// We follow the construction of p.72 of Lambek, Hofmann "Lectures on Rings and Modules", and
// we also follow their notation.

proc mfStrictifyIdempotent(matrix A, matrix U)
{
    // If U is already strictly idempotent, return it
    if( U * U == U ){ return(U); }
    
    int m = ncols(A);
    
    matrix N = U * U - U;
    matrix z[m][m];
    
    matrix powerOfN = N;
    int vanishingOrder;
    
    for( vanishingOrder = 1; vanishingOrder < 1000; vanishingOrder++ )
    {
        //dbprint(printlevel, "[mfStrictifyIdempotent] Looking at order " + string(vanishingOrder));
        if( powerOfN == z ){ break; }
        
        powerOfN = N * powerOfN;
    }
    
    if( powerOfN != z )
    {
        print("[mfStrictifyIdempotent] Exceeded bound looking for nilpotent, exiting.");
        return();
    }
    
    // vanishingOrder is the smallest integer positive such that N^vanishingOrder = 0.
    int i;
    matrix X[m][m];
    
    for(i = 1; i < vanishingOrder; i++)
    {
        X = X + (-1)^(i+1) * int(binomial(2 * i, i)) * power(N,i);
    }
    
    X = 1/2 * X;
    
    matrix E = U + X * (unitmat(m) - 2 * U);
    
    // Sanity check
    if( A * E != E * A )
    {
        print("[mfStrictifyIdempotent] E is not a morphism.");
        return();
    }
    
    if( E * E != E )
    {
        print("[mfStrictifyIdempotent] Failed to strictify idempotent.");
        return();
    }
    
    return(E);
}

////////////////////////////////////////////////////////////////////
// computeGradingFromInjection
//
// Given a matrix F interpreted as a morphism of free modules, and an
// intvec g assigning degrees to the basis elements of the target module,
// we derive the induced grading intvec of the source module making the map F
// into a homogeneous map of degree zero.

proc computeGradingFromInjection(matrix F, intvec g)
{
    LIB "control.lib";
    
    // Check that the sizes of g and F are compatible
    if( size(g) != nrows(F) )
    {
        print("[computeGradingFromInjection] Sizes of map and grading vector not compatible, exiting.");
        return();
    }
    
    int i,j;
    intvec r;
    int ncolsF = ncols(F);
    int sizeg = size(g);
    int currentDegree = 0;
    
    for(i=1;i<=ncolsF;i++)
    {
        currentDegree = 0;
        for(j=1;j<=sizeg;j++)
        {
            if( F[j,i] != 0 )
            {
               //dbprint(printlevel, "[computeGradingFromInjection] Nonzero entry (" + string(i) + "," + string(j) + ")/(" + string(ncolsF) + "," + string(sizeg) + ") is " + string(F[j,i]) + " corresponding g entry is " + string(g[j]));
               if( currentDegree != 0 && currentDegree != g[j] + 2 * deg(F[j,i]) )
               {
                   print("[computeGradingFromInjection] Encountered multiple nonzero degrees, exiting.");
                   return();
               }
               else
               {
                   //dbprint(printlevel, "[computeGradingFromInjection] Assigning degree " + string(g[j] + 2 * deg(F[j,i])));
                   currentDegree = g[j] + 2 * deg(F[j,i]);
               }
            }
        }
        
        r[i] = currentDegree;
    }
    
    return(r);
}


////////////////////////////////////////////////////////////////////
// mfSplitIdempotent
//
// Takes as input an odd block matrix A interpreted as the differential on a Z/2-graded free module X,
// and an even block matrix E interpreted as an endomorphism of X, satisfying E * E = E. We return
// the differential B on a MF Y splitting E (details in a moment) if no third parameter is given, and
// if a third parameter is given then there are two cases:
//
// A) The third parameter is NOT an intvec, in which case we return a list B, F, G consisting of
// the differential B on a MF Y and morphisms F: Y -> X, G: X -> Y such that E = F * G and
// 1_Y = G * F. That is, we split the idempotent.
//
// B) If the third parameter is of type intvec, we presume it is a grading vector and use it to compute
// a grading on the splitting of the idempotent making F,G homogeneous of degree zero. We then return
// the corresponding grading vector r as the fourth element of the return list B, F, G, r.
//
// WARNING: If X is a matrix factorisation of a nonzero potential, we return a block matrix with
// square blocks, but if the potential is zero the blocks may be non-square.

proc mfSplitIdempotent(matrix A, matrix E, list #)
{   
    int useSanityChecks = blowFlags("sanity_checks"); 
    int m = ncols(A);
    
    // Sanity checks
    if( useSanityChecks )
    {
        if( ncols(A) != nrows(A) )
        {
            print("[mfSplitIdempotent] Passed a nonsquare matrix, exiting.");
            return();
        }
    
        if( A * E != E * A )
        {
            print("[mfSplitIdempotent] Passed a non-morphism, exiting.");
            return();
        }
    
        if( E * E != E )
        {
            print("[mfSplitIdempotent] Passed a non-idempotent endomorphism, exiting.");
            return();
        }
    }
    
    // Extract the odd and even part of the differential and morphism
    list blocks = extractblockmat(A);
    list e_blocks = extractblockmat(E);
    
    matrix a0 = blocks[3]; matrix a1 = blocks[2];
    matrix e0 = e_blocks[1]; matrix e1 = e_blocks[4];
    
    // We produce morphisms f0, g0, f1, g1 where fi, gi is a splitting of ei, in the
    // sense that fi * gi = ei and gi * fi = 1. We do this by taking fi to be the kernel
    // of 1 - ei and then computing gi as the left inverse of fi.
    
    // We know that Ker(1-ei) is a free module (Quillen-Suslin!) and that the output of
    // rightKernel(unitmat(m/2) - e0) gives a presentation of the kernel. But this may not
    // be minimal, in the sense that interpreted as a morphism of free modules it may not
    // actually a monomorphism. We fix this by calling minbase.

    // NOTE: It's possible that since we split e0 and e1 separately, the splittings may
    // be free of different ranks (i.e. the return matrices may be non-square). Of course
    // we know that the splitting will still be a factorisation of the same potential, so
    // if X factorises a nonzero potential, it will follow that the return matrices are square.
    
    LIB "control.lib";

    // Take the kernel ker0 of 1 - e0, write it as a map f0 between free modules. Then
    // we obtain the map g0 by multiplying the left inverse of f0 by e0.
    // NOTE: If e0 = 0 then ker0 is zero, and we should set f0 = g0 = 0.
    module ker0 = rightKernel(unitmat(m/2) - e0);
    matrix f0 = minbase(ker0);
    matrix g0[ncols(f0)][nrows(f0)];
        
    if( ker0[1] != [0] )
    {
        matrix g0 = leftInverse(f0) * e0; // Solves f0 * g0 = e0.
    }
    
    // Same in the odd degrees
    module ker1 = rightKernel(unitmat(m/2) - e1);
    matrix f1 = minbase(ker1);
    matrix g1[ncols(f1)][nrows(f1)];
    
    if( ker1[1] != [0] )
    {
        matrix g1 = leftInverse(f1) * e1;    
    }
    
    int n0 = nrows(g0);
    int n1 = nrows(g1);
    
    // If we have nonsquare matrices we have to do something special
    if( ker0[1] == [0] || ker1[1] == [0] || n0 != n1 )
    {
        // This only makes sense if the potential is zero, so warn and quit otherwise
        if( useSanityChecks )
        {
            if( A * A != matrix(0,nrows(A),ncols(A)) )
            {
                print("[mfSplitIdempotent] Found nonsquare matrices for nonzero differential, exiting.");
                return();
            }
        }
        
        // The case of zero potential and non-square splitting is special, so our return
        // values is special. We put a string in the first position of the return list, so
        // that the receiver knows to interpret the rest of the output in the special manner.
        
        list l = "nonsquare",f0,g0,f1,g1; // f0 g0 = e0, g0 f1 = 1
        
        if( typeof(#[1]) == "intvec" )
        {
            // We are dealing with graded MFs
            intvec g = #[1];
            
            if( m != size(g) )
            {
                print("[mfSplitIdempotent] Encountered bad grading vector, exiting.");
                return();
            }
            
            intvec gr1 = g[1..(m/2)];
            intvec gr2 = g[(m/2+1)..m];
            
            intvec r1 = computeGradingFromInjection(f0, gr1);
            intvec r2 = computeGradingFromInjection(f1, gr2);
            
            l = l + list(r1,r2);
            kill g,r1,r2,gr1,gr2;
        }
        
        return(l);
    }
    
    // Sanity check
    if( useSanityChecks )
    {
        if( f0 * g0 != e0 || f1 * g1 != e1 || g0 * f0 != unitmat(n0) || g1 * f1 != unitmat(n1) )
        {
            print("[mfSplitIdempotent] Splitting was not successful, exiting.");
            return();
        }
    }
    
    // Put the f and g matrices back together
    matrix zf1[nrows(f0)][ncols(f1)];
    matrix zf2[nrows(f1)][ncols(f0)];
    
    matrix zg1[nrows(g0)][ncols(g1)];
    matrix zg2[nrows(g1)][ncols(g0)];
    
    matrix F = blockmat_nsq(f0, zf1, zf2, f1);
    matrix G = blockmat_nsq(g0, zg1, zg2, g1);
    
    // The differential on the splitting is given by B = G * A * F
    matrix B = G * A * F;
    
    if( size(#) == 0 ){ return(B); }
    
    list l = B,F,G;
    
    if( typeof(#[1]) == "intvec" )
    {
        // We are dealing with graded MFs
        intvec g = #[1];
        
        if( m != size(g) )
        {
            print("[mfSplitIdempotent] Encountered bad grading vector, exiting.");
            return();
        }
        
        intvec r = computeGradingFromInjection(F, g);
        l = l + list(r);
        kill g, r;
    }
    
    return(l);
}

////////////////////////////////////////////////////////////////////
// mfReduceSparse
//
// NOTE: There is no guarantee that the output of mfReduceSparse must
// match with mfReduce, because we may choose different nonzero constant
// entries at each stage, leading to a different sequence of b0s.

proc mfReduceSparse(matrix A, list #)
{
    LIB "sparse.lib";
    int prl = printlevel;
    int benchmark = 1; // Set to 1 to output benchmarking data

    dbprint(prl, "[mfReduceSparse] Reducing matrix of size " + string(ncols(A)));

    if( benchmark )
    {
        system("--ticks-per-sec",1000);
        int timeElapsed = timer;
    }
    
    // Extract the odd and even part of the differential
    list blocks = extractblockmat(A);
    matrix b0 = blocks[3]; matrix b1 = blocks[2];
    
    // F and G begin as identity maps
    int ncolsA = ncols(A);
    matrix f0 = unitmat(ncolsA/2); matrix f1 = unitmat(ncolsA/2);
    matrix g0 = unitmat(ncolsA/2); matrix g1 = unitmat(ncolsA/2);

    list b0sparse = normalToSparse(b0);
    list b1sparse = normalToSparse(b1);
    list f0sparse = normalToSparse(f0);
    list f1sparse = normalToSparse(f1);
    list g0sparse = normalToSparse(g0);
    list g1sparse = normalToSparse(g1);
    
    // Run the reduction on b0
    list g = mfReduceSparse_work(b0sparse,b1sparse,f0sparse,f1sparse,g0sparse,g1sparse);
    
    b0sparse = g[1];
    b1sparse = g[2];
    f0sparse = g[3];
    f1sparse = g[4];
    g0sparse = g[5];
    g1sparse = g[6];
    
    // Run the reduction on b1
    list g = mfReduceSparse_work(b1sparse,b0sparse,f1sparse,f0sparse,g1sparse,g0sparse);
    
    b0sparse = g[2];
    b1sparse = g[1];
    f0sparse = g[4];
    f1sparse = g[3];
    g0sparse = g[6];
    g1sparse = g[5];
    
    // Now package the results
    matrix b0 = sparseToNormal(b0sparse);
    matrix b1 = sparseToNormal(b1sparse);
    matrix f0 = sparseToNormal(f0sparse);
    matrix f1 = sparseToNormal(f1sparse);
    matrix g0 = sparseToNormal(g0sparse);
    matrix g1 = sparseToNormal(g1sparse);
    
    // Our MF (b0,b1) is now guaranteed to be free of constants. At this point
    // we just apply usual Guassian elimination.
    
    // DEBUG. If set to 0, we use rowred rather than gauss_row in the following
    int useGaussRow = 0;
    
    // NOTE: Only apply Gaussian elimination if we know the matrices b0, b1 are nonzero
    //dbprint(printlevel, "[mfReduce] Beginning Gaussian elimination.");
    
    matrix zero_b[nrows(b0)][ncols(b0)];
    if( b0 != zero_b && b1 != zero_b )
    {
        matrix tr, b0r;
        
        if( useGaussRow )
        {
            list gau = gauss_row(b0,1);
            tr = transpose(gau[2]); // The transformation matrix, so tr * b0 = reduced form
            b0r = transpose(gau[1]); // The reduced form
        }
        else
        {
            list gau = rowred(b0,1);
            tr = gau[2];
            b0r = gau[1];
        }
        
        if( tr * b0 != b0r ){ print("[mfReduce] Error in Gaussian elimination (first)."); return(); }
        if( det(tr) == 0 )
        {
            print("[mfReduce] Transformation matrix not invertible (first)."); 
            return();
        }
        
        matrix trinv = inverse(tr);
        
        b0 = b0r;
        b1 = b1 * trinv;
        
        f1 = tr * f1;
        g1 = g1 * trinv;
    
        matrix tr2;
        
        // Try a second time on the transpose
        if( useGaussRow )
        {
            list gau = gauss_row(transpose(b0),1);
            tr2 = gau[2];
            b0r = gau[1];
        }
        else
        {
            list gau = rowred(transpose(b0),1);
            tr2 = transpose(gau[2]);
            b0r = transpose(gau[1]);
        }
        
        if( b0 * tr2 != b0r ){ print("[mfReduce] Error in Gaussian column elimination (second)."); return(); }
        if( det(tr2) == 0 ){ print("[mfReduce] Transformation matrix not invertible (second)."); return(); }
        
        matrix tr2inv = inverse(tr2);
        
        b0 = b0r;
        b1 = tr2inv * b1;
        f0 = tr2inv * f0;
        g0 = g0 * tr2;
        /////// END GAUSS ////////
    }
    
    // Pack everything into block matrices
    matrix zb[nrows(b0)][ncols(b0)];
    matrix zf[nrows(f0)][ncols(f0)];
    matrix zg[nrows(g0)][ncols(g0)];

    matrix B = blockmat(zb, b1, b0, zb);
    matrix F = blockmat_nsq(f0, zf, zf, f1);
    matrix G = blockmat_nsq(g0, zg, zg, g1);

    dbprint(prl, "[mfReduceSparse]          result is size " + string(ncols(B)) + ".");
    
    if( benchmark )
    {
        timeElapsed = timer - timeElapsed;
        dbprint(prl, "[mfReduceSparse]          elapsed time " + string(timeElapsed) + "ms.");
    }
    
    if( size(#) != 0 )
    {
        //list ret = B, F, G, transform_record;
        list ret = B, F, G;
        return(ret);
    }
    else
    {
        return(B);
    }
}

proc mfReduceSparse_work(list b0sparse, list b1sparse, list f0sparse, list f1sparse, list g0sparse, list g1sparse)
{
    int nc = b0sparse[2]; // ncols(b0)
    int prl = printlevel;
    
    while( nc > 1 )
    {   
        if( (nc mod 5) == 0)
        {
            dbprint(prl, "[mfReduceSparse]    reduced to size " + string(2*nc));
        }
        
        // Find the first constant in the sparse matrix
        int c; // will become index into b0sparse[3] of first nonzero constant
        int i,j;
    
        for(c=1;c<=size(b0sparse[3]);c++)
        {
            if( deg(b0sparse[3][c][3]) == 0 )
            {
                i = b0sparse[3][c][1];
                j = b0sparse[3][c][2];
                break;
            }
        }
    
        // If we cannot find a nonzero constant, it's time to finish
        if( i == 0 || j == 0 )
        {
            break;
        }
    
        //dbprint(prl,"[mfReduceSparse] Step 1");
        poly scalar = b0sparse[3][c][3];
            
        // We found our constant term, permute it to (1,1) and do the inverse to b1
        b0sparse = sparseMultByPoly(b0sparse,1/scalar);
        b0sparse = sparsePermRow(b0sparse,1,i);
        b0sparse = sparsePermCol(b0sparse,1,j);
    
        b1sparse = sparseMultByPoly(b1sparse,scalar);
        b1sparse = sparsePermCol(b1sparse,1,i);
        b1sparse = sparsePermRow(b1sparse,1,j);
    
        f0sparse = sparsePermRow(f0sparse,1,j);
    
        f1sparse = sparseMultByPoly(f1sparse,1/scalar);
        f1sparse = sparsePermRow(f1sparse,1,i);
    
        g0sparse = sparsePermCol(g0sparse,1,j);
    
        g1sparse = sparseMultByPoly(g1sparse,scalar);
        g1sparse = sparsePermCol(g1sparse,1,i);
        
        //dbprint(prl,"[mfReduceSparse] step 2");
        
        // Go through the first column and transform away everything
        // This seems to be the performance bottleneck
        int k;
        for(k=1;k<=size(b0sparse[3]);k++)
        {
            if( b0sparse[3][k][2] == 1 && b0sparse[3][k][1] > 1 && b0sparse[3][k][3] != 0 )
            {
                poly f = b0sparse[3][k][3];
                int row = b0sparse[3][k][1];
                                
                b0sparse = sparseAddRowMultToRow(b0sparse,1,row,-f);
                b1sparse = sparseAddColMultToCol(b1sparse,row,1,f);
                f1sparse = sparseAddRowMultToRow(f1sparse,1,row,-f);
                g1sparse = sparseAddColMultToCol(g1sparse,row,1,f);
                
                kill f, row;
            }
        }
                
        //dbprint(prl,"[mfReduceSparse] step 3");
        // By assumption b0 has the form (1 t \\ 0 s) and hence b1 is of the form (W d \\ 0 e)
        // where W is the potential. There is a homotopy equivalence between this matrix factorisation
        // and the factorisation (s, e)
    
        // Define a sparse matrix T which is the first row of b0 with the first col deleted
        list lookupTableT;
        for(k=1;k<=size(b0sparse[3]);k++)
        {
            if( b0sparse[3][k][2] > 1 && b0sparse[3][k][1] == 1 )
            {
                lookupTableT[b0sparse[3][k][2]-1] = b0sparse[3][k][3];
            }
        }
        
        // The homotopy equivalence between (b0, b1) and (s,e) is given by the morphism
        // ((0 1), (0 1)): (b0,b1) -> (s,e) and ((-t 1)^t, (0 1)^t): (s,e) -> (b0,b1)
        // so we need to stick these on the appropriate side of F, G
        f0sparse = sparseDeleteRow(f0sparse,1);
        f1sparse = sparseDeleteRow(f1sparse,1);
        
        //dbprint(prl,"[mfReduceSparse] step 4");
        // The operation we need to do to g0 is the following: the ith column
        // of the result is -T[1,i] * 1st column of g0 + the (i+1)st column of g0.
        // The result has the same number of rows as g0 but one less column.
    
        list g0rsparse, e;
        g0rsparse[1] = g0sparse[1];
        g0rsparse[2] = g0sparse[2] - 1;
        g0rsparse[3] = e;
        
        // Form a lookup table for the first column of g0
        list lookupFirstCol;
        list lookupFirstColIndices;
        int i;
        for(i=1;i<=size(g0sparse[3]);i++)
        {
            if( g0sparse[3][i][2] == 1 )
            {
                lookupFirstCol[g0sparse[3][i][1]] = g0sparse[3][i][3];
                
                // Add to the indices list pairs consisting of coords of everything in this row
                int j;
                for(j=2;j<=g0sparse[2];j++)
                {
                    lookupFirstColIndices = lookupFirstColIndices + list(list(g0sparse[3][i][1],j));
                }
            }
        }
        
        int k;
        for(k=1;k<=size(g0sparse[3]);k++)
        {
            if( g0sparse[3][k][2] > 1 )
            {
                // We are creating an entry for the result matrix in
                // the same row as this entry but the column one to the left
                //print("Looking at entry (" + string(g0sparse[3][k][1]) + "," + string(g0sparse[3][k][2]) + ") which is " + string(g0sparse[3][k][3]));
                list entry = g0sparse[3][k];
                list ne;
                ne[1] = entry[1];
                ne[2] = entry[2] - 1;

                poly f;
                
                if( typeof(lookupTableT[entry[2]-1]) == "poly" && typeof(lookupFirstCol[entry[1]]) == "poly" )
                {
                    f = lookupTableT[entry[2]-1] * lookupFirstCol[entry[1]];
                }
                
                ne[3] = entry[3] - f;
                g0rsparse[3] = g0rsparse[3] + list(ne);
                
                // Remove us from the lookupFirstColIndices
                int l;
                for(l=1;l<=size(lookupFirstColIndices);l++)
                {
                    if( lookupFirstColIndices[l][1] == entry[1] && lookupFirstColIndices[l][2] == entry[2] )
                    {
                        lookupFirstColIndices = delete(lookupFirstColIndices,l);
                        break;
                    }
                }
                
                kill entry,ne;
            }
        }
        
        // Now take care of anything left in lookupfirstColIndices
        int l;
        for(l=1;l<=size(lookupFirstColIndices);l++)
        {
            list v = lookupFirstColIndices[l];
            list ne;
            ne[1] = v[1];
            ne[2] = v[2] - 1;

            poly f;
            
            if( typeof(lookupTableT[v[2]-1]) == "poly" )
            {
                f = lookupTableT[v[2]-1] * lookupFirstCol[v[1]];
            }
            
            ne[3] = -f;
            g0rsparse[3] = g0rsparse[3] + list(ne);
            kill ne, v;
        }
        
        g0sparse = g0rsparse;
        
        g1sparse = sparseDeleteCol(g1sparse,1);
    
        // This should happen here, not before the business with T
        b0sparse = sparseDeleteRow(b0sparse,1);
        b0sparse = sparseDeleteCol(b0sparse,1);
    
        b1sparse = sparseDeleteRow(b1sparse,1);
        b1sparse = sparseDeleteCol(b1sparse,1);
    
        nc = nc - 1;
    }
    
    list g = b0sparse, b1sparse, f0sparse, f1sparse, g0sparse, g1sparse;
    return(g);
}

////////////////////////////////////////////////////////////////////
// mfReduce
//
// Takes as input an odd block matrix A interpreted as the differential on a Z/2-graded free module X.
// The output is the differential B of a matrix factorisation Y homotopy equivalent to X which has no
// constant entries (the "reduced" form of the original matrix factorisation). Note the size of the input
// and output matrices may differ.
//
// If a nonzero second parameter is specified then instead of returning just a matrix we return a list.
// The second and third outputs are matrices F,G representing morphisms F: X -> Y and G: Y -> X resp.
// which are mutually inverse in the homotopy category.

// TODO: In large (>2000) matrices the bottlenecks now appear to be matrixreduce and mfReduce_work,
// not findConstant.

proc mfReduceOLD(matrix A, list #)
{
    LIB "linalg.lib";
    
    int prl = printlevel;
    int benchmark = 1; // Set to 1 to output benchmarking data

    dbprint(prl, "[mfReduce] Reducing matrix of size " + string(ncols(A)));

    if( benchmark )
    {
        system("--ticks-per-sec",1000);
        int timeElapsed = timer;
    }
    
    // Extract the odd and even part of the differential
    list blocks = extractblockmat(A);
    matrix b0 = blocks[3]; matrix b1 = blocks[2];
    
    // F and G begin as identity maps
    int ncolsA = ncols(A);
    matrix f0 = unitmat(ncolsA/2); matrix f1 = unitmat(ncolsA/2);
    matrix g0 = unitmat(ncolsA/2); matrix g1 = unitmat(ncolsA/2);
        
    // A remains fixed, we work steadily on B and F, G until B has the desired form
    // Begin by looking inside b0 for nonzero constants. If at some point b0 becomes
    // a 1x1 matrix we bail (it must be contractible).
    
    // Performance note: this while loop is very tight memory wise, memory usage
    // is stable across iterations. Most of the time is spent in findConstant.
    int nc = ncols(b0);
    
    while( nc > 1 )
    {   
        if( ncolsA > 500 && (nc mod 5) == 0)
        {
            dbprint(prl, "[mfReduce]    reduced to size " + string(2*nc));
        }

        // r[1] is 1 if a nonzero constant was found and 0 otherwise
        // r[2] is an intvec giving the (i,j) coordinate of the constant entry
        list r = findConstant(b0);
        if( r[1] != 1 ){ break; }
        
        list l = matrixreduce(b0,r[2]); // p = l[2], q = l[3], pinv = l[4], qinv = l[5]
        kill r;
        
        // The matrix factorisation (b0,b1) is isomorphic to (p * b0 * q, q^{-1} * b1 * p^{-1})
        // via the morphism (from the former to the latter) given by the pair
        // (q^{-1},p). We now transform b1 to b1 = q^{-1} * b1 * p^{-1}.
        // We remember the transformation by adjusting F and G, so
        // that at each stage F is an isomorphism between X and Y with inverse G
        
        b0 = l[1];
        b1 = l[5] * b1 * l[4];
        f0 = l[5] * f0; f1 = l[2] * f1;
        g0 = g0 * l[3]; g1 = g1 * l[4];
        kill l;
        
        // Now that we guarantee b0 has an identity in the top left and zeros in the rest
        // of the first column, call a worker routine to "split" off this contractible
        // piece and return the modified B, F, G
        list out = mfReduce_work(b0,b1,f0,f1,g0,g1);
        b0 = out[1]; b1 = out[2];
        f0 = out[3]; f1 = out[4];
        g0 = out[5]; g1 = out[6];
        kill out;
        nc = nc - 1;
    }
    
    nc = ncols(b1);
    
    // No do the same process to b1 (TODO: unify these two steps)
    while( nc > 1 )
    {
        // r[1] is 1 if a nonzero constant was found and 0 otherwise
        // r[2] is an intvec giving the (i,j) coordinate of the constant entry
        list r = findConstant(b1);
        if( r[1] != 1 ){ break; }
                
        list l = matrixreduce(b1,r[2]); // p = l[2], q = l[3], pinv = l[4], qinv = l[5]
        kill r;
            
        // The matrix factorisation (b0,b1) is isomorphic to (q^{-1} * b0 * p^{-1}, p * b1 * q)
        // via the morphism (from the former to the latter) given by the pair
        // (p,q^{-1}). We now transform b0 to b0 = q^{-1} * b0 * p^{-1}.
        // We remember the transformation by adjusting F and G, so
        // that at each stage F is an isomorphism between X and Y with inverse G

        b1 = l[1];
        b0 = l[5] * b0 * l[4];
        f0 = l[2] * f0; f1 = l[5] * f1;
        g0 = g0 * l[4]; g1 = g1 * l[3];
        kill l;

        // Now that we guarantee b1 has an identity in the top left and zeros in the rest
        // of the first column, call a worker routine to "split" off this contractible
        // piece and return the modified B, F, G
        list out = mfReduce_work(b1,b0,f1,f0,g1,g0);
        
        // Note the orders are interchanged relative to the b0 case!
        b0 = out[2]; b1 = out[1];
        f0 = out[4]; f1 = out[3];
        g0 = out[6]; g1 = out[5];
        kill out;
        
        nc = nc - 1;
    }
    
    // Our MF (b0,b1) is now guaranteed to be free of constants. At this point
    // we just apply usual Guassian elimination: TODO it only looks for lower triangular
    // reduced forms...
    
    // DEBUG. If set to 0, we use rowred rather than gauss_row in the following
    int useGaussRow = 0;
    
    // NOTE: Only apply Gaussian elimination if we know the matrices b0, b1 are nonzero
    //dbprint(printlevel, "[mfReduce] Beginning Gaussian elimination.");
    
    matrix zero_b[nrows(b0)][ncols(b0)];
    if( b0 != zero_b && b1 != zero_b )
    {
        matrix tr, b0r;
        
        if( useGaussRow )
        {
            list gau = gauss_row(b0,1);
            tr = transpose(gau[2]); // The transformation matrix, so tr * b0 = reduced form
            b0r = transpose(gau[1]); // The reduced form
        }
        else
        {
            list gau = rowred(b0,1);
            tr = gau[2];
            b0r = gau[1];
        }
        
        if( tr * b0 != b0r ){ print("[mfReduce] Error in Gaussian elimination (first)."); return(); }
        if( det(tr) == 0 )
        {
            print("[mfReduce] Transformation matrix not invertible (first)."); 
            return();
        }
        
        matrix trinv = inverse(tr);
        
        b0 = b0r;
        b1 = b1 * trinv;
        
        f1 = tr * f1;
        g1 = g1 * trinv;
    
        matrix tr2;
        
        // Try a second time on the transpose
        if( useGaussRow )
        {
            list gau = gauss_row(transpose(b0),1);
            tr2 = gau[2];
            b0r = gau[1];
        }
        else
        {
            list gau = rowred(transpose(b0),1);
            tr2 = transpose(gau[2]);
            b0r = transpose(gau[1]);
        }
        
        if( b0 * tr2 != b0r ){ print("[mfReduce] Error in Gaussian column elimination (second)."); return(); }
        if( det(tr2) == 0 ){ print("[mfReduce] Transformation matrix not invertible (second)."); return(); }
        
        matrix tr2inv = inverse(tr2);
        
        b0 = b0r;
        b1 = tr2inv * b1;
        f0 = tr2inv * f0;
        g0 = g0 * tr2;
        /////// END GAUSS ////////
    }
    
    // Pack everything into block matrices
    matrix zb[nrows(b0)][ncols(b0)];
    matrix zf[nrows(f0)][ncols(f0)];
    matrix zg[nrows(g0)][ncols(g0)];

    matrix B = blockmat(zb, b1, b0, zb);
    matrix F = blockmat_nsq(f0, zf, zf, f1);
    matrix G = blockmat_nsq(g0, zg, zg, g1);

    dbprint(prl, "[mfReduce]          result is size " + string(ncols(B)) + ".");
    
    if( benchmark )
    {
        timeElapsed = timer - timeElapsed;
        dbprint(prl, "[mfReduce]          elapsed time " + string(timeElapsed) + "ms.");
    }
    
    if( size(#) != 0 )
    {
        //list ret = B, F, G, transform_record;
        list ret = B, F, G;
        return(ret);
    }
    else
    {
        return(B);
    }
}

proc mfReduce_work(matrix b0, matrix b1, matrix f0, matrix f1, matrix g0, matrix g1)
{
    // By assumption b0 has the form (1 t \\ 0 s) and hence b1 is of the form (W d \\ 0 e)
    // where W is the potential. There is a homotopy equivalence between this matrix factorisation
    // and the factorisation (s, e)

    if( ncols(b0) == 1 ){ print("[mfReduce_work] Called with 1x1 matrices, exiting"); return(b0,b1,f0,f1,g0,g1); }
    
    int nrowsb0 = nrows(b0);
    int ncolsb0 = ncols(b0);
    int nrowsb1 = nrows(b1);
    int ncolsb1 = ncols(b1);
        
    // The homotopy equivalence between (b0, b1) and (s,e) is given by the morphism
    // ((0 1), (0 1)): (b0,b1) -> (s,e) and ((-t 1)^t, (0 1)^t): (s,e) -> (b0,b1)
    // so we need to stick these on the appropriate side of F, G
    
    // Matrix of (0 1)
    int i;
    matrix zeroone[nrowsb0-1][ncolsb0];
    matrix negtone[nrowsb0][ncolsb0-1];
    
    for(i=1;i<=nrowsb0-1;i++){ zeroone[i,i+1] = 1; negtone[i+1,i] = 1; }
    for(i=1;i<=ncolsb0-1;i++){ negtone[1,i] = -b0[1,i+1]; }
    
    // Modify f and g by the appropriate things
    // NOTE: Constructing f0r,f1r by matrix multiplication is much faster than using submat.
    f0 = zeroone * f0;
    f1 = zeroone * f1;
    g0 = g0 * negtone;
    g1 = g1 * transpose(zeroone);
    
    // Read off s and e from b0 and b1
    matrix S[nrowsb0-1][ncolsb0-1] = b0[2..nrowsb0,2..ncolsb0];
    matrix E[nrowsb1-1][ncolsb1-1] = b1[2..nrowsb1,2..ncolsb1];
    
    // Our return list is b0,b1,f0,f1,g0,g1
    list l = S, E, f0, f1, g0, g1;
    kill nrowsb0,ncolsb0,nrowsb1,ncolsb1,S,E,zeroone,negtone;
    return (l);
}

// Returns 1 if there are no constant terms in A (other than zero), and zero otherwise
proc ismfReduced(matrix A)
{
    int i,j;
    for(i=1;i<=ncols(A);i++)
    {
        for(j=1;j<=ncols(A);j++)
        {
            if( A[i,j] != 0 && deg(A[i,j]) == 0 )
            {
                return(0);
            }
        }
    }
    
    return(1);
}

//////////////////////////////
// This is the old findConstant, preserved for reference

proc findConstantOld(matrix A)
{
    int i,j;
    int nc = ncols(A);
    int nr = nrows(A);
    for(i=1;i<=nr;i++)
    {
        for(j=1;j<=nc;j++)
        {
            if( A[i,j] != 0 )
            {
                if( deg(A[i,j]) == 0 )
                {
                    intvec v = i,j;
                    return(list(1,v));
                }
            }
        }
    }
    
    return(list(0,"na"));
}

proc findConstant(matrix A)
{
    int i,j,q;
    int nc = ncols(A);
    int nr = nrows(A);
    int cutoff = 10;

    for(q=1;q<=cutoff;q++)
    {
        for(i=q;i<=nr;i=i+cutoff)
        {
            for(j=1;j<=nc;j++)
            {
                if( A[i,j] != 0 )
                {
                    if( deg(A[i,j]) == 0 )
                    {
                        intvec v = i,j;
                        return(list(1,v));
                    }
                }
            }
        }
    }
    
    return(list(0,"na"));
}

////////////////////////////////////////////////////////////////////
// checkMorphismDegree
//
// Given the differentials A, B of two MFs and an even supermatrix F
// representing a morphism A -> B, together with grading vectors
// Agr and Bgr making A,B into graded MFs, we return 1 if F represents
// a degree d morphism and 0 otherwise.

proc checkMorphismDegree(matrix A, intvec Agr, matrix B, intvec Bgr, matrix F, int d)
{
    // Sanity check
    if( F * A != B * F )
    {
        print("[isMorphismDegreeZero] Not passed valid morphism, exiting.");
        return(0);
    }
    
    matrix f0 = extractblockmat(F)[1];
    matrix f1 = extractblockmat(F)[4];
    int blockCols = ncols(F)/2;
    int blockRows = nrows(F)/2;
    
    int i, j;
    for(i = 1; i <= blockRows; i++) // row
    {
        for(j = 1; j <= blockCols; j++) // column
        {
            if( f0[i,j] != 0 )
            {
                if( d - Bgr[i] + Agr[j] != 2 * deg(f0[i,j]) )
                {
                    dbprint(printlevel, "[isMorphismDegreeZero] First test failed at (" + string(i) + "," + string(j) + ")");
                    return(0);
                }
            }
            
            if( f1[i,j] != 0 )
            {
                if( d - Bgr[blockRows+i] + Agr[blockCols+j] != 2 * deg(f1[i,j]) )
                {
                    dbprint(printlevel, "[isMorphismDegreeZero] Second test failed at (" + string(i) + "," + string(j) + ")");
                    return(0);
                }
            }
        }
    }
    
    return(1);
}

////////////////////////////////////////////////////////////////////
// isGradingValid
//
// Given the differential of a MF and a grading vector, checks whether
// the pair defines a graded MF in the sense explained in "Usage Guide" above.
// Returns 1 if the input is a valid graded MF, 0 otherwise. Note that we
// do not test MFs of 0, we just return 1.

proc isGradingValid(matrix A, intvec g)
{
    // Find the degree of our potential. Let R denote the basering, which
    // we view as a graded ring with the grading which assigns degree 2 to
    // each variable.
    
    int m = ncols(A)/2;
    poly W = (A * A)[1,1];
    
    if( W == 0 ){ return(1); }
        
    // In R this W has degree 2 * (n+1) where n is given by
    int n = deg(W) - 1;
    
    matrix a0 = extractblockmat(A)[3];
    matrix a1 = extractblockmat(A)[2];
    
    int i, j;
    for(i = 1; i <= m; i++) // row
    {
        for(j = 1; j <= m; j++) // column
        {
            // First we check that the polynomial a0[i,j] is "valid". It is a map
            // R{a} -> R{b} where a = g[j] and b = g[m + i], and for A to be a valid
            // graded MF this map should be of degree n + 1 (note doubling of grading!)
            
            // Note that zeros are always OK
            if( a0[i,j] != 0 )
            {
                if( n+1 - g[m+i] + g[j] != 2 * deg(a0[i,j]) )
                {
                    dbprint(printlevel, "[isGradingValid] First test " + string(n+1-g[m+i]+g[j]) + "=" + string(2 * deg(a0[i,j])) + " failed for (" + string(i) + "," + string(j) + ")");
                    return(0);
                }
            }
            
            // Next check that a1[i,j] is valid
            if( a1[i,j] != 0 )
            {
                if( n+1 - g[i] + g[m+j] != 2 * deg(a1[i,j]) )
                {
                    dbprint(printlevel, "[isGradingValid] Second test " + string(n+1-g[i]+g[m+j]) + "=" + string(2 * deg(a1[i,j])) + " failed for (" + string(i) + "," + string(j) + ")");
                    return(0);
                }
            }
        }
    }
    
    // If we are still here then A is valid
    return(1);
}

////////////////////////////////////////////////////////////////////
// matrixreduce
//
// After some bad experiences with examples I don't trust Singular's gaussian elimination
// routines, so here is a primitive version which is good enough for our purposes.
//
// The input is a square matrix M. The output is a matrix N and four invertible matrices P, Q
// formatted as a triple (N, P, Q, Pinv, Qinv) such that P M Q = N. If no entry of M is a unit
// then N = M and P = Q = id. Otherwise the top left entry of N is a 1 and the first column
// of N contains no other nonzero entries. Pinv = P^{-1} and Qinv = Q^{-1}.
//
// We also assume that v = i,j is an intvec with M[i,j] a nonzero constant.

proc matrixreduce(matrix M, intvec v)
{
    int mrank = ncols(M);
    int i = v[1];
    int j = v[2];

    if( M[i,j] == 0 || deg(M[i,j]) != 0 )
    {
        print("[matrixreduce] Passed coordinates of a zero, or nonconstant, matrix entry, exiting.");
        return(0);
    }
    
    matrix permr = permrow(unitmat(mrank),1,i);
    matrix permc = permcol(unitmat(mrank),1,j);
                
    // We found our constant term, permute it to (1,1)
    matrix P = 1/(M[i,j]) * permr;
    matrix Pinv = M[i,j] * permr;
    matrix Q = permc;
    matrix Qinv = permc;
                
    M = P * M * Q;

    // Go through the first column and transform away everything
    matrix Pn = unitmat(mrank);
    matrix Pninv = Pn;
    
    int k;
    for(k=2;k<=mrank;k++)
    {
        if(M[k,1] != 0)
        {
            Pn[k,1] = -M[k,1];
            Pninv[k,1] = M[k,1];
        }
    }
    
    M = Pn * M;
    P = Pn * P;
    Pinv = Pinv * Pninv;
                
    list l = M,P,Q,Pinv,Qinv;
    kill P, Pinv, Q, Qinv, Pn, Pninv, permr, permc;
    return(l);
}

////////////////////////////////////////////////////////////////////
// MFtensor
//
// Takes as input a pair (A,B) of odd block 2x2 matrices which we interpret as a pair of differentials
// on Z/2-graded free modules X,Y resp. The return is the differential on the tensor product X x Y.

proc MFtensor(matrix A, matrix B)
{
    // There are two differentials A x 1 and B x 1 on the tensor product and we return their sum
    int arank = ncols(A);
    int brank = ncols(B);
    
    return( ZZtensor( unitmat(arank), B ) + ZZtensor( A, unitmat(brank) ) );
}

proc MFtensorGradings(intvec g, intvec h)
{
    // With the notation of MFtensor, X x Y is, as a Z/2-graded free module
    // (X x Y)0 = (X0 x Y0) + (X1 x Y1)
    // (X x Y)1 = (X0 x Y1) + (X1 x Y0)
    // with the basis ordered in the usual way. If X,Y are graded free modules
    // with the gradings described by intvecs g, h resp. then the intvec describing
    // the shifts on the free modules in X x Y is
   
    int sizeX = size(g)/2;
    int sizeY = size(h)/2;
    int rankProduct = sizeX * sizeY;
    
    intvec r;
    
    int i, j;
    for(i=1;i<=sizeX;i++)
    {
        for(j=1;j<=sizeY;j++)
        {
            r[(i-1)*sizeY + j] = g[i] + h[j]; // Gradings on X0 x Y0
            r[rankProduct + (i-1)*sizeY + j] = g[sizeX + i] + h[sizeY + j]; // Grading on X1 x Y1
            r[2*rankProduct + (i-1)*sizeY + j] = g[i] + h[sizeY + j]; // X0 x Y1
            r[3*rankProduct + (i-1)*sizeY + j] = g[sizeX + i] + h[j]; // X1 x Y0
        }
    }
    
    return(r);
}

////////////////////////////////////////////////////////////////////
// MFdual
//
// Takes as input an odd block 2x2 matrix A which we interpret as a differential
// on a Z/2-graded free modules X. Returns the differential of the "dual" MF, namely
// if A = (0 a1 \\ a0 0) then we return (0 transpose(a0) \\ -transpose(a1) 0)

proc MFdual(matrix A)
{
    list blocks = extractblockmat(A);
    matrix z[nrows(A)/2][ncols(A)/2];
    matrix dual = blockmat_nsq( z, transpose(blocks[3]), -transpose(blocks[2]), z );
    return(dual);
}

////////////////////////////////////////////////////////////////////
// ZZtensor 
//
// Takes as input a pair (A,B) of block matrices which we interpret as a pair of maps of Z/2-graded
// free modules A: X -> X', B: Y -> Y' according to the decompositions X = X0 + X1 and Y = Y0 + Y1,
// similarly for X', Y'. We assume that A, B are both homogeneous (i.e. either even or odd), but we
// allow X and X' (resp. Y and Y') to have different ranks, so A,B may not be square.
//
// Consider the tensor product Z = X x Y (resp. Z' = X' x Y') of Z/2-graded modules and the map
// A x B: Z -> Z' which sends a homogeneous tensor f x g to (-1)^{|f||B|} A(f) x B(g). We return
// the matrix of this map with respect to the decomposition Z0 = (X0 x Y0) + (X1 + Y1) and
// Z1 = (X0 + Y1) x (X1 + Y0) of Z (resp. of Z'). The basis of X0 x Y0 etc. is ordered in the
// usual way for a Kronecker product of matrices.

proc ZZtensor(matrix A, matrix B)
{
    list la = extractblockmat(A);
    list lb = extractblockmat(B);
    
    matrix a11, a12, a21, a22, b11, b12, b21, b22;
    
    a11 = la[1]; a12 = la[2]; a21 = la[3]; a22 = la[4];
    b11 = lb[1]; b12 = lb[2]; b21 = lb[3]; b22 = lb[4];
    
    int degb = 0; // Default B to degree 0, i.e. even
    
    matrix zero[nrows(B)/2][ncols(B)/2];
    matrix bigzero[nrows(B)][ncols(B)];
    
    if( B != bigzero && b11 == zero && b22 == zero ){ degb = 1; }
    
    // Define the four corners of Z, then use blockmat
    matrix z11 = blockmat_nsq( tensor(a11,b11), (-1)^(degb) * tensor(a12,b12), tensor(a21,b21), (-1)^(degb) * tensor(a22,b22) );
    matrix z12 = blockmat_nsq( tensor(a11,b12), (-1)^(degb) * tensor(a12,b11), tensor(a21,b22), (-1)^(degb) * tensor(a22,b21) );
    matrix z21 = blockmat_nsq( tensor(a11,b21), (-1)^(degb) * tensor(a12,b22), tensor(a21,b11), (-1)^(degb) * tensor(a22,b12) );
    matrix z22 = blockmat_nsq( tensor(a11,b22), (-1)^(degb) * tensor(a12,b21), tensor(a21,b12), (-1)^(degb) * tensor(a22,b11) );
        
    matrix Z = blockmat_nsq(z11,z12,z21,z22);
    
    return(Z);
}

////////////////////////////////////////////////////////////////////
// extractblockmat takes a block matrix (A B // C D) and returns a list {A, B, C, D}.
// We assume that the blocks each have half the width of the matrix, and half the height
// of the matrix (so we assume both are even, but we allow nonsquare blocks)

proc extractblockmat(matrix block)
{
    int nr = nrows(block)/2;
    int nc = ncols(block)/2;
    
    matrix a[nr][nc];
    matrix b[nr][nc];
    matrix c[nr][nc];
    matrix d[nr][nc];
    
    int i,j; // i is the row and j the column
    for(i=1;i <= nr; i++)
    {
        for(j=1;j <= nc; j++)
        {
            a[i,j] = block[i,j];
            b[i,j] = block[i,j+nc];
            c[i,j] = block[i+nr,j];
            d[i,j] = block[i+nr,j+nc];
        }
    }
    
    list l = a,b,c,d;
    kill a,b,c,d,nr,nc,i,j;
    return(l);
}

///////////// TESTS ///////////////

proc test_matrixreduce()
{
    int passed = 1;
    
    ring RR = 0,(x,y),dp;
    
    // Test 1
    matrix M[2][2] = x,5,x,1;
    list l = matrixreduce(M);
    matrix N[2][2] = 1,1/5*x,0,4/25*x;    
    if( l[1] != N || l[2] * M * l[3] != l[1] ){ passed = 0; }
    
    // Test 2
    matrix A[4][4] = 0,0,y,0,0,0,-1,y,y2,0,0,0,y,y2,-1,0;
    list b = matrixreduce(A);
    matrix B[4][4] = 1,0,0,-y,0,0,0,-y2,0,0,-y2,0,0,-y2,-y,y;
    
    if( b[1] != B || b[2] * A * b[3] != b[1] ){ passed = 0; }
    
    if( passed == 1 ){ print("All tests passed."); } else { print("Some tests failed."); }
}

proc test_ZZtensor()
{
    int passed = 1;
    
    // Test 1
    matrix A[2][2] = 1,0,0,1;
    matrix B[2][2] = 0,1,1,0;
    
    // The tensor product A x B should be the following matrix
    matrix AB[4][4] = 0, 0, 1, 0, 0, 0, 0, -1, 1, 0, 0, 0, 0, -1, 0, 0;
    
    if( AB != ZZtensor(A,B) ){ passed = 0; }
        
    if( passed == 1 ){ print("All tests passed."); } else { print("Some tests failed."); }
}

proc test_mfReduce()
{
    int passed = 1;
    
    // Test 1
    ring RR = 0,(x,y),dp;
    
    matrix d0[4][4] = 0,0,y,0,0,0,-1,y,y2,0,0,0,y,y2,-1,0;
    matrix d1[4][4] = 0,0,y,0,1,0,-1,y,y2,0,0,0,y,y2,0,0;
    matrix z[4][4];

    matrix d = blockmat(z,d1,d0,z);
    list l = mfReduce(d,1);
    
    matrix b = l[1];
    matrix f = l[2];
    matrix g = l[3];
    
    // B should be reduced and f: d -> b and g: b -> d should be morphisms
    if( f * d != b * f ){ passed = 0; }
    if( g * b != d * g ){ passed = 0; }
    
    if( passed == 1 ){ print("All tests passed."); } else { print("Some tests failed."); }
}

////////////////////////////////////////////////////////////////////
// fuseDefects
//
// Returns the reduced tensor product of Y with X, as a pair (B, e) 
// consisting of the differential B of a matrix factorisation of the total
// potential and an idempotent endomorphism e whose splitting is (YxX)[n],
// where n is the number of internal variables.

proc fuseDefects(matrix Y, matrix X, poly W)
{
    int prl = printlevel;

    // First compute the internal algebra. That is, find powers of the internal
    // variables which can be written as linear combinations of the partials. If
    // we follow the notation of my note then this is the algebra I.

    list t = varTrans(W);
    matrix C = t[2];
    intvec q = t[1];
    
    // The ideal whose quotient gives the algebra I is generated by the internal
    // variables to the powers given by q
    int i;
    ideal J;
    int numX = numXVars();
    
    for( i = 1; i <= numX; i++ )
    {
        J[i] = x(i)^(q[i]);
    }

    // Compute the ordinary tensor product
    matrix D = MFtensor(Y,X);
    
    // Inflate or blow up the differential on this tensor product, that is,
    // compute the differential of Y x X x I.
    dbprint(prl, "[fuseDefects] Blowing up differential on tensor product.");
    matrix Dblow = mablow(D,J);
    
    // Reduce this inflated differential
    dbprint(prl, "[fuseDefects] Reducing blown up differential.");
    list l = mfReduce(Dblow,1);
    matrix RD = l[1];
    matrix F = l[2]; // A homotopy equivalence F: Dblow -> RD
    matrix G = l[3]; // A homotopy equivalence G: RD -> Dblow

    // Compute the matrix dQ_X
    dbprint(prl, "[fuseDefects] Computing dQ.");
    matrix dq = dQ(X, q, C);
    matrix iddQ = ZZtensor( unitmat(ncols(Y)), dq ); // "iddQ" is "id x dQ_X"
    
    // Compute the matrix deltaQ
    dbprint(prl, "[fuseDefects] Computing deltaQ.");
    matrix delQ = deltaQ(D, q);

    // And finally the idempotent e on Dblow
    int sign = (numX * (numX-1)) div 2;
    matrix e = (-1)^(sign) * iddQ * delQ;
    
    // The induced idempotent on the reduction is denoted ep
    matrix ep = F * e * G;

    // Sanity check: ep must be an endomorphism of RD
    int h = ncols(ep * RD);
    matrix zero[h][h];
    
    if( ep * RD - RD * ep != zero )
    {
        print("[fuseDefects] The reduced idempotent is not a morphism, exiting.");
        return();
    }
    
    list l = RD, ep;
    
    return(l);
}

////// DEPRECATED


//////////////////////////////////////////////////////////////////////////////////
// "deltaInflation"
//
// Let us write nR for the basering without its y-variables.
//
// Given a monomial XA in the x-variables and an integer i, we return the scalar matrix
// representing the action of [g_i, XA] on the algebra I = nR/J. Here g_i stands for the
// k-linear endomorphism of the ring nR (without y-variables) which sends a polynomial f
// to its division by x(i)^exponent without remainder.
//
// NOTE: x(i) only appears as x(i)^exponent, so maybe we should pass the latter rather than
// i and the exponent separately.
//////////////////////////////////////////////////////////////////////////////////

proc deltaInflation(poly XA, int i, int exponent, ideal J)
{
    // Compute a k-basis of I
    def RRR = basering;
    def nR = ringWithoutYVars();
    setring nR;

    ideal J = imap(RRR,J);
    poly XA = imap(RRR,XA);
    ideal Jstd = std(J);
    ideal basis = kbase(Jstd);
    module BB = reduce(basis,Jstd);

    int n = size(basis);
    
    int k;
    list L;
    for(k=1; k<=n; k++)
    {
        poly basisElt = basis[k];

        // First compute g_i( XA * - ) on our basis element
        poly f1 = ( XA * basisElt - reduce(XA * basisElt,std(x(i)^exponent)) )/(x(i)^exponent);

        // Next compute XA * g_i(-)
        poly f2 = XA * ( basisElt - reduce(basisElt,std(x(i)^exponent)) )/(x(i)^exponent);

        // To our output matrix we add the expression of the commutator f1 - f2 in the
        // chosen basis of the algebra I
        module ff = reduce(f1 - f2,Jstd);
        matrix MM = matrix(reduce(lift(BB,ff),std(syz(BB))));
        L = L + list(MM);
    }

    matrix U = L[1];
    for(k=2; k<=n; k++)
    {
        U=concat(U,L[k]);
    }

    setring RRR;
    matrix NN = imap(nR,U);
    
    return(NN);
}

//////////////////////////////////////////////////////////////////////////////////
// "deltaImablow" blows up a matrix by blowing up all its entries using deltaInflation. (This
// is equal to \delta_{x_i}(Q) of sec 3.1 in Dan's note from 2010-06-26.)
//
// exponent is the integer such that g_i is division without remainder by x(i)^exponent.
//////////////////////////////////////////////////////////////////////////////////

proc deltaImablow(matrix M, int i, int exponent, ideal J)
{
    int prl = printlevel;

    // Compute n := dimension of I = k[x-vars]/J
    int n = dimAlgebraOverInternalVariables(J);

    // Define L to be an appropriately indexed list of blown-up matrices:
    int colsm = ncols(M);
    int i1,j1,i2,j2,k;
    list e,L;

    poly xprod = 1;
    int numX = numXVars();
    
    for(k=1; k<=numX; k++)
    {
        xprod = xprod * x(k);
    }

    for(k=1; k<=colsm; k++)
    {
        L[k] = e;
    }
    
    for(i1=1; i1<=colsm; i1++)
    {
        for(j1=1; j1<=colsm; j1++)
        {
            ///////////////////////////////////////////////////
            // INTERESTING PART: 
            //
            // koffer is a matrix with two rows. The first row contains
            // all the x-monomials with nonzero coefficient in M[i1,j1].
            // The second row contains the corresponding coefficient, which is a polynomial
            // in only the y-variables.

            matrix koffer = coef(M[i1,j1], xprod);
            matrix N[n][n];

            for(k=1; k<=ncols(koffer); k++)
            {
                poly monom = koffer[1,k];
                
                // Compute the power of the x(i)-variable in monom. Note that deltaInflation
                // of any monomial NOT involving x(i) must be zero. Note we multiply with
                // all the variables to ensure that factorize returns a matrix whose ith
                // column is the integer we're interested in + 1.
                int p = factorize(monom * xprod,2)[2][i] - 1; 
                
                if( koffer[2,k] != 0 && monom != 0 && p > 0 )
                {
                    N = N + koffer[2,k] * deltaInflation(monom, i, exponent, J);
                }
            }

            L[i1] = insert(L[i1], N, j1-1);
            ///////////////////////////////////////////////////
        }
    }

    // TODO: This next loop is very slow...
    matrix A[colsm*n][colsm*n];

    for(i1=1; i1<=colsm; i1++)
    {
        for(j1=1; j1<=n; j1++)
        {
            for(i2=1; i2<=colsm; i2++)
            {
                for(j2=1; j2<=n; j2++)
                {
                    A[(i1-1)*n + j1, (i2-1)*n + j2] = L[i1][i2][j1,j2];
                }
            }
        }
    }
    
    return(A);
}

////////////////////////////////////////////////////////////////////
// Given a block matrix returns the supertrace
//
// INPUT: Block matrix (A & B \\ C & D) where A,B,C,D are square matrices
//
// OUTPUT: Tr(A) - Tr(D)

proc supertrace(matrix m)
{
    int r = ncols(m)/2;
    matrix zero[r][r];
    matrix E[r][r]; E = E + 1; // The unit matrix

    matrix B = blockmat(E,zero,zero,-1 * E);

    return( trace( B * m ) );
}

proc MFKer(matrix f, matrix g, matrix fs, matrix gs) 
{ 
	int i,j,k,l,m,q,s,a,b; 
	int r=ncols(f); 
	matrix A[r*r][r*r]; 
	matrix B[r*r][r*r]; 
	matrix C[r*r][r*r]; 
	matrix D[r*r][r*r]; 
	for(k=1; k<=r; k++) 
	{
		for(i=1; i<=r; i++) 
		{
			for(j=1; j<=r; j++) 
			{
				A[i + k*r - r, j + k*r - r] = - g[j,i]; 
			} 
		} 
	}
	 
	for(k=1; k<=r; k++) 
	{
		for(i=1; i<=r; i++) 
		{
			for(j=1; j<=r; j++) 
			{
				B[k + r*i - r, k + r*j - r] = gs[i,j]; 
			} 
		} 
	}
	 
	for(k=1; k<=r; k++) 
	{
		for(i=1; i<=r; i++) 
		{
			for(j=1; j<=r; j++) 
			{
				C[k + r*i - r, k + r*j - r] = fs[i,j]; 
			} 
		} 
	}
	 
	for(k=1; k<=r; k++) 
	{
		for(i=1; i<=r; i++) 
		{
			for(j=1; j<=r; j++) 
			{
				D[i + k*r - r, j + k*r - r] = - f[j,i]; 
			} 
		}
	} 
	
	module Ker = syz(blockmat(A,B,C,D)); 
	return(Ker); 
}

proc MFIm(matrix f, matrix g, matrix fs, matrix gs) 
{ 
	int i,j,k,l,m,q,s,a,b; 
	int r=ncols(f); 
	matrix A[r*r][r*r]; 
	matrix B[r*r][r*r]; 
	matrix C[r*r][r*r]; 
	matrix D[r*r][r*r]; 
	for(k=1; k<=r; k++) 
	{
		for(i=1; i<=r; i++) 
		{
			for(j=1; j<=r; j++) 
			{
				A[i + k*r - r, j + k*r - r] = - g[j,i]; 
			} 
		} 
	}
	 
	for(k=1; k<=r; k++) 
	{
		for(i=1; i<=r; i++) 
		{
			for(j=1; j<=r; j++) 
			{
				B[k + r*i - r, k + r*j - r] = gs[i,j]; 
			} 
		} 
	}
	 
	for(k=1; k<=r; k++) 
	{
		for(i=1; i<=r; i++) 
		{
			for(j=1; j<=r; j++) 
			{
				C[k + r*i - r, k + r*j - r] = fs[i,j]; 
			} 
		} 
	}
	 
	for(k=1; k<=r; k++) 
	{
		for(i=1; i<=r; i++) 
		{
			for(j=1; j<=r; j++) 
			{
				D[i + k*r - r, j + k*r - r] = - f[j,i]; 
			} 
		}
	} 
	
	module Ker = module(blockmat(-D,B,C,-A)); 
	return(Ker); 
}

proc zoomreduce(matrix A)
{
    // n is the current size of the top left identity block, begins at zero
    int n = 0;
    int nr = nrows(A);
    int nc = ncols(A);
    int i;
    int ncolsOrig = ncols(A);
    
    matrix P = unitmat(nr);
    matrix Q = unitmat(nc);
    matrix Pinv = unitmat(nr);
    matrix Qinv = unitmat(nc);
    
    // Always the final matrix B will be P * A * Q
    while( 1 )
    {
        if( ncolsOrig > 250 && (n mod 5) == 0 && n > 0 )
        {
            dbprint(printlevel, "[zoomreduce]    reduced to size " + string(2*(ncolsOrig - n)));
        }
        
        // Find a unit in the given matrix, transform it to the top left, and eliminate the first
        // column and first row
        
        // r[2][1] is the row and r[2][2] the column our found constant entry of A
        list r = findConstant(A);
        if( r[1] != 1 ){ break; }
    
        //print(string(nrows(A)) + ", " + string(r[2][1]) + "," + string(r[2][2]));
    
        if( r[2][1] != 1 )
        {
            A = permrow(A,1,r[2][1]);
            P = permrow(P,1+n,r[2][1]+n);
            Pinv = permcol(Pinv,1+n,r[2][1]+n);
        }

        if( r[2][2] != 1 )
        {
            A = permcol(A,1,r[2][2]);
            Q = permcol(Q,1+n,r[2][2]+n);
            Qinv = permrow(Qinv,1+n,r[2][2]+n);
        }
        kill r;

        // Note you have to do these types of things on P,Q first! Because A will change!
        if( A[1,1] != 1 )
        {
            P = multrow(P,1+n,1/A[1,1]);    
            Pinv = multcol(Pinv,1+n,A[1,1]);
            A = multrow(A,1,1/A[1,1]);
        }

        for(i=2;i<=nc;i++)
        {
            if( A[1,i] != 0 )
            {
                Q = addcol(Q,1+n,-A[1,i],i+n);
                Qinv = addrow(Qinv,i+n,A[1,i],1+n);
                A = addcol(A,1,-A[1,i],i);
            }
        }

        for(i=2;i<=nr;i++)
        {
            if( A[i,1] != 0 )
            {
                P = addrow(P,1+n,-A[i,1],i+n);
                Pinv = addcol(Pinv,i+n,A[i,1],1+n);
                A = addrow(A,1,-A[i,1],i);
            }
        }

        if( nr == 1 || nc == 1 ){ break; }
        
        A = submat(A,2..nr,2..nc);
        nc = nc - 1;
        nr = nr - 1;
        n = n + 1;
    }
    
    // The final reduced matrix is the direct sum of the identity matrix and our final A,
    // but we just return the interesting bit A
    return(list(A,n,P,Q,Pinv,Qinv));
}

////////////////////////////////////////////////////////////////////
// mfReduce
//
// Takes as input an odd block matrix A interpreted as the differential on a Z/2-graded free module X.
// The output is the differential B of a matrix factorisation Y homotopy equivalent to X which has no
// constant entries (the "reduced" form of the original matrix factorisation). Note the size of the input
// and output matrices may differ.
//
// If a nonzero second parameter is specified then instead of returning just a matrix we return a list.
// The second and third outputs are matrices F,G representing morphisms F: X -> Y and G: Y -> X resp.
// which are mutually inverse in the homotopy category.

proc mfReduce(matrix A, list #)
{
    dbprint(printlevel, "[mfReduce] Reducing matrix of size " + string(ncols(A)));
    
    system("--ticks-per-sec",1000);
    int timeElapsed = timer;
    
    // Extract the odd and even part of the differential
    list blocks = extractblockmat(A);
    matrix b0 = blocks[3]; matrix b1 = blocks[2];
    kill blocks;
    
    // Reduce b0. This returns a list b0r,P,Q,n where P,Q are invertible matrices,
    // b0r is a matrix with no nonzero constant entries, and P * b0 * Q = dsum(unitmat(n),b0r).
    // The induced differential in degree one is dsum(W * unitmat(n),b1r) = Q^{-1} * b1 * P^{-1}
    
    list l = zoomreduce(b0);
    // n = l[2];
    // P = l[3];
    // Q = l[4];
    // Pinv = l[5];
    // Qinv = l[6];
    
    b0 = l[1];
    b1 = submat(l[6] * b1 * l[5],(l[2]+1)..nrows(b1),(l[2]+1)..ncols(b1));
    
    matrix f0 = submat(l[6],(l[2]+1)..nrows(l[6]),1..ncols(l[6]));
    matrix f1 = submat(l[3],(l[2]+1)..nrows(l[3]),1..ncols(l[3]));
    matrix g0 = submat(l[4],1..nrows(l[4]),(l[2]+1)..ncols(l[4]));
    matrix g1 = submat(l[5],1..nrows(l[5]),(l[2]+1)..ncols(l[5]));
    kill l;
    
    // Now repeat the awesome feat on b1
    list l = zoomreduce(b1);
    
    b1 = l[1];
    b0 = submat(l[6] * b0 * l[5],(l[2]+1)..nrows(b0),(l[2]+1)..ncols(b0));
    
    f0 = submat(l[3] * f0,(l[2]+1)..nrows(l[3]),1..ncols(f0));
    f1 = submat(l[6] * f1,(l[2]+1)..nrows(l[6]),1..ncols(f1));
    g0 = submat(g0 * l[5],1..nrows(g0),(l[2]+1)..ncols(l[5]));
    g1 = submat(g1 * l[4],1..nrows(g1),(l[2]+1)..ncols(l[4]));
    kill l;
    
    // The maps F = (f0,f1) and G = (g0,g1) now give homotopy equivalences between
    // the original MF and the reduced MF (b0,b1)
    matrix zb[nrows(b0)][ncols(b0)];
    matrix zf[nrows(f0)][ncols(f0)];
    matrix zg[nrows(g0)][ncols(g0)];

    matrix B = blockmat(zb, b1, b0, zb);
    matrix F = blockmat_nsq(f0, zf, zf, f1);
    matrix G = blockmat_nsq(g0, zg, zg, g1);
    kill zb,zf,zg,b1,b0,f0,f1,g0,g1;
    
    dbprint(printlevel, "[mfReduce]          result is size " + string(ncols(B)) + ".");
    dbprint(printlevel, "[mfReduce]          elapsed time " + string(timer-timeElapsed) + "ms.");
    
    // TODO: We don't do the final gauss_row / rowred step in the old mfReduce, so our
    // output won't be as pretty, but it is faster to omit this step. In cases where
    // we actually want to look at the output (e.g. fusion) it is better to use the old
    // mfReduce.
    
    if( size(#) != 0 )
    {
        //list ret = B, F, G, transform_record;
        list ret = B, F, G;
        kill B,F,G;
        return(ret);
    }
    else
    {
        kill F,G;
        return(B);
    }
}

////////////////////////////////////////////////////////////////////
// mfPushforward
//
// We are given a matrix A interpreted as the differential on a matrix factorisation X
// of a potential W in our ring, together with a ring variable "intvar" and integer N
// such that intvar^N acts null-homotopically on X, and a matrix H of degree one such that
// A * H + H * A = intvar^N * unitmat, i.e. the entries of H give a homotopy between
// intvar^N and the zero map. We assume that, as a polynomial, W does not depend on the
// variable intvar.
//
// Let S denote the ring obtained from our basering by deleting intvar. We can restrict
// scalars on X and obtain an infinite rank MF of W over S, the so-called "pushforward".
// The first return value of this routine is the differential of a finite rank MF Y of W over S
// homotopy equivalent to this pushforward.
//
// Let Xblow denote the MF of W over S obtained by "inflation". Then the pushforward is a
// direct summand of Xblow[1] and the second and third return value are morphisms F: Xblow[1] -> Y
// and G: Y -> Xblow[1] such that F * G == unitmat and G * F is, up to homotopy, the same
// idempotent on Xblow[1] determined by its direct summand the pushforward.
//
// If we are passed an intvec grading for A as the last parameter, we respect this grading
// throughout and return as a fourth parameter a grading vector on Y.
//
// We assume that our ring is R = 0,(some variables, we don't care),dp.
//
// NOTE: Before calling any of the routines of blow.lib we rename intvar to x(1) and all the other
// variables to y's, so that our active ring is of the form 0,(x(1),y(1),...,y(??)),dp and
// S is 0,(y(1),...,y(??)),dp. Naturally we convert back to the original ring before returning
// our results.
//
// Note: if the fourth parameter is a _list_ of matrices then we assume that the first is the
// H described above, and the rest are homotopies on A. We then return an additional list consisting
// of the homotopies induced on Y by these homotopies in the list.
//
// NOTE: If the potential is zero and splitting an idempotent produces nonsquare matrices, then 
// the return format is different, because the Z/2-graded module may be zero in one degree: this
// means we can't write things as block matrices. In this case we return a list 
//
//  "nonsquare", f0,g0,f1,g1 [possibly two grading vectors r1,r2]
//
// where f0,g0 split the idempotent on Xblow[1] in degree zero and resp. for f1,g1. Hence the
// differential on Y is implicit (obtained from fi,gi and the differential on Xblow[1]). The
// grading vectors ri give the degrees on the even and odd part of Y resp.

proc mfPushforward(matrix A, poly intvar, int N, Hlist, list #)
{
    int useSanityChecks = blowFlags("sanity_checks"); 
    dbprint(printlevel, "[mfPushforward] Pushing forward matrix of size " + string(ncols(A)) + " with N = " + string(N));
    
    system("--ticks-per-sec",1000);
    int timeElapsed = timer;
    
    def RRR = basering;
    
    // Check for grading
    int useGrading;
    if( size(#) > 0 )
    {
        intvec Agr = #[1];
        int useGrading = 1;
    }
    
    // Check for a list of homotopies to track
    int homotopyList;
    if( typeof(Hlist) == "list" )
    {
        matrix H = Hlist[1];
        Hlist = delete(Hlist,1);    
        
        if( size(Hlist) != 0 )
        {
            int homotopyList = 1;
        }
    }
    else
    {
        matrix H = Hlist;
    }
    
    // Sanity check
    if( useSanityChecks )
    {
        if( A * H + H * A != intvar^N * unitmat(ncols(A)) )
        {
            print("[mfPushforward] Not passed valid homotopy, exiting.");
            return();
        }
    }
    
    // Convert everything into a more suitable ring. We go through the original
    // list of ring variables, rename everything apart from intvar to y(i)'s (in
    // ascending order) and rename intvar to x(1)
    list rlist = ringlist(RRR);
    list varlist = rlist[2];
    
    // Create the new list of variables
    list newvar;
    int i;
    int ycount;
    for(i=1;i<=size(varlist);i++)
    {
        if( string(intvar) == varlist[i] )
        {
            newvar = newvar + list("x(1)");
        }
        else
        {
            ycount++;
            string s = "y(" + string(ycount) + ")";
            newvar = newvar + list(s);
            kill s;
        }
    }
    kill varlist;
    
    list newringList;
    newringList[1] = rlist[1];
    newringList[2] = newvar;
    newringList[3] = rlist[3];
    newringList[4] = rlist[4];
    kill rlist;
    
    // Fix the variable weighting
    intvec kk = (1..size(newvar));
    for(i=1; i<=size(newvar); i++)
    {
        kk[i] = 1;
    }
    newringList[3][1][2] = kk;
    kill kk;
    
    // Create our new ring
    def nR = ring(newringList);
    setring nR;
    
    //dbprint(printlevel, "[mfPushforward] Renaming ring variable(s) to " + varstr(nR));
    
    // If we call fetch then the object of RRR is converted to the new renamed variables
    matrix A = fetch(RRR,A);
    matrix H = fetch(RRR,H);
    if( homotopyList )
    {
        list Hlist = fetch(RRR,Hlist);
    }
        
    // So now H * A + A * H = x(1)^N * unitmat and the potential W depends only on the y's.
    // Compute the inflation
    ideal J = x(1)^N;
    matrix Ablow = mablow(A,J);
    if( useGrading ){ intvec Ablowgr = mablowGrading( Agr, J, N ); }
    if( homotopyList )
    {
        for(i=1;i<=size(Hlist);i++)
        {
            Hlist[i] = mablow(Hlist[i],J);
        }
    }
    // Reduce the inflated matrix factorisation (of W over S = QQ[y(1),...,y(??)])
    list l = mfReduce(Ablow,1);
    matrix RT = l[1]; // Differential on reduced MF
    matrix F = l[2]; // A homotopy equivalence Ablow -> RT
    matrix G = l[3]; // A homotopy equivalence RT -> Ablow

    if( useGrading ){ intvec RTgr = computeGradingFromInjection(G,Ablowgr); }
    
    kill Ablow,l;

    // The idempotent on Ablow
    matrix e = mablow( H, J ) * mablow_delta(A, 1, N, J);
    
    // The idempotent on the reduction
    matrix ep = F * e * G;
    
    // Move the homotopies over to the reduction RT
    if( homotopyList )
    {
        for(i=1;i<=size(Hlist);i++)
        {
            Hlist[i] = F * Hlist[i] * G;
        }
    }
    
    // Sanity checks:
    if( useSanityChecks )
    {
        if( ep * RT != RT * ep )
        {
            print("[mfPushforward] The reduced idempotent (up to homotopy) ep is not an endomorphism of RT, exiting.");
            return();
        }
    }
    
    // Check that ep is idempotent up to homotopy
    matrix epck = ep;
    for(i=1;i<=ycount;i++)
    {
        epck = subst( epck, y(i), 0 );
    }
    
    if( epck * epck != epck )
    {
        // NOTE: If this test fails to pass, it is usually due to a sign problem...
            
        // TODO DEBUG DEBUG WARNING UGLY HACK
        if( epck * epck == -1 * epck )
        {
            ep = -ep;
        }
    }
    kill epck;
        
    // TODO: Check that ep1 and ep2 are degree zero
    
    matrix epstrict = mfStrictifyIdempotent(RT, ep);
    
    // Sanity checks:
    if( useSanityChecks )
    {
        if( epstrict * RT != RT * epstrict || epstrict * epstrict != epstrict )
        {
            print("[mfPushforward] The strictified idempotent is not an endomorphism of RT, or not an idempotent on the nose, exiting.");
            return();
        }
    }
    
    list l;
    if( !useGrading )
    {
        l = mfSplitIdempotent(RT, epstrict, 1);
    }
    else
    {
        l = mfSplitIdempotent(RT, epstrict, RTgr);
    }

    // This can only happen if the potential is zero and mfSplitIdempotent found non-square
    // matrices. In this case our return formatting is different, see the introduction.
    if( typeof(l[1]) == "string" )
    {
        // In this the list l has the format l = "nonsquare",f0,g0,f1,g1 where fi,gi are the
        // splittings in the respective degrees, and l may have as a final entry a grading
        // vector for the even and odd parts (separately). Note that mfSplitIdempotent has
        // different conventions for what f and g mean. I.e. f0 g0 = e0, g0 f1 = 1, so
        // we need to rearrange (since here we want F to be the projection, not the injection)
        // and we want to group g0 with g1, f0 with g1. I.e. in the notation of mfSplitIdempotent
        // we want to return the list "nonsquare",g0,g1,f0,f1.
        
        setring RRR;
        list l = imap(nR,l);
        list retlist = l;
        retlist[2] = l[3];
        retlist[3] = l[5];
        retlist[4] = l[2];
        retlist[5] = l[4];
        kill l;

        //dbprint(printlevel, "[mfPushforward] splitting produced nonsquare matrices.");
        dbprint(printlevel, "[mfPushforward] elapsed time " + string(timer-timeElapsed) + "ms.");
            
        return(retlist);
    }
    
    // mfSplitIdempotent returns not just the splitting of the idempotent, but the
    // actual maps splitting the idempotent. In the following notation, this means
    // that s * t == ep and t * s == unitmat
    
    matrix final = l[1];
    if( useGrading ){ intvec finalgr = l[4]; }
    
    matrix s = l[2]; // s: final --> RT
    matrix t = l[3]; // t: RT --> final
    
    // Sanity check
    if( useSanityChecks && useGrading )
    {
        if( !isGradingValid(final, finalgr) )
        {
            print("[mfPushforward] Something has gone wrong with the grading, exiting.");
            return();
        }
    }
    
    // We have now split the original idempotent e on Ablow, and the splittings are
    matrix mapAblowToFinal = t * F;
    matrix mapFinalToAblow = G * s;
    
    // Each of the homotopies in our list is a homotopy on RT, let us replace
    // these by homotopies on final
    if( homotopyList )
    {
        for(i=1;i<=size(Hlist);i++)
        {
            Hlist[i] = t * Hlist[i] * s;
        }
    }
    
    kill s,t,F,G,RT,e,ep,epstrict;
    if( useGrading ){ kill RTgr; }
        
    // Back to the original ring and return. Note that we use fetch and not imap
    // because we want to replace variables in nR by the variables in RRR in the same
    // _position_ in ringlist.
    setring RRR;
    matrix final = fetch(nR,final);
    matrix mapAblowToFinal = fetch(nR,mapAblowToFinal);
    matrix mapFinalToAblow = fetch(nR,mapFinalToAblow);
    if( homotopyList )
    {
        list Hlist = fetch(nR,Hlist);
    }
    
    // Note that we really want a splitting of e[1] on Ablow[1], so let us suspend
    final = mfSuspend( final );
    mapAblowToFinal = mfSuspendMorph( mapAblowToFinal );
    mapFinalToAblow = mfSuspendMorph( mapFinalToAblow );
    if( useGrading ){ finalgr = mfSuspendGrading( finalgr ); }
    if( homotopyList )
    {
        for(i=1;i<=size(Hlist);i++)
        {
            Hlist[i] = mfSuspend( Hlist[i] ); // homotopies are suspended just like differentials
        }
    }
    
    list retlist = list(final,mapAblowToFinal,mapFinalToAblow);
    
    // Note that grading (if it exists) goes before homotopy list (if it exists!)
    if( useGrading )
    {
        retlist = retlist + list(finalgr);
    }

    if( homotopyList )
    {
        retlist = retlist + list(Hlist);
        kill Hlist;
    }
    
    dbprint(printlevel, "[mfPushforward] result is size " + string(ncols(final)) + ".");
    dbprint(printlevel, "[mfPushforward] elapsed time " + string(timer-timeElapsed) + "ms.");
    kill final, mapAblowToFinal, mapFinalToAblow;
        
    return(retlist);
}

////////////////////////////////////////////////////////////////////
// mfPushforwardInductive
//
// We are given a matrix A interpreted as the differential on a matrix factorisation X
// of a potential W in our ring, together with a list of ring variables "intvars" and list N
// such that intvar[i]^N[i] acts null-homotopically on X, and a matrix H[i] of degree one such that
// A * H[i] + H[i] * A = intvar[i]^N[i] * unitmat, i.e. the entries of H[i] give a homotopy between
// intvar[i]^N[i] and the zero map. We assume that, as a polynomial, W does not depend on the
// variables intvar.
//
// Let S denote the ring obtained from our basering by deleting the intvars. We can restrict
// scalars on X and obtain an infinite rank MF of W over S, the so-called "pushforward".
// The first return value of this routine is the differential of a finite rank MF Y of W over S
// homotopy equivalent to this pushforward.
//
// The second return value is the grading vector for A, if we are using gradings.
//
// The third (or second, if there is no grading) return value is a list R = (F1,G1,x1,N),(F2,G2,x2,N),...
// of the same length of intvars which records the F and G matrices returned by mfPushforward
// at each stage of the computation, along with the internal variable in question and the
// exponent it is associated with.

proc mfPushforwardInductive(matrix A, list intvars, list N, list H, list #)
{
    int useSanityChecks = blowFlags("sanity_checks"); // Turn off to run faster
    
    system("--ticks-per-sec",1000);
    int timeElapsed = timer;
    
    def RRR = basering;
    
    list R;
    
    // Check for grading
    int useGrading;
    if( size(#) > 0 )
    {
        intvec Agr = #[1];
        int useGrading = 1;
    }
    
    // Sanity check
    int i;
    if( useSanityChecks )
    {
        for(i=1;i<=size(intvars);i++)
        {
            if( A * H[i] + H[i] * A != intvars[i]^(N[i]) * unitmat(ncols(A)) )
            {
                print("[mfPushforward] Not passed valid homotopies, exiting.");
                return();
            }
        }
    }
    
    // Inductively we contract off the action of each of the external variables, using
    // the given homotopies. During the process we switch rings, killing off the 
    // external variables that we have used up
    
    int count = 1;
    def nR(1) = basering;
    
    while( size(intvars) > 0 )
    {
        //dbprint(printlevel, "[mfPushforwardInductive] In step " + string(count) + " with ring vars " + varstr(nR(count)));
        
        // Do the reduction with respect to the first variable and homotopy, and
        // induce homotopies on this reduction for the action of the rest of the variables
        if( !useGrading )
        {
            list l = mfPushforward(A, intvars[1], N[1], H);
        }
        else
        {
            list l = mfPushforward(A, intvars[1], N[1], H, Agr);
        }
    
        if( typeof(l[1]) == "string" )
        {
            //dbprint(printlevel, "[mfPushforwardInductive] Pushing forward produced nonsquare matrices.");
            
            // mfSplitIdempotent found, during mfPushforward, that it had to split
            // an idempotent on a complex. Our return value in this situation is
            // "nonsquare",[r1,r2],R' where r1,r2 are possible gradings. We are given
            // "nonsquare",f0,f1,g0,g1,[r1,r2] by mfPushforward
            poly ivar = intvars[1];
            setring RRR;
            
            if( count > 1 )
            {
                list l = imap(nR(count),l);
                poly ivar = imap(nR(count),ivar);
            }
            
            list ll = "nonsquare";
            
            if( useGrading )
            {
                ll = ll + list(l[6],l[7]); // Add on r1,r2
            }
            
            // Modify the current map list R by adding on the end the list f0,f1,g0,g1,intvars[1],N[1]
            // NOTE: We can't stick these together into block matrices (like the other
            // entries in R) because we might be rank zero in one component
            
            R = R + list(list(l[2],l[3],l[4],l[5],ivar,N[1]));
            ll = ll + list(R);
                        
            dbprint(printlevel, "[mfPushforwardInductive] total elapsed time " + string(timer-timeElapsed) + "ms.");
            //displaySplittingRecord(R); //debug
            
            return(ll);
        }
        
        // Legend
        // final = l[1] is the MF with intvars[1] excluded which is h.e. to the pushforward
        // l[2] is a map Ablow[1] --> final
        // l[3] is a map final --> Ablow[1] (where [1] means suspension)
        // l[4] is the grading (if we are using gradings) or our modified list of homotopies
        // l[5] is our homotopies if we are using the grading, and undefined otherwise
    
        // Return to the original ring and add to R the pair (l[2],l[3],intvar[1],N[1]). Note
        // we have to return to the original ring because l[2],l[3] may depend on
        // external variables which we are going to delete in a moment
        poly ivar = intvars[1];
        
        setring RRR;
        
            // The first time through nR(1) = RRR so there is no need for imap
            if( count > 1 )
            {
                list l = imap(nR(count),l);
                poly ivar = imap(nR(count),ivar);
            }
        
            R = R + list(list(l[2],l[3],ivar,N[1]));
            
        setring nR(count);
        
        // Remove the variable intvars[1] from our active ring
        list rlist = ringlist(nR(count));
        list varlist = rlist[2];
    
        // Create the new list of variables
        int i;
        for(i=1;i<=size(varlist);i++)
        {
            if( varlist[i] == string(intvars[1]) )
            {
                varlist = delete(varlist,i);
                break;
            }
        }
    
        list newringList;
        newringList[1] = rlist[1];
        newringList[2] = varlist;
        newringList[3] = rlist[3];
        newringList[4] = rlist[4];
        // Fix the variable weighting
        intvec kk = (1..size(varlist));
        for(i=1; i<=size(varlist); i++)
        {
            kk[i] = 1;
        }
        newringList[3][1][2] = kk;
    
        // Prepare for the next step of the induction
        A = l[1];
        if( useGrading ){ Agr = l[4]; }
        intvars = delete(intvars,1);
        N = delete(N,1);
        
        if( size(intvars) == 0 )
        {
            break;
        }

        H = l[4 + useGrading];
    
        // Create our new ring
        def nR(count+1) = ring(newringList);
        setring nR(count+1);
    
        matrix A = imap(nR(count),A);
        list intvars = imap(nR(count),intvars);
        list H = imap(nR(count),H);
        
        count++;
    }
    
    // Return to the original ring
    setring RRR;
    matrix Anew = imap(nR(count),A);
    
    list retlist = Anew;
    
    if( useGrading )
    {
        retlist = retlist + list(Agr);
    }
    
    // Add on the maps
    retlist = retlist + list(R);
    dbprint(printlevel, "[mfPushforwardInductive] total elapsed time " + string(timer-timeElapsed) + "ms.");
    
    return(retlist);
}

proc displaySplittingRecord(list R)
{
    print("[displaySplittingRecord] Given a splitting record of length " + string(size(R)));
    
    int i;
    for(i=1;i<=size(R);i++)
    {
        if( size(R[i]) == 4 )
        {
            string out = "[displaySplittingRecord]    Variable: ";
            out = out + string(R[i][3]) + " exponent: " + string(R[i][4]);
            out = out + " F: " + string(nrows(R[i][1])) + "x" + string(ncols(R[i][1])) + " G: ";
            out = out + string(nrows(R[i][2])) + "x" + string(ncols(R[i][2]));
            print(out);
        }
        else
        {
            string out = "[displaySplittingRecord]    Nonsquare, variable: ";
            out = out + string(R[i][5]) + " exponent: ";
            out = out + string(R[i][6]) + " f0: " + string(nrows(R[i][1])) + "x" + string(ncols(R[i][1]));
            out = out + " f1: " + string(nrows(R[i][2])) + "x" + string(ncols(R[i][2]));
            out = out + " g0: " + string(nrows(R[i][3])) + "x" + string(ncols(R[i][3]));
            out = out + " g1: " + string(nrows(R[i][4])) + "x" + string(ncols(R[i][4]));
            print(out);
        }// f0,f1,g0,g1,intvars[1],N[1]
    }
}

////////////////////////////////////////////////////////////////////
// mfInflate
//
// We are given a matrix A interpreted as the differential on a matrix factorisation X
// of a potential W in our ring, together with a ring variable intvar and a power N.
// We assume that W is a polynomial in the set of variables with intvar removed, and
// we return the differential on the tensor product X \otimes Q[intvar]/(intvar^N).

proc mfInflate(matrix A, poly intvar, int N)
{
    // Convert everything into a more suitable ring. We go through the original
    // list of ring variables, rename everything apart from intvar to y(i)'s (in
    // ascending order) and rename intvar to x(1)
    def RRR = basering;
    list rlist = ringlist(RRR);
    list varlist = rlist[2];
    
    // Create the new list of variables, where intvar is renamed to x(1)
    // and the other variables are enumerated as y(i)'s.
    list newvar;
    int i;
    int ycount;
    for(i=1;i<=size(varlist);i++)
    {
        if( string(intvar) == varlist[i] )
        {
            newvar = newvar + list("x(1)");
        }
        else
        {
            ycount++;
            string s = "y(" + string(ycount) + ")";
            newvar = newvar + list(s);
            kill s;
        }
    }
    
    list newringList;
    newringList[1] = rlist[1];
    newringList[2] = newvar;
    newringList[3] = rlist[3];
    newringList[4] = rlist[4];
    kill rlist;
    
    // Fix the variable weighting
    intvec kk = (1..size(newvar));
    for(i=1; i<=size(newvar); i++)
    {
        kk[i] = 1;
    }
    newringList[3][1][2] = kk;
    kill newvar, kk;
    
    // Create our new ring
    def nR = ring(newringList);
    kill newringList;
    setring nR;
    
    // Now we can call mablow
    matrix A = fetch(RRR,A);
    ideal J = x(1)^N;
    matrix Ablow = mablow(A,J);
    
    setring RRR;
    matrix final = fetch(nR,Ablow);
        
    return(final);
}
