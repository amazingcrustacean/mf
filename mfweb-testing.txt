///////////////////////////////////////////////////
// mfweb Example 1
///////////////////////////////////////////////////

option(noredefine);option(noloadLib);option(redSB);
LIB "blow.lib";
LIB "ring.lib";
LIB "linkhom.lib";
LIB "matrix.lib";
LIB "mfweb.lib";
LIB "mfweb-general.lib";
int nx=1;
int ny=3;
ring RRRR=(0,r),(x(1..nx),y(1..ny)),dp;
minpoly = rootofUnity(3);
poly minpolyblow = x(1)^2 + x(1) + 1;
printlevel=1;

matrix defect1[2][2] = 0,x(1)-r*y(1),(x(1)^3-y(1)^3)/(x(1)-r*y(1)),0;
matrix defect2[2][2] = 0,y(2)-r*x(1),(y(2)^3-x(1)^3)/(y(2)-r*x(1)),0;
matrix defect3[2][2] = 0,y(3)-r*y(2),(y(3)^3-y(2)^3)/(y(3)-r*y(2)),0;

// Define a web with three vertices and four edges, i.e. a defect fusion
//
//    --- y(1) ---> defect1 ---- x(1) ----> defect2 --- y(2) ---> defect3 --- y(3) --->

list e1 = list(0,1,list(y(1)),y(1)^3);
list e2 = list(1,2,list(x(1)),x(1)^3);
list e3 = list(2,3,list(y(2)),y(2)^3);
list e4 = list(3,0,list(y(3)),y(3)^3);
list web = list(3, list(e1,e2,e3,e4), list(defect1,defect2,defect3));

//    --- y(1) ---> defect1 ---- x(1) ----> defect2 --- y(2) --->
list subweb = subwebWithVertices(web, list(1,2));
list compStrat = list(1,2), list(x(1));
list L = webCompilePairGeneral(subweb, compStrat);
print(L[1]); // the final answer for the fusion of this subweb


///////////////////////////////////////////////////
// mfweb Example 2 - trefoil web
///////////////////////////////////////////////////

option(noredefine);option(noloadLib);option(redSB);
LIB "blow.lib";
LIB "ring.lib";
LIB "linkhom.lib";
LIB "matrix.lib";
LIB "mfweb.lib";
LIB "mfweb-general.lib";
ring rr=0,(x(1..6)),dp;
int N = 2; // The N in sl(N) link homology
printlevel = 1;


list linkL = linkLibrary("trefoil");
list web = webFromLink(linkL,intvec(0,1,1),N);
list compStrat = list(1,2,3), list(x(1),x(2),x(3),x(4),x(5),x(6));

list L = webCompileGeneral(web, compStrat);

// The old webCompile produces the following, all in even degrees
// 000: 2,0,0,-2
// 100: 1,-1
// 010: 1,-1
// 110: 0,-2,2,0
// 001: 1,-1
// 101: 0,-2,2,0
// 011: 0,-2,2,0
// with which the current code agrees, modulo a permutation on the 110 state.