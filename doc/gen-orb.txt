///////////////////////////////////////////////////////
// Attempt to algorithmically find generalised orbifolds
///////////////////////////////////////////////////////

option(noredefine);option(noloadLib);option(redSB);
LIB "mfweb.lib";
//ring rr=0,(u,v,x,y),dp;
ring rr=11,(u,v,x,y),dp;
printlevel = 1;

// We are looking for matrix factorisations of V - W
// of Koszul type { a1, a2 ; b1, b2 }, so we look for
// pairs of polynomials a1, a2 with V - W in the ideal (a1,a2).

// Given a list length and integer bound,
// returns all lists of integers of the given length
// with each entry between 1 and the bound (inclusive)
// There is an optional argument maxsize which, if specified,
// means that we omit from the list any sequences which have
// more than maxsize "non-1" entries
proc listofints(int len, int bound, list #)
{
    int maxsize = 0;
    
    if( size(#) > 0 )
    {
        maxsize = #[1];
    }
    
    list l;
    if( len > 1 )
    {
        if( maxsize != 0 )
        {
            l = listofints(len - 1, bound, maxsize);
        }
        else
        {
            l = listofints(len - 1, bound);
        }
    }
    else
    {
        int j;
        for(j = 1; j <= bound; j++ )
        {
            l = l + list(list(j));
        }
        
        return(l);
    }
    
    list nl;
    int i, j;
    for(i = 1; i <= size(l); i++ )
    {
        for(j = 1; j <= bound; j++ )
        {
            list new = list(j) + l[i];
            
            // Check to see how many non-1 entries this list has
            if( maxsize != 0 )
            {
                int c;
                int N = 0;
                for( c = 1; c <= size(new); c++ )
                {
                    if( new[c] != 1 ){ N++; }
                    if( N > maxsize ){ break; }
                }
                
                if( N <= maxsize )
                {
                    nl = nl + list(new);
                }
            }
            else
            {
                nl = nl + list(new);
            }
        }
    }
    
    return(nl);
}

// Given a list of allowed monomials, and allowed coefficients, the following routine returns
// a list of pairs (a1, a2) such that each ai is a linear combination of the allowed monomials
// using the allowed coefficients, such that Q belongs to the ideal generated by a1, a2
// There is an optional fourth argument maxsize, which specifies that we should only consider
// polynomials ai with at most maxsize nonzero coefficients.

proc findkoszul(list allowed, list allowed_coeff, poly Q, list #)
{
    list mlist;
    list retlist;
    int maxsize = 0;
    
    if( size(#) > 0 )
    {
        maxsize = #[1];
        print("Using only polynomials with at most " + string(maxsize) + " nonzero coefficients.");
        mlist = listofints(size(allowed), size(allowed_coeff), maxsize);
    }
    else
    {
        mlist = listofints(size(allowed), size(allowed_coeff));   
    }
    
    int i, j, c;
    for(i = 1; i <= size(mlist); i++ )
    {
        print("In step " + string(i) + " / " + string(size(mlist)) );
        
        list l1 = mlist[i];
        poly a1;
        
        for(c = 1; c <= size(l1); c++ )
        {
            a1 = a1 + allowed_coeff[ l1[c] ] * allowed[ c ];
        }
        
        for(j = i+1; j <= size(mlist); j++ )
        {

            list l2 = mlist[j];
        
            // Assemble the polynomials a1, a2
            poly a2;
        
            for(c = 1; c <= size(l1); c++ )
            {
                a2 = a2 + allowed_coeff[ l2[c] ] * allowed[ c ];
            }
        
            //print(string(a1) + " and " + string(a2));
            ideal J = a1,a2;
            ideal Jstd = std(J);
        
            if( reduce( Q, Jstd ) == 0 )
            {
                print("SUCCESS -----------------------");
                print(string(a1) + " and " + string(a2));
                print("-------------------------------");
                
                list n = a1, a2;
                retlist = retlist + list(n);
            }
        }
    }
    
    return(retlist);
}

///////////////
// EXAMPLE
//
// The defect between W = u6 - v2 and V = x3 - xy2
// which we know from Nils and Ingo's paper. In principle if you search
// among the monomials u, v, x, y, u2, uy you will need to look at 729 
// possibilites, but restricting to only a1, a2 with two nonzero coefficients
// this is reduced to 73

list allowed = u, v, x, y, u2, uy; //, uv, ux, uy, vx, vy, u2, v2, x2, y2;
list allowed_coeff = 0, -1, 1; // always put 0 first

list l = findkoszul( allowed, allowed_coeff, x3 - xy2 - u6 + v2, 2 );


///////////////
// EXAMPLE
//
// Looking for a defect between u12 - v2 and x3 + y4

list allowed = u, v, x, y, u2, v2, x2, y2, uv, ux, uy, vx, vy, u3, v3, x3, y3, u4;
// u2v, u2x, u2y, uv2, v2x, v2y, ux2, vx2, x2y, uy2, vy2, xy2, u4, v4, x4, y4;
list allowed_coeff = 0, -1, 1;

list l = findkoszul( allowed, allowed_coeff, x3 + y4 - u12 + v2, 3 );

// List of tried things
//
// u, v, x, y, u2, v2, x2, y2, uv, ux, uy, vx, vy, u3, v3, x3, y3, allowed_coeff = 0, -1, 1, size = 2
//      RESULT: reports only -u3+y and x3+v2
// u, v, x, y, u2, v2, x2, y2, uv, ux, uy, vx, vy, u3, v3, x3, y3, u4, allowed_coeff = 0, -1, 1, size = 3
//      RESULT: reports only -u3+y and x3+v2