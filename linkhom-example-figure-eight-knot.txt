/////////////////////////////////////////////////////////////////////////////////////////
// Compute KR cohomology of "figure-eight knot".
/////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////
// We use the conventions and labellings of the note [FEK] from 2010-08-09. 
//
// Part 1: Try to reduce the matrix factorisations "((AA)B)B" from [FEK, p.3].
/////////////////////////////////////////////////////////////////////////////////////////

// Step 1.1: Compile "AA"

option(noredefine);option(noloadLib);option(redSB);
LIB "blow.lib";
LIB "linkhom.lib";
LIB "matrix.lib";
int nx=2;
int ny=4;
ring rr=0,(x(1..nx),y(1..ny)),dp;
int N = 2; // The N in sl(N) link homology
printlevel = 1;

// In the notation of [FEK, p.1] the Figure eight knot has four crossings, which
// we refer to by the tuple of variables incident at the crossing (e.g. 1578). At the
// crossing 1578 we place A1 and at 2678 we place A2, defined as follows:

matrix A1a = mfIdentityDefect( y(1)^(N+1), y(2)^(N+1), y(1), y(2) );
matrix A1b = mfIdentityDefect( x(1)^(N+1), x(2)^(N+1), x(1), x(2) );
matrix A1 = MFtensor(A1a, A1b);
matrix A2a = mfIdentityDefect( y(3)^(N+1), y(4)^(N+1), y(3), y(4) );
matrix A2b = mfIdentityDefect( x(2)^(N+1), x(1)^(N+1), x(2), x(1) );
matrix A2 = MFtensor(A2a, A2b);

// Here the mapping between Singular variables and edge labels of [FEK] is
// x(1) = 7, x(2) = 8, y(1) = 1, y(2) = 5, y(3) = 6, y(4) = 2

ideal J = x(1)^N, x(2)^N;
intvec q = N, N;
number Nn = N + 1;
matrix C[2][2] = 1/Nn, 0, 0, 1/Nn;

// Compute the ordinary tensor product
matrix D = MFtensor(A1,A2);
matrix Dblow = mablow(D,J);

// Reduce this inflated differential
list l = mfReduce(Dblow,1);
matrix RD = l[1];
matrix F = l[2]; // A homotopy equivalence F: Dblow -> RD
matrix G = l[3]; // A homotopy equivalence G: RD -> Dblow

matrix diff1 = ZZtensor( diff(A1, x(1)), unitmat(ncols(A2)) );
matrix diff2 = ZZtensor( unitmat(ncols(A1)), diff(A2, x(2)) );
matrix iddQ = mablow( det(C) * diff1 * diff2, J );

matrix delta1 = mablow_delta(D, 1, 2, J);
matrix delta2 = mablow_delta(D, 2, 2, J);
matrix delQ = delta1 * delta2;

// And finally the idempotent e on Dblow
int sign = (nx * (nx-1)) div 2;
matrix e = (-1)^(sign) * iddQ * delQ;

matrix ep = F * e * G;
ep * RD == RD * ep;
ep * ep == ep;

// Strictify this idempotent (ep is already idempotent on the nose, so this is not really necessary):
matrix epfinal = mfStrictifyIdempotent(RD, ep);
epfinal * RD == RD * epfinal;
epfinal * epfinal == epfinal;

matrix finalAA = mfSuspend( mfSplitIdempotent(RD, epfinal), nx );
print(finalAA);

// Step 1.2: Compile "AAB"

// We now collapse the top two crossings of the figure-eight into a single vertex, where
// we place finalAA, which in the notation of [FEK] has outgoing edges labelled 1 and 6
// and incoming edges 2 and 5. If we consider the web with this vertex and the vertex
// 3456 then there are four external variables (1,2,3,4) and two internal variables (5,6).
// Note that finalAA only involves y(1),...,y(4) which map to 1,5,6,2. If we run

matrix AAv = subst(finalAA,y(2),x(1));
matrix AA = subst(AAv,y(3),x(2));

// Then finalAA involves y(1),x(1),x(2),y(4). The remaining variables y(2),y(3) we now
// consider to represent the edges 3,4. So the current mapping of Singular variables
// to edge labels is
// x(1) = 5, x(2) = 6, y(1) = 1, y(2) = 3, y(3) = 4, y(4) = 2

matrix B3 = mfWideEdge( y(2), x(1), y(3), x(2), N );

// Compute the ordinary tensor product
matrix D = MFtensor(AA,B3);
matrix Dblow = mablow(D,J);

// Reduce this inflated differential
list l = mfReduce(Dblow,1);
matrix RD = l[1];
matrix F = l[2]; // A homotopy equivalence F: Dblow -> RD
matrix G = l[3]; // A homotopy equivalence G: RD -> Dblow

matrix diff1 = ZZtensor( diff(AA, x(2)), unitmat(ncols(B3)) );
matrix diff2 = ZZtensor( unitmat(ncols(AA)), diff(B3, x(1)) );
matrix iddQ = mablow( det(C) * diff1 * diff2, J );

matrix delta1 = mablow_delta(D, 1, 2, J);
matrix delta2 = mablow_delta(D, 2, 2, J);
matrix delQ = delta1 * delta2;

// And finally the idempotent e on Dblow
int sign = (nx * (nx-1)) div 2;
matrix e = -1 * (-1)^(sign) * iddQ * delQ;

matrix ep = F * e * G;
ep * RD == RD * ep;
ep * ep == ep;

// Strictify this idempotent (ep is already idempotent on the nose, so this is not really necessary):
matrix epfinal = mfStrictifyIdempotent(RD, ep);
epfinal * RD == RD * epfinal;
epfinal * epfinal == epfinal;

matrix finalAAB = mfSuspend( mfSplitIdempotent(RD, epfinal), nx );
print(finalAAB);

// Step 1.3: Compile "AABB"

// So finalAAB involves y(1),y(2),y(3),y(4) which currently represent the labels 1,3,4,2.
// We transfer finalAAB into a new ring, relabelling y(i) into x(i)

// Relabel variables:
int nx=4;
int ny=4;
ring rr2=0,(x(1..nx),y(1..ny)),dp;
int N = 2; // The N in sl(N) link homology
matrix finalAAB = imap(rr,finalAAB);
matrix AAB1 = subst(finalAAB,y(1),x(1));
matrix AAB2 = subst(AAB1,y(2),x(2));
matrix AAB3 = subst(AAB2,y(3),x(3));
matrix AAB = subst(AAB3,y(4),x(4));
int nx=4;
ring rr3=0,(x(1..nx)),dp;
int N = 2;
matrix AAB = imap(rr2,AAB);

// Our current mapping is x(1) = 1, x(2) = 3, x(3) = 4, x(4) = 2.

matrix B4 = mfWideEdge( x(3), x(4), x(2), x(1), N );

ideal J = x(1)^N, x(2)^N, x(3)^N, x(4)^N;
intvec q = N, N, N, N;
number Nn = N + 1;
matrix C[4][4] = 1/Nn * unitmat(4);

// Compute the ordinary tensor product
matrix D = MFtensor(AAB,B4);
matrix Dblow = mablow(D,J);

// Reduce this inflated differential
list l = mfReduce(Dblow,1);
matrix RD = l[1];
matrix F = l[2]; // A homotopy equivalence F: Dblow -> RD
matrix G = l[3]; // A homotopy equivalence G: RD -> Dblow

// RD is the zero matrix:
RD == zeromat(ncols(RD));

matrix diff1 = ZZtensor( diff(AAB, x(1)) * diff(AAB, x(2)), unitmat(ncols(B4)) );
matrix diff2 = ZZtensor( unitmat(ncols(AAB)), diff(B4, x(3)) * diff(B4, x(4)) );
matrix iddQ = mablow( det(C) * diff1 * diff2, J );

matrix delta1 = mablow_delta(D, 1, 2, J);
matrix delta2 = mablow_delta(D, 2, 2, J);
matrix delta3 = mablow_delta(D, 3, 2, J);
matrix delta4 = mablow_delta(D, 4, 2, J);
matrix delQ = delta1 * delta2 * delta3 * delta4;

// And finally the idempotent e on Dblow
int sign = (nx * (nx-1)) div 2;
matrix e = (-1)^(sign) * iddQ * delQ;

matrix ep = F * e * G;
ep * RD == RD * ep;
ep * ep == ep;

// Strictify this idempotent:
matrix epfinal = mfStrictifyIdempotent(RD, ep);
epfinal * RD == RD * epfinal;
epfinal * epfinal == epfinal;

matrix finalAABB = mfSuspend( mfSplitIdempotent(RD, epfinal), nx );
// This gives (since mfSplitIdempotent is not equipped to deal with MFs of zero): 
// [mfSplitIdempotent] Debug break 3
// [mfSplitIdempotent] Splitting produced nonsquare matrices, exiting.

matrix ep0 = extractblockmat(epfinal)[1];
matrix ep1 = extractblockmat(epfinal)[4];
print(mat_rk(ep0));
print(mat_rk(ep1));

// Hence the reduced form of AABB is 0 -> QQ^8 -> 0, where QQ = rationals.

// We can also check this using the following Chern character calculation
// In the following the variable x(i) maps to the edge i.
// option(noredefine);option(noloadLib);option(redSB);
// LIB "blow.lib";
// LIB "linkhom.lib";
// LIB "matrix.lib";
// int nx=8;
// int N = 2; // The N in sl(N) link homology
// ring rr=0,(x(1..nx)),dp;
// matrix A1a = mfIdentityDefect( x(7)^(N+1), x(8)^(N+1), x(7), x(8) );
// matrix A1b = mfIdentityDefect( x(1)^(N+1), x(5)^(N+1), x(1), x(5) );
// matrix A1 = MFtensor(A1a, A1b);
// poly ch1 = supertrace( diff(A1, x(1)) * diff(A1, x(5)) * diff(A1, x(7)) * diff(A1, x(8)) );
// matrix A2a = mfIdentityDefect( x(8)^(N+1), x(7)^(N+1), x(8), x(7) );
// matrix A2b = mfIdentityDefect( x(6)^(N+1), x(2)^(N+1), x(6), x(2) );
// matrix A2 = MFtensor(A2a, A2b);
// poly ch2 = supertrace( diff(A2, x(2)) * diff(A2,x(6)) * diff(A2,x(7)) * diff(A2,x(8)));
// matrix B3 = mfWideEdge( x(3), x(5), x(6), x(4), N );
// poly ch3 = supertrace( diff(B3, x(3)) * diff(B3,x(5)) * diff(B3,x(6)) * diff(B3,x(4)));
// matrix B4 = mfWideEdge( x(2), x(4), x(1), x(3), N );
// poly ch4 = supertrace( diff(B4, x(2)) * diff(B4,x(4)) * diff(B4,x(1)) * diff(B4,x(3)));
// ideal J = x(1)^N, x(2)^N, x(3)^N, x(4)^N, x(5)^N, x(6)^N, x(7)^N, x(8)^N;
// poly chernFinal = reduce( ch1 * ch2 * ch3 * ch4, std(J) );
// The total Chern character is this divided by (N+1)^8 and with Res( - / x(1)^N ... x(8)^N ) applied.
// For N = 2 this yields 8 (up to a sign), confirming the calculation above.

matrix eq0f = ep1;

// Now split the idempotent by hand:
LIB "control.lib";
module ker0 = rightKernel(unitmat(ncols(eq0f)) - eq0f);
matrix f0 = ker0;
matrix g0[ncols(f0)][nrows(f0)]; // Defaults to zero
    
if( ker0[1] != [0] )
{
    matrix g0 = leftInverse(f0) * eq0f; // Solves f0 * g0 = eq0f.
};

// Check that (f0,g0) is a splitting of ep1:
f0 * g0 == ep1;
g0 * f0 == unitmat(ncols(g0 * f0));


// Step 2: define and reduce the map between AABB and AABA+AAAB++BABB+ABBB:

matrix chi0 = mfChi0(x(1),x(2),x(3),x(4),N);
matrix chi1 = mfChi1(x(1),x(2),x(3),x(4),N);


// Let (f x g) x h : (A x B) x C --> (A' x B') x C' be a morphism, and let
// F1: (A x B)_blow --> (A x B)_reduced be a morphism with homotopy inverse G1, 
// F2: ((A x B)_reduced x C)_blow --> ((A x B)_reduced x C)_reduced be a 
// morphism with homotopy inverse G2. Then
//     (((f x g)_blow o G1) x h)_blow o G2
// is the associated morphism ((A x B)_reduced x C)_reduced --> (A' x B') x C'.
// Similarly, we get a morphism 
// ((A x B)_reduced x C)_reduced --> ((A' x B')_reduced x C')_reduced by also
// making use of F1 and F1 "from the left".
//
// Iterating this construction one more time and using the various maps F,G from
// above (which have to be renamed F1,G1,F2,G2,F3,G3), we obtain the map 
// (AABB)_reduced --> (AABA+AAAB++BABB+ABBB)_reduced (together with Step 3 below)
// between the degree -2 piece and the degree -1 piece of KR cohomology.

// I will do this later.


// Step 3: TODO: compile the web AABA+AAAB++BABB+ABBB:




