// Trefoil ///////////////////////////////////////////
//
// Also 3_1. See http://katlas.org/wiki/The_Rolfsen_Knot_Table.

option(noredefine);option(noloadLib);option(redSB);//option(prot);
LIB "blow.lib";
LIB "linkhom.lib";
LIB "matrix.lib";
LIB "control.lib";
LIB "mfweb.lib";
ring rr=0,(x(1..6)),dp;
int N = 6; // The N in sl(N) link homology
printlevel = 1;

list trefoilLink = linkLibrary("trefoil");
list h = linkCompile(trefoilLink, "./data/trefoil-N" + string(N) + "-zoom.mp", N);
list cp = KRcomplex(trefoilLink, h, N);

ring ss=(0,t,q),(x),dp;

list cp = imap(rr,cp);
list cohom = computeCohomology(cp);
number euler = gradedEuler(cohom,q);
euler;

// The KR homology is described by its Poincare polynomial
number poincare = gradedPoincare(cohom, q, t);
poincare;

// Jones polynomial: -q9 + q5 + q3 + q

// KR invariants /////////////////////

// N = 2 (q9+q5t+q3t3+qt3)/(t3)
// agrees with the data on the Knot Atlas.

// N = 3 (q14+q12+q8t+q6t3+q6t+q4t3+q2t3)/(t3)
// agrees with Gukov-Schwarz-Vafa (GSV).

// N = 4 (q19+q17+q15+q11t+q9t3+q9t+q7t3+q7t+q5t3+q3t3)/(t3) 
// (103 seconds) agrees with GSV.

// N = 5 (q24+q22+q20+q18+q14t+q12t3+q12t+q10t3+q10t+q8t3+q8t+q6t3+q4t3)/(t3)
// (176 seconds) agrees with GSV.

// N = 6 (t3q15+t3q13+t3q11+t3q9+t3q7+t3q5+tq17+tq15+tq13+tq11+tq9+q29+q27+q25+q23+q21)/(t3)
// (state 8 took 3325 seconds).
// With new splitting code: 300 seconds total!

// Trefoil - reduced ///////////////////////////////////////////

option(noredefine);option(noloadLib);option(redSB);//option(prot);
LIB "blow.lib";
LIB "linkhom.lib";
LIB "matrix.lib";
LIB "control.lib";
LIB "mfweb.lib";
ring rr=0,(x(1..6)),dp;
int N = 5; // The N in sl(N) link homology
printlevel = 1;

list trefoilLink = linkLibrary("trefoil");
list h = linkCompileReduced(trefoilLink, "./data/trefoil-N" + string(N) + "-zoom-reduced.mp", N, x(1), 1);
list cp = KRcomplex(trefoilLink, h, N);

ring ss=(0,t,q),(x),dp;

list cp = imap(rr,cp);
list cohom = computeCohomology(cp);
number euler = gradedEuler(cohom,q);
euler;

// The KR homology is described by its Poincare polynomial
number poincare = gradedPoincare(cohom, q, t);
poincare;

// N = 2:

// Note that the web compilations actually produce Z/2-graded Q spaces living in both Z2
// degrees, but apparently we should only use on degree to get the right euler char...

// If useDegree = 1 in linkCompileReduced, the reduced N = 2 euler characteristic is
// q2 + q6 - q8, which is what it should be, since
(q2 + q6 - q8)*(q+1/q) == -q9 + q5 + q3 + q;

// If useDegree = 0 then you get (-q7+q5+q), i.e. 1/q * the correct answer.
// If useDegree = -1 (i.e. use all of the Z2-graded module) you get (-q8-q7+q6+q5+q2+q)
// i.e. the sum of the two

// N = 3 and useDegree = 0:
euler * ( (q^N - 1/q^N)/(q - 1/q) );
// = (-q12-q10+q6+2q4+q2+1)

// N = 3 and useDegree = 1:
euler * ( (q^N - 1/q^N)/(q - 1/q) );
// = (-q14-q12+q8+2q6+q4+q2)                        // As it should be.

// N = 4 and useDegree = 0:
euler * ( (q^N - 1/q^N)/(q - 1/q) );
// = (-q16-q14-q12+q8+2q6+2q4+q2+1)

// N = 4 and useDegree = 1:
euler * ( (q^N - 1/q^N)/(q - 1/q) );
// (-q19-q17-q15+q11+2q9+2q7+q5+q3)                 // As it should be.

// N = 5 and useDegree = 1:
euler * ( (q^N - 1/q^N)/(q - 1/q) );
// (-q24-q22-q20-q18+q14+2q12+2q10+2q8+q6+q4)       // As it should be.


// Now redundant ranting on reduced KR homology computations

option(noredefine);option(noloadLib);option(redSB);//option(prot);
LIB "blow.lib";
LIB "linkhom.lib";
LIB "matrix.lib";
LIB "mfweb.lib";
ring rr=0,(x(1..6)),dp;
int N = 2; // The N in sl(N) link homology
printlevel = 1;

list trefoilLink = linkLibrary("trefoil");
// The usual compilation:
//list compStrat = list(1,2,3),list(x(1),x(2),x(3),x(4),x(5),x(6));
// list web111 = webFromLink(trefoilLink, intvec(1,1,1), N);
//list D = webCompile(web111,compStrat); // dim 4 in degree zero

// Now do the same compilation (the usual one) by hand
matrix X(1) = web111[3][1];
intvec Xgr(1) = web111[4][1];
matrix X(2) = web111[3][2];
intvec Xgr(2) = web111[4][2];
matrix X(3) = web111[3][3];
intvec Xgr(3) = web111[4][3];
matrix X = MFtensor(MFtensor(X(1),X(2)),X(3));
intvec Xgr = MFtensorGradings(MFtensorGradings(Xgr(1),Xgr(2)),Xgr(3));

int i;
for(i=1; i<=2; i++)
{
    matrix h(i) = 1/3 * diff(X(1),x(i));
    matrix H(i) = ZZtensor(ZZtensor(h(i),unitmat(ncols(X(2)))),unitmat(ncols(X(3))));
    
    matrix h(i+2) = 1/3 * diff(X(2),x(i+2));
    matrix H(i+2) = ZZtensor(ZZtensor(unitmat(ncols(X(1))),h(i+2)),unitmat(ncols(X(3))));
    
    matrix h(i+4) = 1/3 * diff(X(3),x(i+4));
    matrix H(i+4) = ZZtensor(ZZtensor(unitmat(ncols(X(1))),unitmat(ncols(X(2)))),h(i+4));
}

for(i=1; i<=6; i++)
{
    H(i) * X + X * H(i) == x(i)^2 * unitmat(ncols(X));
}

// list D = mfPushforwardInductive(X, list(x(1),x(2),x(3),x(4),x(5),x(6)), list(2,2,2,2,2,2), list(H(1),H(2),H(3),H(4),H(5),H(6)), Xgr);
// If you print D[2],D[3] you see that we get the same results as from webCompile

// Now we do the compilation of the 000 state in the reduced homology,
// by substituting x(1) = 0 in all the MFs and eliminating only x(2),...,x(6)
for(i=1; i<=3; i++)
{
    matrix Y(i) = subst(X(i),x(1),0);
    intvec Ygr(i) = Xgr(i);
}

for(i=1; i<=6; i++)
{
    matrix G(i) = subst(H(i),x(1),0);
}

matrix Y = MFtensor(MFtensor(Y(1),Y(2)),Y(3));
intvec Ygr = MFtensorGradings(MFtensorGradings(Ygr(1),Ygr(2)),Ygr(3));

for(i=2; i<=6; i++)
{
    G(i) * Y + Y * G(i) == x(i)^2 * unitmat(ncols(Y));
}

// mfPushforwardInductive is fed homotopies between the action of x(i)^2 and 0, for 1 <= i <= 6
list D = mfPushforwardInductive(Y, list(x(2),x(3),x(4),x(5),x(6)), list(2,2,2,2,2), list(G(2),G(3),G(4),G(5),G(6)), Ygr);
print(D[1]);

// Should be the same as using webFromLink with the reduction parameter
list compStratR = list(1,2,3),list(x(2),x(3),x(4),x(5),x(6));
list web111alt = webFromLink(trefoilLink, intvec(1,1,1), N, x(1));
list Dalt = webCompile(web111alt, compStratR);
// And indeed it is (compare Dalt[1] with D[1]).

// The compilation is a MF of zero, rank two in each degree, with zero differentials.
// We get the same result if we switch to the ring 0,(x(2..6)),dp beforehand

// So now we trust webCompile and do not need to do the reduced compilations by hand...

// Now compile the three states to which 111 maps (in reduced homology). Note that we can do this
// calculation by hand (as above) or with webCompile. The latter is better because then
// we can use webCompileMorphism

list web011 = webFromLink(trefoilLink, intvec(0,1,1), N, x(1));
list D011 = webCompile(web011,compStratR);

list web101 = webFromLink(trefoilLink,intvec(1,0,1), N, x(1));
list D101 = webCompile(web101,compStratR);

list web110 = webFromLink(trefoilLink,intvec(1,1,0), N, x(1));
list D110 = webCompile(web110,compStratR);

matrix F011 = subst(mfChi(1,x(2),x(1),x(3),x(4),N),x(1),0);
matrix map1 = webCompileMorphismFromData(web111alt, Dalt, web011, D011, compStratR, F011, 1);

matrix F101 = subst(mfChi(1,x(4),x(3),x(5),x(6),N),x(1),0);
matrix map2 = webCompileMorphismFromData(web111alt, Dalt, web101, D101, compStratR, F101, 2);

matrix F110 = subst(mfChi(1,x(6),x(5),x(1),x(2),N),x(1),0);
matrix map3 = webCompileMorphismFromData(web111alt, Dalt, web110, D110, compStratR, F110, 3);

// Compute the cohomology in position -3 which is the intersection of the kernels of
// map1, map2, map3
module h = intersect(rightKernel(map1),rightKernel(map2),rightKernel(map3));
print(Dalt[1]);

// We get that h = gen(3),gen(7), but gen(3) is in degree zero and gen(7) is in degree 1.
// Note the symmetry though.

// Note that the Euler characteristic of the reduced KR homology for N = 2 should be
// the Jones polynomial divided by (q+1/q), which is q2 + q6 - q8 (I think). Note that
// the grading assigned to the 111 reduced compilation web is
Dalt[2] + 6;
// which is 5,3,7,5,6,4,8,6
// so our generators lie in degrees 7 and 8. It is at least possible that if we ignore
// the Z2 grading and just define the Euler char in the usual way, this q7 will cancel
// with something in degree -1 (the q7s cancel in a similar way when you compute the 
// normalised jones poly, so this seems plausible).