option(noredefine);option(noloadLib);option(redSB);
LIB "blow.lib";
LIB "linkhom.lib";
LIB "matrix.lib";
LIB "control.lib";
LIB "mfweb.lib";
ring rr=0,(x(1..6)),dp;
int N = 5; // The N in sl(N) link homology
printlevel = 1;

// Define the underlying web of the trefoil
intvec edgevec(1) = 2,1,3,4;
intvec edgevec(2) = 4,3,5,6;
intvec edgevec(3) = 6,5,1,2;

// Define which vertices are overcrossings (+1) and which are undercrossings (-1):
intvec vertexParity = -1,-1,-1;

// Define the link as a list (see linkhom.lib preceding mfCompileLink)
list trefoilLink = vertexParity, list(edgevec(1),edgevec(2),edgevec(3));

// RUNNING ON LANDI SINCE 2010-09-25--08:20:
// Compute the euler characteristic, from trefoil-data
list h = mfCompileLinkAlt(trefoilLink, "./data/trefoil-N" + string(N) + "-zoom.mp", N);

list cp = KRcomplex(trefoilLink, h);

ring ss=(0,q,t),(x),dp;
list cp = imap(rr,cp);
list cohom = computeCohomology(cp);
number euler = gradedEuler(cohom,q);
euler;

// The KR homology is described by its Poincare polynomial
number poincare = gradedPoincare(cohom, q, t);
poincare;

// Running the above code with the state of things on 24/9/10 yields
// the following.

// N = 2 invariants of the trefoil
//
// Jones polynomial: -q9 + q5 + q3 + q
// KR polynomial: (q9+q5t+q3t3+qt3)/(t3) 
//
// The Jones polynomial agrees with what I calculated by hand, and
// the KR polynomial agrees with the data on the Knot Atlas.

// N = 3 invariants of the trefoil
// 
// P_3: -q14-q12+q8+2q6+q4+q2
// KR polynomial: (q14+q12+q8t+q6t3+q6t+q4t3+q2t3)/(t3)
//
// The KR polynomial (and hence P_3) agree with the ones computed
// by Gukov-Schwarz-Vafa (GSV).

// N = 4 invariants
//
// P_4: -q19-q17-q15+q11+2q9+2q7+q5+q3
// KR polynomial: (q19+q17+q15+q11t+q9t3+q9t+q7t3+q7t+q5t3+q3t3)/(t3)
//
// Note that here the main holdup seems to be several calls to minbase.
// In total the calculation took around 23 minutes. I think the problem
// is a baby version of what makes the N = 5 so slow.

// N = 5 doesn't go through. The first three states are very fast, 
// then in state 4/8 we get bogged down. Every matrix operation takes
// forever, and the mfReduce runs are huge. I think the problem is not
// that the matrices are big, but that their _entries_ are big numbers.
// This can be seen already in N = 4, try printing out the KR complex.
[mfCompileLinkAlt] Looking at state [1,1,0] which is number [[ 4/8 ]].
[mfCompileLinkAlt] Currently used memory: 1174kb.
[webCompile] Entering round 1 of compilation.
[mfPushforward] Pushing forward matrix of size 16 with N = 5
[mfReduce] Reducing matrix of size 80
[mfReduce]          result is size 16.
[mfReduce]          elapsed time 3740ms.
[mfPushforward] result is size 8.
[mfPushforward] elapsed time 5590ms.
[mfPushforward] Pushing forward matrix of size 8 with N = 5
[mfReduce] Reducing matrix of size 40
[mfReduce]          result is size 16.
[mfReduce]          elapsed time 2490ms.
[mfPushforward] result is size 8.
[mfPushforward] elapsed time 5720ms.
[mfPushforwardInductive] total elapsed time 11360ms.
[webCompile] Entering round 2 of compilation.
[mfPushforward] Pushing forward matrix of size 32 with N = 5
[mfReduce] Reducing matrix of size 160
[mfReduce]          result is size 32.
[mfReduce]          elapsed time 608050ms.
[mfPushforward] result is size 16.
[mfPushforward] elapsed time 3228920ms.
[mfPushforward] Pushing forward matrix of size 16 with N = 5
[mfReduce] Reducing matrix of size 80
[mfReduce]          result is size 16.
[mfReduce]          elapsed time 14768090ms. // Bit over four hours!
