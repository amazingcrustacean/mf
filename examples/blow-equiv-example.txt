/////////////////////////////////////////////////////////////////////////////
// Examples of fusion of equivariant defects
//

// Checked 16-10-2020 with Singular 4.1.0

//////////////////////////////////////////////////////////////////////////////////////
// EXAMPLE A1 - Tensoring (x,x2) with a factorisation of y^3 - x^3
//
// Here the group is G = Z/(3)
//
////////////////////////////////////////////////////////////////////////////////////

option(noredefine);option(noloadLib);option(redSB);
LIB "blow.lib";
LIB "blowequiv.lib";
ring rr=(0,r),(x(1),y(1)),dp; minpoly=rootofUnity(3);
poly minpolyblow = x(1)^3 + 1;
list varGrading;
varGrading[1] = intvec(1);
intvec G = (3);
printlevel = 1;

poly W = x(1)^3;

// X = Q(M,1) 
int M = 1;
matrix X[2][2] = 0, x(1), x(1)^2, 0; // X is a MF of W
list Xequiv;
Xequiv[1] = intvec(M); // G-grading of even generator
Xequiv[2] = intvec(M+1); // G-grading of odd generator
isEquivMFValid(X, Xequiv, G, varGrading);

// Y is a factorisation of V - W, which we consider as a functor between MF(W) and MF(y(1)^3).
// We want to compute the image of X under this functor, that is, the fusion of Y and X
// over the intermediate group G
int m = 0;
intvec n = (1,1,1);
int dprime = size(n);
int d = sum(n);
poly V = y(1)^dprime;
list roots_of_unity = list(r);
list l = defectBrunnerRoggenkamp(m, n, r);
matrix Y = l[1]; // Matrix

list Yequiv_extra = l[2]; // Z/d'Z grading
list Yequiv = l[3]; // Z/dZ grading
isEquivMFValid(Y, Yequiv, G, varGrading);

matrix A = fuseEquivDefects(Y, X, G, varGrading, roots_of_unity, W, Yequiv, Xequiv, W, Yequiv_extra);

print(A); // This is the differential on the fusion of Y with X

// Should be 0, 3y(1), 1/3y(1)^2, 0

//////////////////////////////////////////////////////////////////////////////////////
// EXAMPLE A2 - Tensoring P^{(m,n)} with Q^{(M,1)} 
//
// Here the group is G = Z/(d) and the fusion is (5.38) of Brunner-Roggenkamp
// which states that
//
//   P^{(m,n)} * Q^{(M,1)} = 0 if M is not in m + { 0, n_1, n_1 + n_2, ... }
//                         = Q^{(a,1)} if M = m + n_1 + ... + n_a
//
// here n = (n_0, n_1, ..., n_{d'-1})
////////////////////////////////////////////////////////////////////////////////////

option(noredefine);option(noloadLib);option(redSB);
LIB "blow.lib";
LIB "blowequiv.lib";

int d = 6;
int dprime = 3;

// Note that we need both primitive dth and d'th roots of unity
// which means we should add to our field a primitive qth root
// where q = lcm(d,d')

ring rr=(0,r),(x(1),y(1)),dp; minpoly=rootofUnity(lcm(d,dprime));
poly minpolyblow = x(1)^(lcm(d,dprime)) + 1;
list varGrading;
varGrading[1] = intvec(1);
intvec G = (d);
printlevel = 1;

poly droot = r^(lcm(d,dprime) div d);
poly dprimeroot = r^(lcm(d,dprime) div dprime);

poly W = x(1)^d;

// X = Q(M,1) = boundaryBrunnerRoggenkamp(M,1,d)
int M = 6;
list l = boundaryBrunnerRoggenkamp(M, 1, d);
matrix X = l[1];
list Xequiv = l[2];
isEquivMFValid(X, Xequiv, G, varGrading);

// defectBrunnerRoggenkamp(m, n) size(n) = dprime, sum(n) = d
list l = defectBrunnerRoggenkamp(0, intvec(2,2,2), dprimeroot);
matrix Y = l[1]; // Matrix
list Yequiv = l[3]; // Z/dZ grading
isEquivMFValid(Y, Yequiv, G, varGrading);

// Since m = 0 the fusion should be zero unless M is in {0, 2, 4, 6}
matrix A = fuseEquivDefects(Y, X, G, varGrading, list(droot), W, Yequiv, Xequiv, W);
print(A);