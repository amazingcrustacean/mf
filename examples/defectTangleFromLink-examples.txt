//
// Obtaining defects of x^d-y^d from cutting links
//

// Example 1: trefoil and d=4 ---------------------------------------------------------------------------

option(noredefine);option(noloadLib);option(redSB);//option(prot);
LIB "blow.lib";
LIB "linkhom.lib";
LIB "mfweb.lib";
ring rr=0,(x(1..7)),dp;
printlevel = 1;

int N = 3;
list linkData = linkLibrary("trefoil");
list states = powervec(3);
list defects;

// Compute the defects that you get from cutting all states at all possible places:
for( int cutpos=1; cutpos<=6; cutpos++ )
{    
    print(""); print("Cutting edge " + string(cutpos) + ":"); print("");
    defects[cutpos] = list();
    for( int i=1; i<=size(states); i++ )
    {
        list L = defectTangleFromLink(linkData, states[i], N, cutpos);
        list web = L[1];
        list compStrat = L[2];
        defects[cutpos][i] = webCompile(web, compStrat)[1];
        kill L,web,compStrat;
    }
}

for( int cutpos=1; cutpos<=6; cutpos++ )
{    
    for( int i=1; i<=size(states); i++ )
    {
        print("The defect we get form state " + string(i) + " has size " + string( ncols(defects[cutpos][i]) ) + " if we cut the edge number " + string(cutpos) + ".");
    }
    print("");
}

// We seem to get the same result independent of where we cut, for example: 
The defect we get form state 1 has size 6 if we cut the edge number 1.
The defect we get form state 2 has size 4 if we cut the edge number 1.
The defect we get form state 3 has size 4 if we cut the edge number 1.
The defect we get form state 4 has size 8 if we cut the edge number 1.
The defect we get form state 5 has size 4 if we cut the edge number 1.
The defect we get form state 6 has size 8 if we cut the edge number 1.
The defect we get form state 7 has size 8 if we cut the edge number 1.
The defect we get form state 8 has size 16 if we cut the edge number 1.

// UPDATE: The smallest defects of size 4 above are precisely those where exactly one vertex in the
//         web is a "wide edge" (corresponding to a 1) and all the rest are just tensor products of
//         identity defects (corresponding to a 0). This in particular means that defects[1][5] and
//         the others below are _not_ new. 
> states;
[1]:
   0,0,0
[2]:
   1,0,0
[3]:
   0,1,0
[4]:
   1,1,0
[5]:
   0,0,1
[6]:
   1,0,1
[7]:
   0,1,1
[8]:
   1,1,1


// These are at least not obviously tensor products or direct sums (or are they?):
> print(defects[1][5]);
0,                0,                _[1,3],0,     
0,                0,                _[2,3],_[2,4],
512*x(1)-512*x(7),0,                0,     0,     
_[4,1],           512*x(1)-512*x(7),0,     0  
    
> defects[1][5];
_[1,1]=0
_[1,2]=0
_[1,3]=1/512*x(1)^3+1/512*x(1)^2*x(7)+1/512*x(1)*x(7)^2+1/512*x(7)^3
_[1,4]=0
_[2,1]=0
_[2,2]=0
_[2,3]=1/2048*x(1)^4+5/4096*x(1)^3*x(7)+5/4096*x(1)^2*x(7)^2+5/4096*x(1)*x(7)^3+3/4096*x(7)^4
_[2,4]=1/512*x(1)^3+1/512*x(1)^2*x(7)+1/512*x(1)*x(7)^2+1/512*x(7)^3
_[3,1]=512*x(1)-512*x(7)
_[3,2]=0
_[3,3]=0
_[3,4]=0
_[4,1]=-128*x(1)^2-64*x(1)*x(7)+192*x(7)^2
_[4,2]=512*x(1)-512*x(7)
_[4,3]=0
_[4,4]=0

defects[2][3];


// Example 2: figure-eight know and d=4 -----------------------------------------------------------------

option(noredefine);option(noloadLib);option(redSB);//option(prot);
LIB "blow.lib";
LIB "linkhom.lib";
LIB "mfweb.lib";
ring rr=0,(x(1..9)),dp;
printlevel = 1;

int N = 3;
list linkData = linkLibrary("figure-eight");
list states = powervec(4);
list defects;

// This takes 2 or three hours on my laptop:
for( int cutpos=1; cutpos<=8; cutpos++ )
{    
    print(""); print("Cutting edge " + string(cutpos) + ":"); print("");
    defects[cutpos] = list();
    for( int i=1; i<=size(states); i++ )
    {
        list L = defectTangleFromLink(linkData, states[i], N, cutpos);
        list web = L[1];
        list compStrat = L[2];
        defects[cutpos][i] = webCompile(web, compStrat)[1];
        kill L,web,compStrat;
    }
}

for( int cutpos=1; cutpos<=8; cutpos++ )
{    
    for( int i=1; i<=size(states); i++ )
    {
        print("The defect we get form state " + string(i) + " has size " + string( ncols(defects[cutpos][i]) ) + " if we cut the edge number " + string(cutpos) + ".");
    }
    print("");
}

// We seem to get the same result independent of where we cut, for example: 
The defect we get form state 1 has size 18 if we cut the edge number 1.
The defect we get form state 2 has size 12 if we cut the edge number 1.
The defect we get form state 3 has size 12 if we cut the edge number 1.
The defect we get form state 4 has size 24 if we cut the edge number 1.
The defect we get form state 5 has size 12 if we cut the edge number 1.
The defect we get form state 6 has size 8 if we cut the edge number 1.
The defect we get form state 7 has size 8 if we cut the edge number 1.
The defect we get form state 8 has size 16 if we cut the edge number 1.
The defect we get form state 9 has size 12 if we cut the edge number 1.
The defect we get form state 10 has size 8 if we cut the edge number 1.
The defect we get form state 11 has size 8 if we cut the edge number 1.
The defect we get form state 12 has size 16 if we cut the edge number 1.
The defect we get form state 13 has size 24 if we cut the edge number 1.
The defect we get form state 14 has size 16 if we cut the edge number 1.
The defect we get form state 15 has size 16 if we cut the edge number 1.
The defect we get form state 16 has size 16 if we cut the edge number 1.

// Compare this with:
> states;
[1]:
   0,0,0,0
[2]:
   1,0,0,0
[3]:
   0,1,0,0
[4]:
   1,1,0,0
[5]:
   0,0,1,0
[6]:
   1,0,1,0
[7]:
   0,1,1,0
[8]:
   1,1,1,0
[9]:
   0,0,0,1
[10]:
   1,0,0,1
[11]:
   0,1,0,1
[12]:
   1,1,0,1
[13]:
   0,0,1,1
[14]:
   1,0,1,1
[15]:
   0,1,1,1
[16]:
   1,1,1,1


// These are among the smallest MFs and at least not obviously tensor products 
// or direct sums (or are they?):
> print(defects[1][7]);
0,     0,     0,     0,     0,     0,     _[1,7],_[1,8],
0,     0,     0,     0,     0,     _[2,6],0,     0,     
0,     0,     0,     0,     0,     _[3,6],_[3,7],_[3,8],
0,     0,     0,     0,     _[4,5],_[4,6],_[4,7],_[4,8],
_[5,1],_[5,2],0,     _[5,4],0,     0,     0,     0,     
0,     _[6,2],0,     0,     0,     0,     0,     0,     
_[7,1],_[7,2],_[7,3],0,     0,     0,     0,     0,     
_[8,1],_[8,2],_[8,3],0,     0,     0,     0,     0    


> defects[1][7];
_[1,1]=0
_[1,2]=0
_[1,3]=0
_[1,4]=0
_[1,5]=0
_[1,6]=0
_[1,7]=512*x(1)-512*x(9)
_[1,8]=32*x(1)-32*x(9)
_[2,1]=0
_[2,2]=0
_[2,3]=0
_[2,4]=0
_[2,5]=0
_[2,6]=1/64*x(1)-1/64*x(9)
_[2,7]=0
_[2,8]=0
_[3,1]=0
_[3,2]=0
_[3,3]=0
_[3,4]=0
_[3,5]=0
_[3,6]=-69/256*x(1)^2+105/256*x(1)*x(9)-9/64*x(9)^2
_[3,7]=384*x(1)-384*x(9)
_[3,8]=288*x(1)-288*x(9)
_[4,1]=0
_[4,2]=0
_[4,3]=0
_[4,4]=0
_[4,5]=384*x(1)-384*x(9)
_[4,6]=315/512*x(1)^3-87/64*x(1)^2*x(9)+1143/512*x(1)*x(9)^2-381/256*x(9)^3
_[4,7]=-33216*x(1)^2+110976*x(1)*x(9)-77760*x(9)^2
_[4,8]=-2076*x(1)^2+6936*x(1)*x(9)-4860*x(9)^2
_[5,1]=173/1024*x(1)^4-29/128*x(1)^3*x(9)-29/128*x(1)^2*x(9)^2-29/128*x(1)*x(9)^3-405/1024*x(9)^4
_[5,2]=-105/1024*x(1)^5+11/512*x(1)^4*x(9)-29/128*x(1)^3*x(9)^2-29/128*x(1)^2*x(9)^3-127/1024*x(1)*x(9)^4-127/512*x(9)^5
_[5,3]=0
_[5,4]=1/384*x(1)^3+1/384*x(1)^2*x(9)+1/384*x(1)*x(9)^2+1/384*x(9)^3
_[5,5]=0
_[5,6]=0
_[5,7]=0
_[5,8]=0
_[6,1]=0
_[6,2]=64*x(1)^3+64*x(1)^2*x(9)+64*x(1)*x(9)^2+64*x(9)^3
_[6,3]=0
_[6,4]=0
_[6,5]=0
_[6,6]=0
_[6,7]=0
_[6,8]=0
_[7,1]=3/1408*x(1)^3+3/1408*x(1)^2*x(9)+3/1408*x(1)*x(9)^2+3/1408*x(9)^3
_[7,2]=-23/5632*x(1)^4-1/512*x(1)^3*x(9)-1/512*x(1)^2*x(9)^2-1/512*x(1)*x(9)^3+3/1408*x(9)^4
_[7,3]=-1/4224*x(1)^3-1/4224*x(1)^2*x(9)-1/4224*x(1)*x(9)^2-1/4224*x(9)^3
_[7,4]=0
_[7,5]=0
_[7,6]=0
_[7,7]=0
_[7,8]=0
_[8,1]=-1/352*x(1)^3-1/352*x(1)^2*x(9)-1/352*x(1)*x(9)^2-1/352*x(9)^3
_[8,2]=23/352*x(1)^4+1/32*x(1)^3*x(9)+1/32*x(1)^2*x(9)^2+1/32*x(1)*x(9)^3-3/88*x(9)^4
_[8,3]=1/264*x(1)^3+1/264*x(1)^2*x(9)+1/264*x(1)*x(9)^2+1/264*x(9)^3
_[8,4]=0
_[8,5]=0
_[8,6]=0
_[8,7]=0
_[8,8]=0

defects[1][11];

// EXAMPLE 2 - Figure eight chern character

option(noredefine);option(noloadLib);option(redSB);
LIB "blow.lib";
LIB "linkhom.lib";
LIB "mfweb.lib";
ring rr=0,(x(1..9)),dp;
printlevel = 1;

int N = 3;
list linkData = linkLibrary("figure-eight");
intvec state = 1:4;
list L = defectTangleFromLink(linkData, state, N, 1);
list web = L[1];
list compStrat = L[2];
matrix D = webCompile(web, compStrat)[1];

ring ss=0,(x(1),x(9)),dp;
matrix D = imap(rr,D);
chernChar(D);
print(chernChar(mfIdentityDefect(x(1)^(N+1),x(9)^(N+1),x(1),x(9))));
// Result is that chernChar(D) = 6 * chernChar(Id).

// EXAMPLE 3 - Cinquefoil

option(noredefine);option(noloadLib);option(redSB);
LIB "blow.lib";
LIB "linkhom.lib";
LIB "mfweb.lib";
ring rr=0,(x(1..11)),dp;
printlevel = 1;

int N = 3;
list linkData = linkLibrary("5_1");
intvec state = 1:5;
list L = defectTangleFromLink(linkData, state, N, 1);
list web = L[1];
list compStrat = L[2];
matrix D = webCompile(web, compStrat)[1];

ring ss=0,(x(1),x(11)),dp;
matrix D = imap(rr,D);
chernChar(D);
print(chernChar(mfIdentityDefect(x(1)^(N+1),x(11)^(N+1),x(1),x(11))));
// Result is that chernChar(D) = -32 * chernChar(Id).