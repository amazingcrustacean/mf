option(noredefine);option(noloadLib);option(redSB);
LIB "blow.lib";
LIB "mfweb.lib";
LIB "fusion-temp.lib";
int nx=1;
int ny=2;
ring RRRR=(0,r),(x(1..nx),y(1..ny)),dp;
int d = 6;
minpoly = rootofUnity(d);
poly minpolyblow = x(1)^2 - x(1) + 1;   // This needs to be adjusted by hand when d is changed.
printlevel=1;

//    --- y(1) ---> defect1 = P_{a} ---- x(1) ----> defect2 = P_{b}--- y(2) --->

int a,b=1,2;
matrix defect1[2][2] = 0,x(1) - r^a * y(1),(x(1)^d - y(1)^d)/(x(1) - r^a * y(1)),0;
matrix defect2[2][2] = 0,y(2) - r^b * x(1),(y(2)^d - x(1)^d)/(y(2) - r^b * x(1)),0;

poly W = x(1)^d;
ideal J = jacob(W);

list e1 = list(0,1,list(y(1)),y(1)^d);
list e2 = list(1,2,list(x(1)),x(1)^d);
list e3 = list(2,0,list(y(2)),y(2)^d);
list web = list(3, list(e1,e2,e3), list(defect1,defect2));

list compStrat = list(1,2), list(x(1));
list L = webCompilePair(web, compStrat);
def fusion = L[1]; // the final answer for the fusion of this subweb

// F is the map defect1 x defect2 x J --> fusion.
matrix F = L[2][1][1];

// theta is the map defect1 x defect2 --> defect1 x defect2
matrix theta = thetaMap( defect1, defect2, J );

// Neither theta nor F are Z2-homogeneous. (The signs in the definition of thetaMap are still wrong,
// but why is F not homogeneous?):
print(F);
print(theta);

// At least F and theta have the correct sizes to be multiplied:
matrix M = F * theta;
print(M);

// In general, if there is more than one intermediate variable to be integrated out, 
// we should concatenate a sequence of maps
//
//     Y x X --t1--> Y x X x J1 --F1--> Z1 --t2--> Z1 x J2 --F2--> ...
//
// where the Fi are the F-maps (as part of the splittings (Zi,Fi,Gi)) returned by 
// webCompilePair (resp. mfPushforwardInductive), Ji are the ideals generated by xi^Ni 
// (for the appropriate integers Ni that we compute). 
// But what is ti for i>=2? Since Zi will usually not be of the form A x B for two MFs A,B, 
// ti will not be a map like theta.
