/////////////////////////////////////////////////////////////////////////////
// Examples of moduli spaces of MFs

//////////////////////////////////////////////////////////////////////////////////////
// Moduli of self-defects of x^2 - case of rank 1, total degree <= 1
//////////////////////////////////////////////////////////////////////////////////////

option(noredefine);option(noloadLib); //option(prot);
LIB "blow.lib";
LIB "moduli.lib";
ring rr=0,(x,y),dp;
printlevel=1;
poly W = y^2 - x^2;

// Find the moduli space of factorisations of W which are
// rank 1 (i.e. 2x2 supermatrices) and have entries which
// are polynomials in x,y of total degree <= 1, that is,
// a + bx + cy for some a,b,c.

def nR = moduliOfPotential(W,1,1);
setring(nR);
ideal I = groebner(moduli_eqns);

// Note here that the middle indices are always (1)(1) because our
// matrices are rank 1. Let us write f(a)(b) for f(a)(1)(1)(b).
// The b's are indices into the following set of monomials

displayIndices(1);
// 1,y,x = [0,0],[0,1],[1,0]

// If we write the upper right block as a + by + cx and
// the lower left block as a' + b'y + c'x then

//I[1]=f(2)(1)(1)(1) = a'
//I[2]=f(1)(1)(1)(1) = a
//I[3]=f(1)(1)(1)(3)*f(2)(1)(1)(3)+1 = cc'+1
//I[4]=f(2)(1)(1)(2)^2-f(2)(1)(1)(3)^2 = (b')^2-(c')^2
//I[5]=f(1)(1)(1)(3)*f(2)(1)(1)(2)+f(1)(1)(1)(2)*f(2)(1)(1)(3) = cb'+bc'
//I[6]=f(1)(1)(1)(2)*f(2)(1)(1)(2)-1 = bb'-1
//I[7]=f(1)(1)(1)(2)^2-f(1)(1)(1)(3)^2 = b^2-c^2
//I[8]=f(1)(1)(1)(2)*f(2)(1)(1)(3)^2-f(2)(1)(1)(2) = b(c')^2-b'

list P = primdecSY(I);

// P is a list containing the primary decomposition of I,
// where P[i][1] is the primary component and P[i][2] the associated
// prime. In our case we see that P[i][1] == P[i][2] for every i,
// that is, I is an intersection of prime ideals. Or what is the same,
// the locus cut out by I is a union of two irreducible components. They
// are given by the prime ideals:

P[1][1];

//_[1]=f(2)(1)(1)(2)+f(2)(1)(1)(3) = b' + c'
//_[2]=f(2)(1)(1)(1) = a'
//_[3]=f(1)(1)(1)(2)-f(1)(1)(1)(3) = b - c
//_[4]=f(1)(1)(1)(1) = a
//_[5]=f(1)(1)(1)(3)*f(2)(1)(1)(3)+1 = cc' + 1

// That is, this component is the space of all MFs where a = a' = 0
// and b = c, b' = -c' and cc' = -1. This is one-dimensional: it is a hyperbola.
// Note that each point [X] determines the same MF X up to isomorphism, they
// are all isomorphic to the MF (y+x, y-x) which is c = 1, c' = -1. So the
// Chern character is constant with value 2 on this component

P[2][1];

//_[1]=f(2)(1)(1)(2)-f(2)(1)(1)(3) = b' - c'
//_[2]=f(2)(1)(1)(1) = a'
//_[3]=f(1)(1)(1)(2)+f(1)(1)(1)(3) = b + c
//_[4]=f(1)(1)(1)(1) = a
//_[5]=f(1)(1)(1)(3)*f(2)(1)(1)(3)+1 = cc' + 1

// The same but with b' = c' and b = -c, again one-dimensional.
// These MFs are all isomorphic to (y-x,y+x), so the Chern character is constant
// with value -2 on this component

// We see from these calculations that the irreducible subschemes P[1][1] and P[2][1]
// are disjoint, and collapse to {(y+x,y-x)} and {(y-x,y+x)} up to isomorphism resp.

//////////////////////////////////////////////////////////////////////////////////////
// Moduli of self-defects of x^3 - case of rank 1, total degree <= 2
//////////////////////////////////////////////////////////////////////////////////////

option(noredefine);option(noloadLib); //option(prot);
LIB "blow.lib";
LIB "moduli.lib";
ring rr=0,(x,y),dp;
printlevel=1;
poly W = y^3 - x^3;

// Find the moduli space of factorisations of W which are
// rank 1 (i.e. 2x2 supermatrices) and have entries which
// are polynomials in x,y of total degree <= 2

def nR = moduliOfPotential(W,1,2);
setring(nR);
ideal I = groebner(moduli_eqns);

// Note here that the middle indices are always (1)(1) because our
// matrices are rank 1. Let us write f(a)(b) for f(a)(1)(1)(b).
// The b's are indices into the set of monomials
// 1,y,x,y2,xy,x2 i.e. [0,0],[0,1],[1,0],[0,2],[1,1],[2,0]

list P = primdecSY(I);

// Again all four components are prime and one-dimensional

int i;
for(i=1; i<=size(P); i++)
{
	dim(groebner(P[i][1]));
}

//////////////////////////////////////////////////////////////////////////////////////
// Universal MF of y^2 - x^2 case of rank 1, total degree <= 1
//////////////////////////////////////////////////////////////////////////////////////

option(noredefine);option(noloadLib); //option(prot);
LIB "blow.lib";
LIB "moduli.lib";
ring rr=0,(x,y),dp;
printlevel=1;
poly W = y2 - x2;

def uR = universalMF(W,1,1);
setring(uR);

U; // The universal MF of W of rank 1 and total degree <= 1

// U[1,1]=0
// U[1,2]=x*f(1)(1)(1)(3)+y*f(1)(1)(1)(2)+f(1)(1)(1)(1)
// U[2,1]=x*f(2)(1)(1)(3)+y*f(2)(1)(1)(2)+f(2)(1)(1)(1)
// U[2,2]=0

// U is not a MF of W on the nose, but only up to moduli_eqns

ideal I = groebner(moduli_eqns);
reduce((U*U)[1,1],I) == y2 - x2;
reduce((U*U)[2,2],I) == y2 - x2;

// We can compute e.g. the chern Char of U
poly ch = supertrace(diff(U,x) * diff(U,y));
reduce(ch,I);

// -2*f(1)(1)(1)(2)*f(2)(1)(1)(3) = -2bc' in the notation used earlier
// We know that Spec(nR/I) is a disjoint union of two components: on one
// bc' = 1 and on the other bc' = -1.

//////////////////////////////////////////////////////////////////////////////////////
// Universal MF of y^3 - x^3 case of rank 1, total degree <= 2
//////////////////////////////////////////////////////////////////////////////////////

option(noredefine);option(noloadLib); //option(prot);
LIB "blow.lib";
LIB "moduli.lib";
ring rr=0,(x,y),dp;
printlevel=1;
poly W = y^3 - x^3;

def uR = universalMF(W,1,2);
setring(uR);
ideal I = groebner(moduli_eqns);
poly ch = supertrace(diff(U,x) * diff(U,y));
poly rch = reduce(ch,I);

// Now see the values this rch takes on the four components identified earlier
list P = primdecSY(I);

int i;
for(i=1;i<=4;i++){ ideal p(i) = groebner(P[i][2]); }

for(i=1;i<=4;i++){ dim(p(i)); }

// 3
// 3
// 3
// 3

for(i=1;i<=4;i++){ reduce(ch,p(i)); }

//-3*x-3*y
//-3*x*f(1)(1)(1)(2)*f(2)(1)(1)(6)+3*y*f(1)(1)(1)(2)*f(2)(1)(1)(6)+3*y
//3*x+3*y
//-3*x*f(1)(1)(1)(5)*f(2)(1)(1)(3)+3*y*f(1)(1)(1)(5)*f(2)(1)(1)(3)-3*y


// So on the irreducible subcomponent of the moduli space cut out by p(2), p(4)
// the Chern character does vary. Thus the points do not all represent isomorphic
// matrix factorisations.
//
// By inspection we can see that p(1), p(3) parametrise the suspension of one
// another (see how switching f(1) to f(2) relates them). Writing 
// a = f(1)(1)(1)(2) and b = f(2)(1)(1)(6) the MF parametrised by p(1) is
// the pair ( a( y - x ), b( y2 + xy + x2 ) ) with ab = 1. Thus all points are
// isomorphic to (y-x, y2+xy+x2) and p(3) is the shift.
//
// The relation between p(2) and p(4) must be more subtle: we can see from their
// Chern characters that one is not just a shift of the other.
//
// Observe that GL(2) acts on the moduli space by pullback along change of
// variable isomorphisms of Q[x,y].

//////////////////////////////////////////////////////////////////////////////////////
// Moduli of self-defects of x^3 - case of rank 2, total degree <= 2
//////////////////////////////////////////////////////////////////////////////////////

option(noredefine);option(noloadLib); option(prot);
LIB "blow.lib";
LIB "moduli.lib";
ring rr=0,(x,y),dp;
printlevel=1;
poly W = y^3 - x^3;

int r = 2;
int k = 2;

def nR = moduliOfPotential(W,r,k);
setring(nR);

// Zero out all constant terms
int z,i,j,a;
for(z=1;z<=2;z++)
{
for(i=1;i<=r;i++)
{
for(j=1;j<=r;j++)
{
// Zero out constant terms
moduli_eqns = moduli_eqns + f(z)(i)(j)(1);
for(a=2;a<=6;a++)
{
// All other coeffs are either zero, 1 or -1
poly f = f(z)(i)(j)(a);
moduli_eqns = moduli_eqns + f*(1-f)*(1+f);
}
}
}
}

ideal I = groebner(moduli_eqns);

// still TOO HARD! Zero out more terms

//////////////////////////////////////////////////////////////////////////////////////
// Universal MF of y^4 - x^4 case of rank 1, total degree <= 3
//////////////////////////////////////////////////////////////////////////////////////

option(noredefine);option(noloadLib); option(prot);
LIB "blow.lib";
LIB "moduli.lib";
ring rr=0,(x,y),dp;
printlevel=1;
poly W = y^4 - x^4;

int r = 1;
int k = 3;

def uR = universalMF(W,r,k);
setring(uR);
ideal I = groebner(moduli_eqns); // takes a few minutes

// I has 230 equations in it

list P = primdecSY(I);

// This has 10 components, not all prime

int i;
ideal p(1..10);

for(i=1;i<=10;i++)
{
p(i) = groebner(P[i][2]); // take the prime radicals
}

for(i=1;i<=10;i++)
{
dim(p(i));
}

// The dimensions are all 3

poly ch = supertrace(diff(U,x) * diff(U,y));
poly rch = reduce(ch,I);

// Now see the values this rch takes on the 10 components identified earlier
for(i=1;i<=10;i++)
{
reduce(rch,p(i));
}

// -4*x^2*f(1)(1)(1)(2)*f(2)(1)(1)(10)+4*x*y+4*y^2*f(1)(1)(1)(2)*f(2)(1)(1)(10)
// -4*x^2-4*x*y-4*y^2
// 4*x^2-4*x*y+4*y^2
// -4*x^2*f(1)(1)(1)(9)*f(2)(1)(1)(3)-4*x*y+4*y^2*f(1)(1)(1)(9)*f(2)(1)(1)(3)
// 4*x^2+4*x*y+4*y^2
// -8*x*y
// 8*x*y
// -4*x^2*f(1)(1)(1)(5)*f(2)(1)(1)(6)+4*y^2*f(1)(1)(1)(5)*f(2)(1)(1)(6)+8*y^2
// -4*x^2*f(1)(1)(1)(5)*f(2)(1)(1)(6)+4*y^2*f(1)(1)(1)(5)*f(2)(1)(1)(6)-8*y^2
// -4*x^2+4*x*y-4*y^2

// Here we see several families. In each case there is a single continuous
// parameter (e.g. f(1)(1)(1)(2)*f(2)(1)(1)(10)) so modulo isomorphism we
// expect a 1-dimensional moduli space


//////////////////////////////////////////////////////////////////////////////////////
// Moduli of self-defects of x^3 - case of rank 2, total degree <= 2
// This time only parametrising determinant MFs
//////////////////////////////////////////////////////////////////////////////////////

option(noredefine);option(noloadLib); option(prot);
LIB "blow.lib";
LIB "moduli.lib";
ring rr=0,(x,y),dp;
printlevel=1;
poly W = y^3 - x^3;

int r = 2;
int k = 2;

def uR = universalMFDet(W,r,k);
setring(uR);

poly ch = supertrace(diff(U,x) * diff(U,y));
ch;
// 0 - well that's a bummer

// The full moduli space takes forever to compute so let us
// stick to the subscheme of MFs where all constant terms
// and all xy terms are zero
int i,j;
for(i=1;i<=r;i++)
{
for(j=1;j<=r;j++)
{
moduli_eqns = moduli_eqns + f(i)(j)(1);
moduli_eqns = moduli_eqns + f(i)(j)(5);
}
}

ideal I = groebner(moduli_eqns);

poly ch = supertrace(diff(U,x) * diff(U,y));
poly rch = reduce(ch,I);

list P = primdecSY(I); // takes about a minute

// There are two components
ideal p(1) = groebner(P[1][2]);
ideal p(2) = groebner(P[2][2]);

