////////////////////////////////////////////////
// Example of defect fusion using webCompilePair
////////////////////////////////////////////////

// For the fusion of defects with boundary conditions, or defect-defect fusion
// (i.e. convolution of matrix factorisation "kernels") we use webCompilePair,
// which takes as input an oriented graph (called a "web") whose edges are
// decorated with potentials (i.e. the equation of an isolated singularity) and
// whose vertices are decorated with matrix factorisations. The output is a finite
// rank matrix factorisation homotopy equivalent to the "total factorisation" of
// the web. All these terms are defined more precisely in the preamble of mfweb.lib
// and the paper arXiv: 1108.1081, but let us proceed to the example.
//
// The web has two vertices (marked with X,Y) and two edges (marked x(1)^3, y(1)^5)
//
//    X ---- x(1)^3 ----> Y ---- y(1)^5 ---->
//
// Here the second edge (labelled with y(1)^5) goes to the boundary.
//
// For this to be a valid web, Y needs to be a matrix factorisation of y(1)^5 - x(1)^3
// (i.e. outgoing potential minus incoming potential) while X needs to be a matrix
// factorisation of x(1)^3. The total factorisation is Y \otimes X, as a matrix
// factorisation of y(1)^5 over the variables y(1). This is infinite rank but is
// homotopy equivalent to a finite rank matrix factorisation.
//
// This finite rank matrix factorisation is, by definition, the image of
// X \in hmf(x(1)^3) under the functor hmf(x(1)^3) --> hmf(y(1)^5) induced
// by the kernel Y. Let us compute this finite rank guy now. Then we will move
// onto more complicated examples.

option(noredefine);option(noloadLib);option(redSB);
LIB "linkhom.lib";
ring rr=0,(x(1),y(1)),dp;

// We encode the web given above as a pair of edges, and a pair of vertices.
// Format for an edge is source, target, variable, potential. Start indexing
// your vertices at 1, since 0 stands for the boundary.
list e1 = list(1,2,list(x(1)),x(1)^3);
list e2 = list(2,0,list(y(1)),y(1)^5);
list edgeList = list(e1,e2);

// Now define the mfs X,Y to be placed at each vertex 
matrix X[2][2] = 0, x(1)^2, x(1), 0;

matrix Y0[2][2] = -x(1), y(1), -y(1)^4, x(1)^2;
matrix Y1[2][2] = x(1)^2, -y(1), y(1)^4, -x(1);
matrix z[2][2];
matrix Y = blockmat(z,Y1,Y0,z);

list mfs = X, Y;

// Define the web
list web = list(2, edgeList, mfs); // 2 for the number of vertices
webVerify(web);

// The compilation of this web is the fusion of Y with X. 
list compStrat = defaultCompStratForWeb(web);
list L = webCompilePair(web, compStrat);
print(L[1]);

// The answer is a direct sum of two copies of the Koszul factorisation (y(1),y(1)^4)

////////////////////////////////////////////////
// Example of defect-defect fusion
////////////////////////////////////////////////

// TODO

////////////////////////////////////////////////////
// Example of defect-defect fusion using parameters
////////////////////////////////////////////////////

// TODO