/////////////////////////////////////////////////////////////////////////////
// Examples of alternative fusion

////////// E1 ////////////

option(noredefine);option(noloadLib);option(redSB);
LIB "blow.lib";
ring R = 0,(x(1)),dp;

// Consider the complex R -- x(1)^a --> R -- 0 --> R
int a = 5;
intvec v = a;
matrix A[2][2] = 0, 0, x(1)^a, 0;
matrix l[2][2] = 0, 1, 0, 0;

// So that
l * A + A * l == x(1)^a * unitmat(2);

matrix Adef = madefl(A, v);
matrix ldef = madefl(l, v);
matrix at = diff(Adef, x(1));

matrix E = mfSuspendMorph( ldef * at );

// This is an idempotent splitting to give an a dimensional vector space in degree one
E * E == E;


/////////// Hopf link state ///////

option(noredefine);option(noloadLib);option(redSB);
LIB "linkhom.lib";
list linkData = linkLibrary("hopf");
int numVar = linkNumberOfVariables(linkData);
ring rr=0,(x(1..numVar)),dp;
printlevel = 1;
int N = 2;

intvec vertexParity = linkData[1];
list edgeList = linkData[2];
int webSiz = size(vertexParity);
list stateDiagrams = powervec(webSiz);

// Choose a state diagram
intvec v = stateDiagrams[1];

dbprint(printlevel, "");
dbprint(printlevel, "Looking at state [" + string(v) + "]");
    
// Build a web suitable for calling webCompile:
list web = webFromLink(linkData, v, N);
matrix mf(1) = web[3][1];
matrix mf(2) = web[3][2];

matrix A = MFtensor( mf(1), mf(2) );
poly W = (mf(1) * mf(1))[1,1];

// Get homotopies for the action of x(1)^{N+1} and x(2)^{N+1}

matrix H(1)[nrows(mf(1))][ncols(mf(1))];
matrix H(2)[nrows(mf(1))][ncols(mf(1))];
matrix H(3)[nrows(mf(1))][ncols(mf(1))];
matrix H(4)[nrows(mf(1))][ncols(mf(1))];

number c = 1/number(N+1);

int k;
for(k=1; k<=4; k++)
{
    H(k) = ZZtensor( c * diff(mf(1),x(k)), unitmat(ncols(mf(2))) );
}

H(3) = - H(3);
H(4) = - H(4);

matrix H = H(1) * H(2) * H(3) * H(4);

intvec v = N, N, N, N;

matrix h = madefl(H, v);
matrix a = madefl(A, v);
matrix e = h * diff(a,x(1)) * diff(a,x(2)) * diff(a,x(3)) * diff(a, x(4));

for(k=1;k<=4;k++)
{
    a = subst(a,x(k),0);
    e = subst(e,x(k),0);
}

matrix epstrict = mfStrictifyIdempotent(a, e);

list l = mfSplitIdempotent( a, epstrict );