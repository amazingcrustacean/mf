version="0.1";
category="Miscellaneous";
// summary description of the library
info="
LIBRARY:   mfweb.lib  Compilation of defect webs
AUTHOR:    Nils Carqueville, Daniel Murfet
KEYWORDS:  matrix factorization

PROCEDURES:
";

LIB "linalg.lib";
LIB "matrix.lib";
LIB "ring.lib";
LIB "blow.lib";
LIB "linkhom.lib";

////////////////////////////////////////////////////////////////////
// USAGE GUIDE
//
// In principle everything in here should work for an arbitrary ring. Maybe.
//
// A web is an oriented graph where edges are allowed to begin or end, but not
// both, on some unspecified "boundary". All edges are labelled with a single
// ring variable and an integer, and every vertex is assigned a matrix factorisation
// of the sum of all the "outgoing" variables (to their respective powers) minus
// the sum of all the incoming variables (again to their respective powers).

/////////////////////////////////////////////////
// DATA TYPE: vertex
//
// A vertex is a tuple (L1,P1,L2,P2) of four lists, where each Li
// is a list of ring variables (possibly empty). The first list
// L1 denotes the incoming variables and the second list the outgoing variables.
// The Pi are lists of integers, with P1 giving the exponents on the L1 variables
// and P2 giving the exponents on the L2 variables.
//
// NOTE: All exponents should be > 1 otherwise the results are trivial.
//
// WARNING: We do not allow isolated vertices, with no incoming or outgoing vertices.
// The ordering of the variables in L1 and L2 may matter.
//
// A ring variable is allowed to appear in both L1 and L2 (i.e. a loop) but then
// of course it should be assigned the same exponent in P1 and P2.

/////////////////////////////////////////////////
// DATA TYPE: web
//
// A web is represented by a tuple (L1,L2[,L3]) of two or three lists, where
//
//  1. L1 is a list of vertices, say of size v.
//  2. L2 is a list of matrices, also of size v, with each matrix
//  being the differential of a matrix factorisation defined in the 
//  set of variables associated with the corresponding vertex in L1,
//  factorising the potential explained in the Usage Guide.
//  3. L3 is an optional list of intvecs, also of size v, making each
//  of the MFs into a graded MF.
//
// NOTE: This is different to the format for webs explained in mfCompileWeb of linkhom.lib
//
// We say that a ring variable "occurs" in a web if it occurs in some vertex
// of the web. Such a variable is "external" if does not occur as a
// incoming and outgoing variable in some vertex, and "internal" otherwise.
//
// The total potential of a web is the sum of the potentials associated with
// each vertex of the web.
//
// If a ring variable appears in two vertices of a web, it should be assigned
// the same exponent in each.
//
// NOTE: Distinct edges in the web MUST be assigned distinct variables!

/////////////////////////////////////////////////
// DATA TYPE: compilation strategy
//
// Compilation of a web means taking the tensor product over all MFs in the
// web and pushing forward to the ring with all internal variables in the web
// deleted. A compilation strategy represents one way of effecting this pushforward
// in practice.
//
// Precisely, a compilation strategy consists of a pair (L1,L2), where
// L1 is a permutation of the set {1,...,v} and L2 is a list
// containing each internal variable in the web precisely once. The idea is that L1 tells
// us the order in which to tensor the MFs in the web together (for example, if
// L1 were 3,1,2 we should first tensor the MF at vertex 3 with the one at vertex 1,
// and then tensor the result with the MF at vertex 2) and L2 tells us the ordering
// on the variables to use in the reduction/pushforward procedure.

/////////////////////////////////////////////////
// varLiesBetweenVertices
// 
// Return 1 if the variable u lies between these two vertices, 0 otherwise.

proc varLiesBetweenVertices(poly u, list v1, list v2)
{
    if( (checklist(v1[3],u) && checklist(v2[1],u)) || (checklist(v1[1],u) && checklist(v2[3],u)) )
    {
        return(1);
    }
    
    return(0);
}

/////////////////////////////////////////////////
// webVerify
//
// Verify that the given list satisfies (some of) the conditions to be a web.

proc webVerify(list web)
{
    int useGrading = (size(web) > 2 );
    list vertices = web[1];
    list mfs = web[2];
    if( useGrading ){ list mfsGrading = web[3]; }
    
    if( size(vertices) != size(mfs) )
    {
        print("[webVerify] There is size mismatch between vertices and MFs, failed.");
        return(0);
    }
    
    int i;
    for(i=1;i<=size(vertices);i++)
    {
        list v_in = vertices[i][1];
        list p_in = vertices[i][2];
        list v_out = vertices[i][3];
        list p_out = vertices[i][4];
        matrix A = mfs[i];
        if( useGrading ){ intvec Agr = mfsGrading[i]; }
        
        if( size(v_in) + size(v_out) == 0 )
        {
            print("[webVerify] There is an isolated vertex, failed.");
            return(0);
        }
        
        // Figure out the potential at this vertex
        poly W;
        int j;
        for(j=1;j<=size(v_in);j++)
        {
            W = W - v_in[j]^(p_in[j]);
        }
        
        for(j=1;j<=size(v_out);j++)
        {
            W = W + v_out[j]^(p_out[j]);
        }
        
        // Is A a MF of this potential?
        if( A * A != W * unitmat(ncols(A)) )
        {
            print("[webVerify] At vertex " + string(i) + " the MF does not factorise the local potential W=" + string(W) + ", failed.");
            return(0);
        }
        
        // Is A a graded MF?
        if( size(web) > 2 )
        {
            if( !isGradingValid(A, Agr) )
            {
                print("[webVerify] At vertex " + string(i) + " the grading is not valid, failed.");
                return(0);
            }
        }
    }
    
    return(1);
}

/////////////////////////////////////////////////
// webCompilePair
//
// The backbone of our compilation routines. We are given a
// web with only two vertices and a compilation strategy. Next we
// describe the output in the standard case, but be aware there is
// an important special case to be explained at the end.
//
// We first return a matrix factorisation in the set of external variables
// of the total potential of the given web. Let X denote the tensor product
// over all vertices of the associated MFs, defined in the ordering determined
// by our compilation strategy. Let pX denote the pushforward/restriction of
// scalars to the ring with all internal variables in the web deleted. Our
// first return value is the differential of a MF Y homotopy equivalent to pX.
//
// The second return value is the grading vector for Y, if we are using gradings.
//
// The third (or second, if there is no grading) return value is a list
// R = (F1,G1),(F1,G2),... whose length is equal to the number of internal variables
// in the web. These are the maps returned by mfPushforwardInductive applied to
// the set of internal variables ordered according to our compilation strategy.
//
// In more detail: let p1X denote the pushforward of X just to the ring without the
// "first" internal variable, where "first" means first in the compilation strategy.
// This is a direct summand of Xblow[1], and (F1,G1) is a pair splitting, in the
// homotopy category of finite rank MFs, the corresponding idempotent. Say the
// splitting is Y1. Then F1: Xblow[1] -> Y1 and G1: Y1 -> Xblow[1] with F1 * G1 = 1
// and G1 * Y1 the idempotent corresponding to p1X.
//
// Next, we push forward Y1 to the ring without the first and second internal variables,
// and the same yoga produces maps (F2,G2) splitting an idempotent on Y1blow[1], etc.
//
// This list R is referred to as a "splitting record".
//
// NOTE: Special case
//
// If the total potential of the web is zero, and if in the last step of the compilation
// process we end up with non-square matrices (may not happen) then it is not safe to
// return the differential on Y (it will not be square) so our return list looks like
//
// "nonsquare", [r1,r2,] R
//
// where r1,r2 are grading vectors on the even and odd parts of Y resp. (if we are
// using the grading) and R is as described above, but where the last (F,G) pair is
// a tuple f0,f1,g0,g1 with f0,g0 splitting the even part of the very last idempotent
// and similarly for f1,g1.


proc webCompilePair(list web, list compStrat)
{
    int useSanityChecks = blowFlags("sanity_checks");
    int useGrading = (size(web) > 2);
    
    if( useSanityChecks )
    {
        if( !webVerify(web) )
        {
            print("[webCompilePair] Given web is not valid, exiting.");
            return();
        }
        
        if( size(web[1]) != 2 )
        {
            print("[webCompilePair] We only compile pairs. Duh. Exiting.");
            return();
        }
    }
    
    // Extract the content of the web
    list vertices = web[1];
    list mfs = web[2];
    if( useGrading ){ list mfGradings = web[3]; }
    
    // And the compilation strategy
    list vertexOrder = compStrat[1];
    list varOrder = compStrat[2];
    
    // Order the vertices according to the compilation strategy
    int i;
    for(i=1;i<=2;i++)
    {
        list vertex(i) = vertices[vertexOrder[i]];
        matrix mf(i) = mfs[vertexOrder[i]];
        if( useGrading ){ intvec mfgr(i) = mfGradings[vertexOrder[i]]; }
    }
    
    // Our task is to build up the input to mfPushforwardInductive and
    // then interpret its output.
    matrix A = MFtensor( mf(1), mf(2) );
    if( useGrading ){ intvec Agr = MFtensorGradings( mfgr(1), mfgr(2) ); }
    
    // Build up a list of the internal variables, ordered accoring to the
    // compilation strategy, a list of powers and a list of homotopies. The
    // powers we collect are the powers of the variables which act null-homotopically
    // on A, with associated homotopies stored in H.
    list intvars;
    list varPowers;
    list Hlist;
    for(i=1;i<=size(varOrder);i++)
    {
        poly u = varOrder[i];
        //dbprint(printlevel, "[webCompilePair] Integrating out internal variable " + string(u)); // debug
        
        // See if this variable is internal
        if( checklist(vertex(1)[1],u) && checklist(vertex(2)[3],u))
        {
            // Variable is internal, goes from vertex(2) to vertex(1)
            intvars = intvars + list(u);
             
            // Find out the exponent on this variable
            int j;
            int N;
            for(j=1;j<=size(vertex(1)[1]);j++)
            {
                if( vertex(1)[1][j] == u )
                {
                    N = vertex(1)[2][j];
                    break;
                }
            }
             
            // Note that mf(2) * mf(2) is a sum of powers of variables,
            // including u^N as a summand. Hence
            // 
            // diff(mf(2),u) * mf(2) + mf(2) * diff(mf(2),u) = N * u^(N-1).
            //
            // That is, to say, if we set h = 1/N * diff(mf(2),u) then
            // h * mf(2) + mf(2) * h = u^(N-1). Actually we set H[i] to be
            // the tensor product of this h with 1_{mf(1)}.
            
            varPowers = varPowers + list(N-1);
            number Nn = N;
            matrix H = 1/Nn * ZZtensor( unitmat(ncols(mf(1))), diff(mf(2),u) );
            
            // Check H is a homotopy
            if( useSanityChecks )
            {
                if( H * A + A * H != u^(N-1) * unitmat(ncols(A)) )
                {
                    print("[mfCompilePair] Homotopy does not work, exiting.");
                    return();
                }
             }
             
             Hlist = Hlist + list(H);
             kill H;
        }
         
        if( checklist(vertex(1)[3],u) && checklist(vertex(2)[1],u) )
        {
            // Variable is internal, goes from vertex(1) to vertex(2)
            intvars = intvars + list(u);
            
            // Find out the exponent on this variable
             int j;
             for(j=1;j<=size(vertex(1)[3]);j++)
             {
                 if( vertex(1)[3][j] == u )
                 {
                    N = vertex(1)[4][j];
                    break;
                 }
             }
             
            // Note that mf(1) * mf(1) is a sum of powers of variables,
            // including u^N as a summand. Hence
            // 
            // diff(mf(1),u) * mf(1) + mf(1) * diff(mf(1),u) = N * u^(N-1).
            //
            // That is, to say, if we set h = 1/N * diff(mf(1),u) then
            // h * mf(1) + mf(1) * h = u^(N-1). Actually we set H[i] to be
            // the tensor product of this h with 1_{mf(2)}.
            
             varPowers = varPowers + list(N-1);
             number Nn = N;
             matrix H = 1/Nn * ZZtensor( diff(mf(1),u), unitmat(ncols(mf(2))) );
             
             // Check H is a homotopy
             if( useSanityChecks )
             {
                if( H * A + A * H != u^(N-1) * unitmat(ncols(A)) )
                {
                    print("[mfCompilePair] Homotopy for " + string(u) + " does not work, exiting.");
                    return();
                }
             }
             
             Hlist = Hlist + list(H);
             kill H;
        }
    }
        
    // Now we feed all this to mfPushforwardInductive
    if( !useGrading )
    {
        list L = mfPushforwardInductive(A, intvars, varPowers, Hlist);
    }
    else
    {
        list L = mfPushforwardInductive(A, intvars, varPowers, Hlist, Agr);
    }
    kill A, intvars, varPowers, Hlist;
    
    return(L);
}

/////////////////////////////////////////////////
// webCompile
//
// Given a web and compilation strategy we crawl the web, fusing
// vertices in the order dictated by the strategy using mfCompilePair.
// Our first output is the differential on the compiled MF Y, h.e. to the pushforward
// of the tensor product of all the MFs in the web to the ring without any of the internal
// variables.
//
// If grading is in use, then the second return is the grading vector on this Y.
//
// The third (or second, if grading is not in use) return value is a list Q, which we
// refer to as the "splitting record". Suppose that we write X1, .., Xv for the MFs lying
// at the vertices in our web, ordered according to the compilation strategy. Let
// X1 # X2 denote the result of tensoring X1,X2 and replacing this by a finite rank MF
// homotopy equivalent to the pushforward which eliminates the variables lying between
// vertices 1,2. This reduction generates a splitting record R1 (as defined above) and the
// pair (X1 # X2, R1) is the first entry in the list Q (or (X1 # X2, gr, R1) if we are 
// in the graded setting, gr being the grading vector on X1 # X2).
//
// The second entry in Q is ((X1 # X2) # X3, R2) where R2 is the splitting record of the
// second fusion. All fusions being conducted according to the given compilation strategy.
// The last entry in Q is (Y,Ygr,R?), i.e. we repeat the differential, grading of Y but
// in addition there is the splitting record of the reduction which produced Y.
// TODO: Possibly avoid storing Y twice.
//
// NOTE: Special case
//
// If the total potential of the web is zero, and if in the last step of the compilation
// process we end up with non-square matrices (may not happen) then it is not safe to
// return the differential on Y (it will not be square) so our return list looks like
//
// "nonsquare", [r1,r2,]  Q
//
// where r1,r2 are grading vectors on the even and odd parts of Y resp. (if we are
// using the grading) and Q is the global splitting record. The last entry in Q is
// a tuple ("nonsquare",[r1,r2,],R) with the last entry of R a tuple (f0,f1,g0,g1,u,N)
// with f0,g0 splitting the even part of the very last idempotent and similarly for f1,g1.

proc webCompile(list web, list compStrat)
{
    int useSanityChecks = blowFlags("sanity_checks");
    int useGrading = (size(web) > 2);
    
    system("--ticks-per-sec",1000);
    int timeElapsed = timer;
    
    if( useSanityChecks )
    {
        if( !webVerify(web) )
        {
            print("[webCompile] Given web is not valid, exiting.");
            return();
        }
    }
    
    def RRR = basering;
    int count = 1;
    def nR(1) = basering;
    list splittingRecord;
    int numInternalVar = size(compStrat[2]);
    
    // Continue fusing until there are no internal variables left. Each time through the
    // loop we will have deleted some internal variables from our current ring and have
    // changed the web and strategy to reflect the fusion of two vertices in the old web.
    // Recall that compStrat[2] is an ordered list of the internal variables.
    while( numInternalVar > 0 )
    {
        // Our current ring is nR(count)
        dbprint(printlevel, "[webCompile] Entering round " + string(count) + " of compilation.");
        
        list vertices = web[1];
        list mfs = web[2];
        if( useGrading ){ list mfGradings = web[3]; }

        // And the compilation strategy
        list vertexOrder = compStrat[1];
        list varOrder = compStrat[2];

        // Construct a subweb and substrategy consisting of the first two vertices to be fused
        list adjacent_var; // All variables adjacent to these two vertices
        list adjacent_varStr;
        int i;
        for(i=1;i<=2;i++)
        {
            list vertex(i) = vertices[vertexOrder[i]];
            matrix mf(i) = mfs[vertexOrder[i]];
            if( useGrading ){ intvec mfgr(i) = mfGradings[vertexOrder[i]]; }
            
            // Populate the list of adjacent variables
            int j;
            for(j=1;j<=size(vertex(i)[1]);j++)
            {
                if( !checklist(adjacent_var, vertex(i)[1][j]) )
                {
                    adjacent_var = adjacent_var + list(vertex(i)[1][j]);
                    adjacent_varStr = adjacent_varStr + list(string(vertex(i)[1][j]));
                }
            }
            
            for(j=1;j<=size(vertex(i)[3]);j++)
            {
                if( !checklist(adjacent_var, vertex(i)[3][j]) )
                {
                    adjacent_var = adjacent_var + list(vertex(i)[3][j]);
                    adjacent_varStr = adjacent_varStr + list(string(vertex(i)[3][j]));
                }
            }
        }
        
        //print("Adjacent variables are "); // debug
        //print(adjacent_var); // debug
        
        list substrat_var;
        list substrat_varStr;
        
        // Find the variables lying between our two vertices
        for(i=1;i<=size(adjacent_var);i++)
        {
            poly u = adjacent_var[i];
            
            if( varLiesBetweenVertices(u,vertex(1),vertex(2)) )
            {
                substrat_var = substrat_var + list(u);
                substrat_varStr = substrat_varStr + list(string(u));
            }
        }
                
        // Define the subweb and strategy
        list subweb = list(list(vertex(1),vertex(2)), list(mf(1),mf(2)));
        if( useGrading ){ subweb = subweb + list(list(mfgr(1),mfgr(2))); }
        list substrat = list(list(1,2), substrat_var);
        
        // Change to the ring containing only those variables involved in this fusion
        // This is NOT nR(count+1), it is just a temp ring
        list rlist = ringlist(nR(count));

        list newringList;
        newringList[1] = rlist[1];
        newringList[2] = adjacent_varStr;
        newringList[3] = rlist[3];
        newringList[4] = rlist[4];

        // Fix the variable weighting
        intvec kk = (1..size(adjacent_varStr));
        for(i=1; i<=size(adjacent_varStr); i++)
        {
            kk[i] = 1;
        }
        newringList[3][1][2] = kk;
        kill kk;
        
        // Create our new ring
        def tempring = ring(newringList);
        kill rlist, newringList;
        
        ///////// BEGIN tempring //////////
        setring tempring;
        list subweb = imap(nR(count),subweb);
        list substrat = imap(nR(count),substrat);
            ////// IMPORTANT
            list l = webCompilePair(subweb, substrat);
            ////////////////
        kill subweb, substrat;
        setring nR(count);
        kill subweb, substrat;
        ///////// END tempring ///////////
        
        list l = imap(tempring, l);
        kill tempring;
        
        if( typeof(l[1]) == "string" )
        {
            // This is the case where webCompilePair produced non-square matrices. This
            // must be our last step, and l looks like
            //
            // "nonsquare", [r1,r2,] R
            //
            // where r1,r2 are grading vectors on the even and odd parts of Y resp. (if we are
            // using the grading) and R is the splitting record, but where the last (F,G) pair in R is
            // a tuple (f0,f1,g0,g1) with f0,g0 splitting the even part of the very last idempotent
            // and similarly for f1,g1.
            
            //dbprint(printlevel, "[webCompile] Hit nonsquare matrices, wrapping it up.");
            
            kill vertices, mfs, vertexOrder, varOrder, adjacent_var, adjacent_varStr;
            kill vertex(1), vertex(2), mf(1), mf(2), substrat_var, substrat_varStr;
            
            setring RRR;
            
            // The first time through nR(1) = RRR so there is no need for imap
            if( count > 1 )
            {
                list l = imap(nR(count),l);
            }
            
            kill nR(count);

            list retlist;
            retlist[1] = "nonsquare";
            if( useGrading ){ retlist = retlist + list(l[2],l[3]); }
            splittingRecord = splittingRecord + list(l);
            retlist = retlist + list(splittingRecord);
            kill l, splittingRecord;

            dbprint(printlevel, "[webCompile] total elapsed time " + string(timer-timeElapsed) + "ms.");
    
            return(retlist);
        }
        
        // The return from webCompilePair is (newvertex [,g], R) where newvertex is the
        // differential on a MF and g is a possible grading vector, R is the splitting record.
        // First we return to RRR and adjoin R to the global splitting record
        setring RRR;
        
            // The first time through nR(1) = RRR so there is no need for imap
            if( count > 1 )
            {
                list l = imap(nR(count),l);
            }
        
            splittingRecord = splittingRecord + list(l);
            
        setring nR(count);
        
        // Now do some engineering on our web. We need to replace the first two vertices
        // by their fusion, and rearrange variables and the compilation strategy accordingly
        
        // 1. Fused vertices
        list fusedWebVertices = vertices;

        // Go through and remove all the squeezed out internal edges from all the vertices
        // (these have been previously collected in substrat_var).
        // Whenever we see a variable going into or out of the second vertex (as dictated by
        // the compilation strategy) reroute it so that it goes into (or out of) the first vertex.
        
        for(i=1;i<=size(fusedWebVertices);i++)
        {
            list v = fusedWebVertices[i];
            
            // Look at incoming edges/variables
            int j;
            list temp1;
            list temp2;
            for(j=1;j<=size(v[1]);j++)
            {
                poly u = v[1][j];
                
                // If this variable is internal, delete it. Or, more
                // accurately, we only add it to the new list if it is
                // NOT internal
                if( !checklist(substrat_var,u) )
                {
                    temp1 = temp1 + list(v[1][j]);
                    temp2 = temp2 + list(v[2][j]);
                }
            }
            v[1] = temp1;
            v[2] = temp2;
            kill temp1,temp2;
            
            // Look out outgoing edges
            list temp3, temp4;
            for(j=1;j<=size(v[3]);j++)
            {
                poly u = v[3][j];
                
                // If this variable is internal, delete it
                if( !checklist(substrat_var,u) )
                {
                    temp3 = temp3 + list(v[3][j]);
                    temp4 = temp4 + list(v[4][j]);
                }
            }
            v[3] = temp3;
            v[4] = temp4;
            kill temp3,temp4;
            
            fusedWebVertices[i] = v;
            kill v;
        }
        
        // Now to the first vertex fusedWebVertices[vertexOrder[1]] we add edges corresponding
        // to all edges originating or terminating at the second vertex
        list v = fusedWebVertices[vertexOrder[1]];
        list w = fusedWebVertices[vertexOrder[2]];
        v[1] = v[1] + w[1];
        v[2] = v[2] + w[2];
        v[3] = v[3] + w[3];
        v[4] = v[4] + w[4];
        fusedWebVertices[vertexOrder[1]] = v;
        kill v,w;
      
        // Delete this second vertex
        fusedWebVertices = delete(fusedWebVertices,vertexOrder[2]);
        
        //print("After the first fusion the modified web has vertices:");
        //print(fusedWebVertices); // debug
        
        // 2. List of matrices
        list fusedWebMfs = mfs;
        fusedWebMfs[vertexOrder[1]] = l[1];
        fusedWebMfs = delete(fusedWebMfs,vertexOrder[2]);
        
        // 3. Gradings
        if( useGrading )
        {
            list fusedWebMfGr = mfGradings;
            fusedWebMfGr[vertexOrder[1]] = l[2];
            fusedWebMfGr = delete(fusedWebMfGr,vertexOrder[2]);
        }
        
        list fusedWeb = list(fusedWebVertices, fusedWebMfs);
        kill fusedWebVertices, fusedWebMfs;
                
        if( useGrading ){ fusedWeb = fusedWeb + list(fusedWebMfGr); }
        
        if( useSanityChecks )
        {
            if( !webVerify( fusedWeb ) )
            {
                print("[webCompile] Fused web is not valid, exiting.");
                return();
            }
        }
        
        // Next we rearrange the compilation strategy. The vertices is simple: we have
        // replaced the first vertex in the strategy by the fusion, so we just drop the
        // second entry of vertexOrder
        list fusedVertexOrder = delete(vertexOrder,2);
        
        for(i=1;i<=size(fusedVertexOrder);i++)
        {
            if( fusedVertexOrder[i] > vertexOrder[2] )
            {
                fusedVertexOrder[i] = fusedVertexOrder[i] - 1;
            }
        }
        
        list fusedVarOrder;
        
        // Our new set of internal variables is the old one with all the variables we
        // squeezed out removed. Note that here is where we update numInternalVar
        int i;
        for(i=1;i<=size(varOrder);i++)
        {
            poly u = varOrder[i];

            if( !checklist(substrat_var,u) )
            {
                fusedVarOrder = fusedVarOrder + list(u);
            }
            else
            {
                // u is an internal variable which was squeezed out, so
                // reduce our internal variable count appropriately
                numInternalVar--;
            }
        }
        
        list fusedStrat = list(fusedVertexOrder, fusedVarOrder);
        kill fusedVertexOrder, fusedVarOrder;
                
        // Now we go to the ring nR(count+1), which is nR(count) with the internal
        // variables that we just squeezed out removed. Recall that substrat_var
        // contains a list of these variables
        list rlist = ringlist(nR(count));
        
        list newvar;
        for(i=1;i<=size(rlist[2]);i++)
        {
            if( !checklist(substrat_varStr, rlist[2][i]) )
            {
                newvar = newvar + list(rlist[2][i]);
            }
        }

        list newringList;
        newringList[1] = rlist[1];
        newringList[2] = newvar;
        newringList[3] = rlist[3];
        newringList[4] = rlist[4];
        kill rlist;
        
        // Fix the variable weighting
        intvec kk = (1..size(newvar));
        for(i=1; i<=size(newvar); i++)
        {
            kk[i] = 1;
        }
        newringList[3][1][2] = kk;
        kill kk;
        
        // Create our new ring
        def nR(count+1) = ring(newringList);
        kill newringList;
        
        // Do some kills before switching rings. All we need to keep are fusedWeb
        // and fusedStrat
        kill vertices, mfs, vertexOrder, varOrder, adjacent_var, adjacent_varStr;
        kill vertex(1), vertex(2), mf(1), mf(2), substrat_var, substrat_varStr;
        
        setring nR(count+1);
        
        list web = imap(nR(count),fusedWeb);
        
        // If the number of internal variables is zero, then fusedStrat is not defined
        // in nR(count) but rather is just a global, since it contains no ring variables
        if( numInternalVar > 0 )
        {
            list compStrat = imap(nR(count),fusedStrat);
        }
        else
        {
            list compStrat = fusedStrat;
        }
        kill nR(count);
        
        // Increment the counter, get ready to go again!
        count++;
    }
    
    // We exited after exhausting our internal variables, with valid web and compStrat.
    // So the first entry in the mfs list of web is our final answer
    setring RRR;
    list web = imap(nR(count),web);
    kill nR(count);
    
    matrix A = web[2][1];
    list retlist = A;
    kill A;
    
    if( useGrading )
    {
        //print(size(web[3])); //debug
        //defined(Agr);
        
        intvec Agr = web[3][1]; 
        retlist = retlist + list(Agr);
        //print(Agr);
        //print("---");
        //print(retlist[size(retlist)]);
    }
    
    retlist = retlist + list(splittingRecord);
    kill splittingRecord;
    dbprint(printlevel, "[webCompile] total elapsed time " + string(timer-timeElapsed) + "ms.");
    
    return(retlist);
}

/////////////////////////////////////////////////
// webCompileMorphism
//
// Given a pair of webs, which we assume only differ with regards to the matrix factorisations
// (and possibly their gradings) assigned to the vertices (i.e. we assume that the vertices are
// the same and in the same order), a compilation strategy, and a morphism F from the matrix
// factorisation at vertex mapPos in the first web to the matrix factorisation at the same
// vertex in the second web, we return the induced morphism between the compilations of the
// two webs. We assume that the matrix factorisations in the web agree except possibly at
// the specified vertex mapPos.
//
// NOTE: mapPos is an index into the ordering of the vertices determined by the compilation
// strategy. This is important.
//
// Recall that the first output of webCompile is the differential on the "compilation" MF,
// which we earlier referred to as Y. Let Y1 denote the compilation of web1 and Y2 the
// compilation of web2. Our first return value here is a even block matrix C representing
// the morphism Y1 --> Y2 compiling F.
//
// In the special case where the potential is zero and we end up with nonsquare matrices,
// we return not a block matrix but a pair (c0,c1) which give the compiled map in each
// degree.
//
// You can distinguish the two cases by the fact that typeof( ) in the first case is matrix
// and in the second case is list.

proc webCompileMorphism(list web1, list web2, list compStrat, matrix M, int mapPos)
{
    list compile(1) = webCompile(web1, compStrat);
    list compile(2) = webCompile(web2, compStrat);
    
    matrix A = webCompileMorphismFromData( web1, compile(1), web2, compile(2), compStrat, M, mapPos );
    return(A);
}

proc webCompileMorphismFromData(list web1, list compile(1), list web2, list compile(2), list compStrat, matrix M, int mapPos)
{
    int useSanityChecks = blowFlags("sanity_checks");
    int useGrading = (size(web1) > 2);
    
    list stratVertices = compStrat[1];
    
    list vertices = web1[1];
    list mfs(1) = web1[2];
    list mfs(2) = web2[2];
    if( useGrading )
    {
        list mfsgr(1) = web1[3];
        list mfsgr(2) = web2[3];
    }
    
    // Now we walk through the compilation strategy. Here's roughly what's going to happen.
    // Suppose our mfs are mf(1), ..., mf(v), ordered according to the compilation strategy.
    // This means that, somewhat confusingly, mf(i) is mfs(1)[stratVertices[i]].
    // What the compilation process does is tensor mf(1) with mf(2), tensor this with a 
    // finite-dimensional algebra to cut down to the ring without any of the variables that
    // lie between the vertices at which mf(1), mf(2) sit (we call this "inflation") reduce this 
    // inflation, and split an idempotent on this reduction. Let us call the result of this
    // splitting mf(1,2). Note the three steps
    //
    //  1. Inflate, using mablow (let us call this B for blow)
    //  2. Reduce (giving a homotopy equivalence between B and its reduction)
    //  3. Split an idempotent (gives a pair of maps splitting the idempotent).
    //
    // In the end we have a pair F: B[1] --> mf(1,2) and G: mf(1,2) --> B[1] such that
    // F * G = 1 and G * F is the idempotent splitting to give the pushforward of mf(1) * mf(2)
    // (in the infinite category) (these equalities are up to homotopy).
    //
    // It is this pair (F,G) which is recorded in the so-called "splitting records" which
    // are returned by webCompile (see mfPushforward, mfPushforwardInductive and webCompilePair
    // for how these things are put together).
    //
    // These steps are then repeated, to obtain mf(1,2,3) from mf(1,2) * mf(3), and so on.
    //
    // Suppose for the sake of simplicity that mapPos = 3, and write mf'(i) for the MFs occurring
    // in web2. Hence M is a map mf(3) --> mf'(3). Then we have an induced map
    //
    // mf(1,2) * mf(3) --> mf(1,2) * mf'(3).
    //
    // Inflating this using mablow, suspending, and precomposing with the appropriate G and
    // postcomposing with the appropriate F we get a map
    //
    // mf(1,2,3) --> mf'(1,2,3)
    //
    // Tensoring with mf(4) = mf'(4) and inflating, pre and post-composing, etc. we continue
    // to keep track of this map until at the end we have the desired map
    //
    // C: mf(1,..,v) --> mf'(1,..,v).
        
    if( useSanityChecks )
    {
        // First check that apart from mapPos the mfs agre
        int i;
        for(i=1; i<=size(vertices); i++)
        {
            if( i != mapPos && mfs(1)[stratVertices[i]] != mfs(2)[stratVertices[i]] )
            {
                print("[webCompileMorphism] Matrix factorisations in position " + string(stratVertices[i]) + " differ, exiting.");
                return();
            }
        }
        
        // Check that M is actually a morphism
        if( M * mfs(1)[stratVertices[mapPos]] != mfs(2)[stratVertices[mapPos]] * M )
        {
            print("[webCompileMorphism] Given matrix is not a morphism, exiting.");
            return();
        }
    }
    
    // The first task is to fastforward to the mapPos - 1 position in the compilation
    // by looking up the differential on mf(1,2,...,mapPos - 1).
    int nonsquare = (typeof(compile(1)[1]) == "string");
    
    // For nonsquare matrices compile looks like string, [intvec,intvec,] list and for
    // square matrices it looks like matrix, [intvec,] list, with the list being the
    // global splitting record.
    
    list splitRec(1) = compile(1)[2 + (nonsquare + 1)*useGrading];
    list splitRec(2) = compile(2)[2 + (nonsquare + 1)*useGrading];
    
    // See webCompile's introduction for the full details on the format of the things
    // in the splitting record. We just recall here that entries are tuples (Z, [gr,] R)
    // where Z is the differential on some mf(1,..,i) and R is the splitting record for
    // the production of Z from mf(1,..,i-1) * mf(i). Note the white lie above; actually
    // we have the inflate-reduce-split triumvirate for _each_ internal variable, and hence
    // a list R of pairs of F,G maps.
    //
    // Note that the ith position in the split record speaks about the fusion of
    // mf(1,...,i) with mf(i+1).
    
    int startPoint;
    if( mapPos > 2 )
    {
        list record = splitRec(1)[mapPos - 2];
        
        // The compilations of web1 and web2 should agree up to this point
        if( useSanityChecks )
        {
            if( record[1] != splitRec(2)[mapPos - 2][1] )
            {
                print("[webCompileMorphism] Expected equal compilations, but this was not true. Exiting.");
                return();
            }
        }
        
        // Replace M by mf(1,..,mapPos-1) * mf(mapPos) --> mf(1,..,mapPos-1) * mf'(mapPos)
        M = ZZtensor( unitmat(ncols(record[1])), M );
        startPoint = mapPos - 1;
    }
    
    if( mapPos == 2 )
    {
        // Replace M by mf(1) * mf(2) --> mf(1) * mf'(2).
        M = ZZtensor( unitmat(ncols(mfs(1)[stratVertices[1]])), M );
        startPoint = 1;
    }
    
    if( mapPos == 1 )
    {
        // Replace M by mf(1) * mf(2) --> mf'(1) * mf(2)
        M = ZZtensor( M, unitmat(ncols(mfs(1)[stratVertices[2]])) );
        startPoint = 1;
    }
    
    // Now we're ready to step through the splitting record
    int i;
    for(i=startPoint;i<=size(splitRec(1));i++)
    {
        // Currently M is a map mf(1,...i) * mf(i+1) --> mf'(1,...,i) * mf'(i+1).
        
        // Check whether we are in the step with nonsquare matrices
        if( typeof(splitRec(1)[i][1]) == "string" )
        {
            // This should be the last splitting in the splitting record
            if( i != size(splitRec(1)) )
            {
                print("[webCompileMorphism] Found nonsquare matrices before the end of the splitting record, exiting.");
                return();
            }
            
            // If the second web is not also in this state, something is wrong
            if( typeof(splitRec(2)[i][1]) != "string" )
            {
                print("[webCompileMorphism] Found nonsquare matrices in only one splitting record, exiting.");
                return();
            }
            
            // In this case the local splitting record lives in a different position, as splitRec(1)[i]
            // is a tuple ("nonsquare",[r1,r2,],R) with the last entry of R a tuple (f0,f1,g0,g1,u,N)
            // with f0,g0 splitting the even part of the very last idempotent and similarly for f1,g1.
            
            list R(1) = splitRec(1)[i][2 + 2*useGrading];
            list R(2) = splitRec(2)[i][2 + 2*useGrading];
        }
        else
        {
            // This is the standard case of square matrices
            
            // Extract the R lists for web1 and web2 mentioned above
            list R(1) = splitRec(1)[i][2 + useGrading];
            list R(2) = splitRec(2)[i][2 + useGrading];    
        }
        
        //displaySplittingRecord(R(1)); //debug
        
        // A splitting record R looks like a list of tuples (F,G,u,N) where
        // F is a map Ablow[1] --> final, G is a map final --> Ablow[1] and
        // u is the internal variable being squeezed out, N is the power such that
        // u^N acts null-homotopically.    
            
        // Unless it is the last step where we get nonsquare matrices, in which case
        // there is a tuple (f0,f1,g0,g1,u,N).
    
        int j;
        for(j=1;j<=size(R(1));j++)
        {
            if( size(R(1)[j]) > 4 )
            {
                // This is a step with nonsquare matrices, hence it must be the last
                if( j != size(R(1)) )
                {
                    print("[webCompileMorphism] Found nonsquare matrices in local splitting record before the end, exiting.");
                    return();
                }
                                        
                matrix f0 = R(2)[j][1]; // Note the F must come from the second web
                // TODONils: Maybe f1 and g0 have to be swapped in the sense that
                matrix f1 = R(2)[j][2];
                matrix g0 = R(1)[j][3]; // and the G from the first
                // has to be replaced by:
//                matrix f1 = R(2)[j][3];
//                matrix g0 = R(1)[j][2]; // and the G from the first
               // But this is not true! 


                matrix g1 = R(1)[j][4];
                poly u = R(1)[j][5];
                int expo = R(1)[j][6];

                // Inflate and suspend
                matrix Minf = mfInflate(M,u,expo);
                M = mfSuspendMorph( Minf );
                kill Minf;
                    
                list mblock = extractblockmat(M);
                matrix m0 = mblock[1];
                matrix m1 = mblock[4];

                // Premultiply by G and postmultiply by F
                m0 = f0 * m0 * g0;
                m1 = f1 * m1 * g1;
                    
                list retlist = list(m0,m1);
                kill mblock, m0, m1, f0, f1, g0, g1, u, expo;
                    
                return(retlist);
            }
                
            poly u = R(1)[j][3];
            int expo = R(1)[j][4];
            matrix F = R(2)[j][1];
            matrix G = R(1)[j][2];
            
            // First we need to inflate and suspend. u = R(1)[3], N = R(1)[4]
            M = mfSuspendMorph( mfInflate(M,u,expo) );
                        
            // Now premultiply by G and postmultiply by F
            M = F * M * G;
            
            kill u, expo, F, G;
        }
        
        // Now M is a map mf(1,...,i+1) --> mf'(1,...,i+1). It remains to tensor
        // with the next MF and then we can start again
        M = ZZtensor( M, unitmat(ncols(mfs(1)[stratVertices[i+2]])) );
    }
    
    return(M);
}
